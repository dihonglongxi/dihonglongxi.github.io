{"pages":[{"text":"首先，本人需要声明一下，本文所移植FreeModbus的过程仅能用作参考，虽然FreeModbus的库已经用在工程很多年，但是由于移植的代码，本人经验等问题，所以本人不建议您直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我在此次移植过程中，主要用到以下几个程序与工具： 32F411EDISCOVERY FreeModbus v1.5 Modbus Poll v6.3.0 STM32CubeMX_V4.8.0 STM32Cube_FW_F4_V1.6.0 Keil_MDK_ARM_V5.15.0 在移植过程中，主要用到芯片的外设有USART1（PB6、PB7）和TIMER11，请您根据实际情况进行设置。其中TIMER的设置，您需要设置时钟的信号基准为50uS，时钟产生中断的时间为1750uS（串口波特率大于19200时，在mbrtu.c中有具体的描述），也就是35个基准时间。 二、拷贝需要的文件到工程目录下 1、解压缩通过下载得到的freemodbus-v1.5.zip。 2、按照下列的文件列表拷贝相应的文件到对应的目录（没有路径，需要自己建），并在 keil中设置好相应的头文件引用路径和源码文件的引用。 拷贝文件到工程文件夹示例： 工程文件夹 │ . mxproject │ < 工程名 > . ioc │ ├─ Drivers //底层驱动文件夹 ├─ Inc //头文件存放位置 │ │ gpio . h │ │ stm32f4xx_hal_conf . h │ │ stm32f4xx_it . h │ │ tim . h │ │ usart . h │ │ │ └─ Modbus //Modbus需要用到的头文件 │ ├─ modbus_driver //Modbus函数等头文件 │ │ ├─ include //Modbus通用函数头文件 │ │ │ mb . h │ │ │ mbconfig . h │ │ │ mbframe . h │ │ │ mbfunc . h │ │ │ mbport . h │ │ │ mbproto . h │ │ │ mbutils . h │ │ │ │ │ └─ rtu //Modbus RTU函数头文件 │ │ mbcrc . h │ │ mbrtu . h │ │ │ └─ modbus_user //Modbus用户配置头文件 │ port . h │ ├─ MDK - ARM │ BPEER_USART_TEST . uvprojx │ └─ Src │ gpio . c │ main . c │ stm32f4xx_hal_msp . c │ stm32f4xx_it . c │ tim . c │ usart . c │ └─ Modbus //Modbus需要用到的源码文件 ├─ modbus_driver │ │ mb . c //Modbus基本函数和设置源码文件 │ │ │ ├─ functions //Modbus通用函数源码文件 │ │ mbfunccoils . c │ │ mbfuncdiag . c │ │ mbfuncdisc . c │ │ mbfuncholding . c │ │ mbfuncinput . c │ │ mbfuncother . c │ │ mbutils . c │ │ │ └─ rtu //Modbus RTU函数源码文件 │ mbcrc . c │ mbrtu . c │ └─ modbus_user //Modbus用户配置源码文件 portevent . c portserial . c porttimer . c 三、搞定Timer Timer的移植过程中，应该算是比较简单的了，需要简单的设置一下初始化的返回值，完整写出开启Timer的函数，停止Timer的函数，并对Timer回掉函数进行设置下，就OK了。 porttimer.c移植后的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* ----------------------- Platform includes ----------------------------*/ #include \"port.h\" #include \"stm32f4xx_hal.h\" #include \"tim.h\" /* ----------------------- Modbus includes ------------------------------*/ #include \"mb.h\" #include \"mbport.h\" /* ----------------------- static functions -----------------------------*/ /* ----------------------- Private define -------------------------------*/ #ifndef Modbus_TimHandle #define Modbus_TimHandle htim11 #endif /* ----------------------- Start implementation -------------------------*/ BOOL xMBPortTimersInit ( USHORT usTim1Timerout50us ) { /*系统初始化已经完成定时器的初始化，故在此不在进行初始化*/ return TRUE ; } inline void vMBPortTimersEnable ( ) { /* Enable the timer with the timeout passed to xMBPortTimersInit( ) */ /*Disable Timer and Reset Counter*/ HAL_TIM_Base_Stop_IT ( & Modbus_TimHandle ); __HAL_TIM_SET_COUNTER ( & Modbus_TimHandle , 0x0000 ); /*Enable Timer*/ HAL_TIM_Base_Start_IT ( & Modbus_TimHandle ); } inline void vMBPortTimersDisable ( ) { /* Disable any pending timers. */ HAL_TIM_Base_Stop_IT ( & Modbus_TimHandle ); } /* Create an ISR which is called whenever the timer has expired. This function * must then call pxMBPortCBTimerExpired( ) to notify the protocol stack that * the timer has expired. */ void prvvTIMERExpiredISR ( void ) { ( void ) pxMBPortCBTimerExpired (); } stm32f4xx_it.c移植后的部分代码如下所示： #!c / Includes ------------------------------------------------------------------ / #include \"stm32f4xx_hal.h\" #include \"stm32f4xx.h\" #include \"stm32f4xx_it.h\" /* USER CODE BEGIN 0 */ # include \"mb.h\" # include \"mbport.h\" extern void prvvUARTTxReadyISR ( void ); extern void prvvUARTRxISR ( void ); extern void prvvTIMERExpiredISR ( void ); /* USER CODE END 0 */ …… …… …… /* USER CODE BEGIN 1 */ void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { /* NOTE : This function Should not be modified, when the callback is needed, the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file */ prvvTIMERExpiredISR ( ); } /* USER CODE END 1 */ 四、搞定串口 串口比较难搞一些了，需要设置中断处理函数、串口初始化函数、串口输入输出函数、串口中断服务函数。 portserial.c移植后的代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #include \"port.h\" #include \"usart.h\" #include \"stm32f4xx_hal.h\" #include \"stm32f4xx_it.h\" /* ----------------------- Modbus includes ------------------------------*/ #include \"mb.h\" #include \"mbport.h\" /* ----------------------- static functions -----------------------------*/ void prvvUARTTxReadyISR ( void ); void prvvUARTRxISR ( void ); /* ----------------------- Private define -------------------------------*/ #ifndef Modbus_UartHandle #define Modbus_UartHandle huart1 #endif /* ----------------------- Start implementation -------------------------*/ void vMBPortSerialEnable ( BOOL xRxEnable , BOOL xTxEnable ) { /* If xRXEnable enable serial receive interrupts. If xTxENable enable * transmitter empty interrupts. */ if ( xRxEnable ) { /* Enable the UART Data Register not empty Interrupt */ __HAL_UART_ENABLE_IT ( & Modbus_UartHandle , UART_IT_RXNE ); } else { /* Disable the UART Data Register not empty Interrupt */ __HAL_UART_DISABLE_IT ( & Modbus_UartHandle , UART_IT_RXNE ); } if ( xTxEnable ) { /* Enable the UART Transmit data register empty Interrupt */ __HAL_UART_ENABLE_IT ( & Modbus_UartHandle , UART_IT_TXE ); prvvUARTTxReadyISR (); } else { /* Disable the UART Transmit data register empty Interrupt */ __HAL_UART_DISABLE_IT ( & Modbus_UartHandle , UART_IT_TXE ); /* Enable the UART Transmit Complete Interrupt */ __HAL_UART_ENABLE_IT ( & Modbus_UartHandle , UART_IT_TC ); } } BOOL xMBPortSerialInit ( UCHAR ucPORT , ULONG ulBaudRate , UCHAR ucDataBits , eMBParity eParity ) { /*由于已经在系统初始化中已经完成串口初始化，故在此不需要再一次进行初始化*/ return TRUE ; } BOOL xMBPortSerialPutByte ( CHAR ucByte ) { /* Put a byte in the UARTs transmit buffer. This function is called * by the protocol stack if pxMBFrameCBTransmitterEmpty( ) has been * called. */ if ( HAL_UART_Transmit ( & Modbus_UartHandle ,( uint8_t * ) & ucByte , 1 , 0x01 ) != HAL_OK ) { return FALSE ; } else { return TRUE ; } } BOOL xMBPortSerialGetByte ( CHAR * pucByte ) { /* Return the byte in the UARTs receive buffer. This function is called * by the protocol stack after pxMBFrameCBByteReceived( ) has been called. */ if ( HAL_UART_Receive ( & Modbus_UartHandle ,( uint8_t * ) pucByte , 1 , 0x01 ) != HAL_OK ) { return FALSE ; } else { return TRUE ; } } /* Create an interrupt handler for the transmit buffer empty interrupt * (or an equivalent) for your target processor. This function should then * call pxMBFrameCBTransmitterEmpty( ) which tells the protocol stack that * a new character can be sent. The protocol stack will then call * xMBPortSerialPutByte( ) to send the character. */ void prvvUARTTxReadyISR ( void ) { pxMBFrameCBTransmitterEmpty ( ); } /* Create an interrupt handler for the receive interrupt for your target * processor. This function should then call pxMBFrameCBByteReceived( ). The * protocol stack will then call xMBPortSerialGetByte( ) to retrieve the * character. */ void prvvUARTRxISR ( void ) { pxMBFrameCBByteReceived ( ); } stm32f4xx_it.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @brief This function handles USART1 global interrupt. */ void USART1_IRQHandler ( void ) { /* USER CODE BEGIN USART1_IRQn 0 */ if ( __HAL_UART_GET_IT_SOURCE ( & huart1 , UART_IT_RXNE ) != RESET ) { prvvUARTRxISR (); //接收中断处理函数 } if ( __HAL_UART_GET_IT_SOURCE ( & huart1 , UART_IT_TXE ) != RESET ) { prvvUARTTxReadyISR (); //发送完成终端处理函数 } HAL_NVIC_ClearPendingIRQ ( USART1_IRQn ); /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler ( & huart1 ); /* USER CODE BEGIN USART1_IRQn 1 */ /* USER CODE END USART1_IRQn 1 */ } 五、搞定其他配置 1、搞定开关中断操作 port.h移植后的部分代码如下所示： 1 2 3 4 /*禁用全部中断*/ #define ENTER_CRITICAL_SECTION( ) __disable_irq() /*开启全部中断*/ #define EXIT_CRITICAL_SECTION( ) __enable_irq() 2、搞定系统配置 mb.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*设置启用Modbus RTU 模式，减少编译后的代码量*/ #if MB_RTU_ENABLED == 1 #include \"mbrtu.h\" #endif /*减少编译后代码错误以及修改，将判定值由1改为0，并修改MB_ASCII_ENABLED的定义为0， 想要了解原因，请自行修改编译查看*/ #if MB_ASCII_ENABLED == 1 #include \"mbascii.h\" #endif /*减少编译后代码大小，将判定值由0改为1，并修改MB_TCP_ENABLED的定义为0，想要了解 原因，请自行修改编译查看*/ #if MB_TCP_ENABLED == 1 #include \"mbtcp.h\" #endif 3、搞定寄存器地址差一的问题 需要在源码中注释掉所有的 usRegAddress++; 。 4、搞定keil编译过程中出现的各种警告 mb.h移植后的部分代码如下所示： 1 2 3 4 5 6 extern void xMBUtilSetBits ( UCHAR * ucByteBuf , USHORT usBitOffset , UCHAR ucNBits , \\ UCHAR ucValue ); extern UCHAR xMBUtilGetBits ( UCHAR * ucByteBuf , USHORT usBitOffset , UCHAR ucNBits ); mbrtu.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 eMBErrorCode eMBRTUReceive ( UCHAR * pucRcvAddress , UCHAR ** pucFrame , USHORT * pusLength ) { /*处女座心理，必须要求无错误、无警告、可过PC-Lint，目前也没有发现这个定义的用处*/ // BOOL xFrameReceived = FALSE; eMBErrorCode eStatus = MB_ENOERR ; ENTER_CRITICAL_SECTION ( ); assert ( usRcvBufferPos < MB_SER_PDU_SIZE_MAX ); /* Length and CRC check */ if ( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN ) && ( usMBCRC16 ( ( UCHAR * ) ucRTUBuf , usRcvBufferPos ) == 0 ) ) { /* Save the address field. All frames are passed to the upper layed * and the decision if a frame is used is done there. */ * pucRcvAddress = ucRTUBuf [ MB_SER_PDU_ADDR_OFF ]; /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus * size of address field and CRC checksum. */ * pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC ); /* Return the start of the Modbus PDU to the caller. */ * pucFrame = ( UCHAR * ) & ucRTUBuf [ MB_SER_PDU_PDU_OFF ]; // xFrameReceived = TRUE; } else { eStatus = MB_EIO ; } EXIT_CRITICAL_SECTION ( ); return eStatus ; } 5、未知原因的添加代码 这部分代码没有明白，为什么需要添加，有些没有研究透，希望有大神可以指点。 mbrtu.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 eMBErrorCode eMBRTUSend ( UCHAR ucSlaveAddress , const UCHAR * pucFrame , USHORT usLength ) { eMBErrorCode eStatus = MB_ENOERR ; USHORT usCRC16 ; ENTER_CRITICAL_SECTION ( ); /* Check if the receiver is still in idle state. If not we where to * slow with processing the received frame and the master sent another * frame on the network. We have to abort sending the frame. */ if ( eRcvState == STATE_RX_IDLE ) { /* First byte before the Modbus-PDU is the slave address. */ pucSndBufferCur = ( UCHAR * ) pucFrame - 1 ; usSndBufferCount = 1 ; /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */ pucSndBufferCur [ MB_SER_PDU_ADDR_OFF ] = ucSlaveAddress ; usSndBufferCount += usLength ; /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */ usCRC16 = usMBCRC16 ( ( UCHAR * ) pucSndBufferCur , usSndBufferCount ); ucRTUBuf [ usSndBufferCount ++ ] = ( UCHAR )( usCRC16 & 0xFF ); ucRTUBuf [ usSndBufferCount ++ ] = ( UCHAR )( usCRC16 >> 8 ); /* Activate the transmitter. */ eSndState = STATE_TX_XMIT ; /*插入代码 启动第一次发送，这样才可以进入发送完成中断*/ xMBPortSerialPutByte ( ( CHAR ) * pucSndBufferCur ); pucSndBufferCur ++ ; usSndBufferCount -- ; vMBPortSerialEnable ( FALSE , TRUE ); } else { eStatus = MB_EIO ; } EXIT_CRITICAL_SECTION ( ); return eStatus ; } 六、搞定主函数 主函数需要设置数组和处理函数，无其他设置，我放上我移植的代码以供参考。 main.c移植后的代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 /* Includes -------------------------------------------------------------*/ #include \"stm32f4xx_hal.h\" #include \"adc.h\" #include \"tim.h\" #include \"usart.h\" #include \"gpio.h\" /* USER CODE BEGIN Includes */ #include \"mb.h\" #include \"mbport.h\" /* USER CODE END Includes */ /* Private variables ----------------------------------------------------*/ /* USER CODE BEGIN PV */ /*线圈状态寄存器*/ #define REG_COILS_START 0x0000 #define REG_COILS_SIZE 8 /*线圈状态输入寄存器*/ #define REG_DISCRETE_START 0x0000 #define REG_DISCRETE_SIZE 8 /*保持寄存器*/ #define REG_HOLDING_START 0x0000 #define REG_HOLDING_NREGS 10 /*输入寄存器*/ #define REG_INPUT_START 0x0000 #define REG_INPUT_NREGS 1 /* USER CODE END PV */ /* Private function prototypes ------------------------------------------*/ void SystemClock_Config ( void ); /* USER CODE BEGIN PFP */ /* USER CODE END PFP */ /* USER CODE BEGIN 0 */ /*定义线圈状态寄存器的地址起始值和存储数组*/ uint8_t ucRegCoilsStart = REG_HOLDING_START ; uint8_t ucRegCoilsBuf [ REG_COILS_SIZE / 8 ]; /*定义线圈输入状态寄存器的地址起始值和存储数组*/ uint8_t ucRegDiscreteStart = REG_HOLDING_START ; uint8_t ucRegDiscreteBuf [ REG_DISCRETE_SIZE / 8 ]; /*定义保持寄存器的地址起始值和存储数组*/ uint16_t usRegHoldingStart = REG_HOLDING_START ; uint16_t usRegHoldingBuf [ REG_HOLDING_NREGS ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 }; /*定义输入寄存器的地址起始值和存储数组*/ uint16_t usRegInputStart = REG_INPUT_START ; uint16_t usRegInputBuf [ REG_INPUT_NREGS ]; /* USER CODE END 0 */ int main ( void ) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration-------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init (); /* Configure the system clock */ SystemClock_Config (); /* Initialize all configured peripherals */ MX_GPIO_Init (); MX_ADC1_Init (); MX_TIM1_Init (); MX_TIM4_Init (); MX_TIM11_Init (); MX_USART1_UART_Init (); /* USER CODE BEGIN 2 */ /*设置Modnbus以RTU模式运行，从机ID为0x01，串口为默认串口，串口波特率为115200，无奇偶校验*/ eMBInit ( MB_RTU , 0x01 , 1 , 115200 , MB_PAR_NONE ); /* Enable the Modbus Protocol Stack. */ eMBEnable (); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while ( 1 ) { ( void ) eMBPoll (); __HAL_TIM_SetCompare ( & htim4 , TIM_CHANNEL_1 , usRegHoldingBuf [ 0 ]); __HAL_TIM_SetCompare ( & htim4 , TIM_CHANNEL_2 , usRegHoldingBuf [ 1 ]); __HAL_TIM_SetCompare ( & htim4 , TIM_CHANNEL_3 , usRegHoldingBuf [ 2 ]); __HAL_TIM_SetCompare ( & htim4 , TIM_CHANNEL_4 , usRegHoldingBuf [ 3 ]); HAL_TIM_PWM_Start ( & htim4 , TIM_CHANNEL_1 ); HAL_TIM_PWM_Start ( & htim4 , TIM_CHANNEL_2 ); HAL_TIM_PWM_Start ( & htim4 , TIM_CHANNEL_3 ); HAL_TIM_PWM_Start ( & htim4 , TIM_CHANNEL_4 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } /** System Clock Configuration */ void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct ; RCC_ClkInitTypeDef RCC_ClkInitStruct ; __PWR_CLK_ENABLE (); __HAL_PWR_VOLTAGESCALING_CONFIG ( PWR_REGULATOR_VOLTAGE_SCALE2 ); RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = 16 ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLM = 8 ; RCC_OscInitStruct . PLL . PLLN = 200 ; RCC_OscInitStruct . PLL . PLLP = RCC_PLLP_DIV4 ; RCC_OscInitStruct . PLL . PLLQ = 4 ; HAL_RCC_OscConfig ( & RCC_OscInitStruct ); RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV2 ; RCC_ClkInitStruct . APB2CLKDivider = RCC_HCLK_DIV1 ; HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_3 ); HAL_SYSTICK_Config ( HAL_RCC_GetHCLKFreq () / 1000 ); HAL_SYSTICK_CLKSourceConfig ( SYSTICK_CLKSOURCE_HCLK ); } /* USER CODE BEGIN 4 */ /** * @brief 输入寄存器处理函数，输入寄存器可读，但不可写。 * @param pucRegBuffer 返回数据指针 * usAddress 寄存器起始地址 * usNRegs 寄存器长度 * @retval eStatus 寄存器状态 */ eMBErrorCode eMBRegInputCB ( UCHAR * pucRegBuffer , USHORT usAddress , USHORT usNRegs ) { eMBErrorCode eStatus = MB_ENOERR ; int16_t iRegIndex ; // 用作例子 usRegInputBuf [ 0 ] = 0x11 ; // 例子结束 //查询是否在寄存器范围内 //为了避免警告，修改为有符号整数 if ( (( int16_t ) usAddress >= REG_INPUT_START ) \\ && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) ) { //获得操作偏移量，本次操作起始地址-输入寄存器的初始地址 iRegIndex = ( int16_t )( usAddress - usRegInputStart ); //逐个赋值 while ( usNRegs > 0 ) { //赋值高字节 * pucRegBuffer ++ = ( uint8_t )( usRegInputBuf [ iRegIndex ] >> 8 ); //赋值低字节 * pucRegBuffer ++ = ( uint8_t )( usRegInputBuf [ iRegIndex ] & 0xFF ); //偏移量增加 iRegIndex ++ ; //被操作寄存器数量递减 usNRegs -- ; } } else { //返回错误状态，寄存器数量不对 eStatus = MB_ENOREG ; } return eStatus ; } /** * @brief 保持寄存器处理函数，保持寄存器可读，可读可写 * @param pucRegBuffer 读操作时--返回数据指针，写操作时--输入数据指针 * usAddress 寄存器起始地址 * usNRegs 寄存器长度 * eMode 操作方式，读或者写 * @retval eStatus 寄存器状态 */ eMBErrorCode eMBRegHoldingCB ( UCHAR * pucRegBuffer , USHORT usAddress , USHORT usNRegs , eMBRegisterMode eMode ) { //错误状态 eMBErrorCode eStatus = MB_ENOERR ; //偏移量 int16_t iRegIndex ; //判断寄存器是不是在范围内 if ( ( ( int16_t ) usAddress >= REG_HOLDING_START ) \\ && ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) ) { //计算偏移量 iRegIndex = ( int16_t )( usAddress - REG_HOLDING_START ); switch ( eMode ) { //读处理函数 case MB_REG_READ : while ( usNRegs > 0 ) { * pucRegBuffer ++ = ( uint8_t )( usRegHoldingBuf [ iRegIndex ] >> 8 ); * pucRegBuffer ++ = ( uint8_t )( usRegHoldingBuf [ iRegIndex ] & 0xFF ); iRegIndex ++ ; usNRegs -- ; } break ; //写处理函数 case MB_REG_WRITE : while ( usNRegs > 0 ) { usRegHoldingBuf [ iRegIndex ] = * pucRegBuffer ++ << 8 ; usRegHoldingBuf [ iRegIndex ] |= * pucRegBuffer ++ ; iRegIndex ++ ; usNRegs -- ; } break ; } } else { //返回错误状态 eStatus = MB_ENOREG ; } return eStatus ; } /** * @brief 线圈寄存器处理函数，线圈寄存器可读，可读可写 * @param pucRegBuffer 读操作---返回数据指针，写操作--返回数据指针 * usAddress 寄存器起始地址 * usNRegs 寄存器长度 * eMode 操作方式，读或者写 * @retval eStatus 寄存器状态 */ eMBErrorCode eMBRegCoilsCB ( UCHAR * pucRegBuffer , USHORT usAddress , USHORT usNCoils , eMBRegisterMode eMode ) { //错误状态 eMBErrorCode eStatus = MB_ENOERR ; //寄存器个数 int16_t iNCoils = ( int16_t ) usNCoils ; //寄存器偏移量 int16_t usBitOffset ; //检查寄存器是否在指定范围内 if ( ( ( int16_t ) usAddress >= REG_COILS_START ) && ( usAddress + usNCoils <= REG_COILS_START + REG_COILS_SIZE ) ) { //计算寄存器偏移量 usBitOffset = ( int16_t )( usAddress - REG_COILS_START ); switch ( eMode ) { //读操作 case MB_REG_READ : while ( iNCoils > 0 ) { * pucRegBuffer ++ = xMBUtilGetBits ( ucRegCoilsBuf , usBitOffset , ( uint8_t )( iNCoils > 8 ? 8 : iNCoils ) ); iNCoils -= 8 ; usBitOffset += 8 ; } break ; //写操作 case MB_REG_WRITE : while ( iNCoils > 0 ) { xMBUtilSetBits ( ucRegCoilsBuf , usBitOffset , ( uint8_t )( iNCoils > 8 ? 8 : iNCoils ), * pucRegBuffer ++ ); iNCoils -= 8 ; } break ; } } else { eStatus = MB_ENOREG ; } return eStatus ; } /** * @brief 开关输入寄存器处理函数，开关输入寄存器，可读 * @param pucRegBuffer 读操作---返回数据指针，写操作--返回数据指针 * usAddress 寄存器起始地址 * usNRegs 寄存器长度 * eMode 操作方式，读或者写 * @retval eStatus 寄存器状态 */ eMBErrorCode eMBRegDiscreteCB ( UCHAR * pucRegBuffer , USHORT usAddress , USHORT usNDiscrete ) { //错误状态 eMBErrorCode eStatus = MB_ENOERR ; //操作寄存器个数 int16_t iNDiscrete = ( int16_t ) usNDiscrete ; //偏移量 uint16_t usBitOffset ; //判断寄存器时候再制定范围内 if ( ( ( int16_t ) usAddress >= REG_DISCRETE_START ) && ( usAddress + usNDiscrete <= REG_DISCRETE_START + REG_DISCRETE_SIZE ) ) { //获得偏移量 usBitOffset = ( uint16_t )( usAddress - REG_DISCRETE_START ); while ( iNDiscrete > 0 ) { * pucRegBuffer ++ = xMBUtilGetBits ( ucRegDiscreteBuf , usBitOffset , ( uint8_t )( iNDiscrete > 8 ? 8 : iNDiscrete ) ); iNDiscrete -= 8 ; usBitOffset += 8 ; } } else { eStatus = MB_ENOREG ; } return eStatus ; } /* USER CODE END 4 */ #ifdef USE_FULL_ASSERT /** * @brief Reports the name of the source file and the source line number * where the assert_param error has occurred. * @param file: pointer to the source file name * @param line: assert_param error line source number * @retval None */ void assert_failed ( uint8_t * file , uint32_t line ) { /* USER CODE BEGIN 6 */ /* User can add his own implementation to report the file name and line number, ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */ /* USER CODE END 6 */ } #endif /** * @} */ /** * @} */ /*************** (C) COPYRIGHT STMicroelectronics *****END OF FILE********/ 七、结语 本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。","tags":"STM32F411VET6","loc":"http://dhlx.wang/Porting_FreeModbus_to_STM32F411VET6_based_on_STM32CubeF4.html","title":"基于STM32CubeF4移植FreeModbus到STM32F411VET6"},{"text":"首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我们在移植AN4657到STM32F411VET6的过程中主要用到以下程序和工具： 32F411EDISCOVERY X-CUBE-IAP-USART(AN4657) Hypertrm STM32CubeMX_V4.8.0 STM32Cube_FW_F4_V1.6.0 Keil_MDK_ARM_V5.15.0 AN4657-STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Inc AN4657-STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Src 二、拷贝需要的文件到工程目录下 1、解压缩通过下载得到的AN4657压缩包。 2、拷贝路径（AN4657-STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Inc）中的 common.h 、 flash_if.h 、 menu.h 、 ymodem.h 到我们自己的工程路径下的Inc文件夹中。 3、拷贝路径（AN4657-STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Src）中的 common.c 、 flash_if.c 、 menu.c 、 ymodem.c 到我们自己的工程路径下的Src文件夹中，并在keil中添加相应的文件。 三、修改串口的基本设置 串口的基本设置在STM32Cube可以进行设置，并生成相应的设置代码，但在我们的移植文件中需要用到串口设置，故我们需要在 common.c 、 menu.c 、 ymodem.c 三个文件中进行修改，我的示例代码是用USART1作为演示。 common.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** @addtogroup STM32F4xx_IAP_Main * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"common.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ /* Private function prototypes ------------------------------------------*/ /* Private functions ----------------------------------------------------*/ menu.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"common.h\" #include \"flash_if.h\" #include \"menu.h\" #include \"ymodem.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ ymodem.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"flash_if.h\" #include \"common.h\" #include \"ymodem.h\" #include \"string.h\" #include \"menu.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif #define CRC16_F /* activate the CRC16 integrity */ /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ P.S. 1、 common.h 、 menu.h 、 ymodem.h 基本不需要任何修改，直接就可以用。 2、如果使用 32F411EDISCOVERY ，请您注意不要使用默认的USART1的IO设置，需要更改为 PB6、PB7，才可以正常使用，默认的TX引脚上接了一个uF级的电容，我因为这个事情调试了很长时间。 三、修改FLASH操作函数及其定义 在整个移植过程中，重头戏就是对 flash_if.h 和 flash_if.c 的移植，里面涉及到很多 处修改，大部分修改是因为M4系列的MCU对FLASH的操作，没有页（Page）的概念，只有扇区（Sector）的操作函数造成的。 所以，综上所述需要先将各种Page（PAGE、page）换成Sector，这样基本上可以解决掉一批错误。 flash_if.h 修改后如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 /* Define to prevent recursive inclusion --------------------------------*/ #ifndef __FLASH_IF_H #define __FLASH_IF_H /* Includes -------------------------------------------------------------*/ //修改引用的头文件为F4的 #include \"stm32f4xx_hal.h\" /* Exported types -------------------------------------------------------*/ /* Exported constants ---------------------------------------------------*/ /* Base address of the Flash sectors */ //定义扇区名和地址之间的关系，方便根据地址获取扇区的编号 #define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000) /* Base @ of Sector 0, 16 Kbyte */ #define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08004000) /* Base @ of Sector 1, 16 Kbyte */ #define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08008000) /* Base @ of Sector 2, 16 Kbyte */ #define ADDR_FLASH_SECTOR_3 ((uint32_t)0x0800C000) /* Base @ of Sector 3, 16 Kbyte */ #define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08010000) /* Base @ of Sector 4, 64 Kbyte */ #define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08020000) /* Base @ of Sector 5, 128 Kbyte */ #define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08040000) /* Base @ of Sector 6, 128 Kbyte */ #define ADDR_FLASH_SECTOR_7 ((uint32_t)0x08060000) /* Base @ of Sector 7, 128 Kbyte */ /* Error code */ enum { FLASHIF_OK = 0 , FLASHIF_ERASEKO , FLASHIF_WRITINGCTRL_ERROR , FLASHIF_WRITING_ERROR , FLASHIF_PROTECTION_ERRROR }; /* protection type */ enum { FLASHIF_PROTECTION_NONE = 0 , FLASHIF_PROTECTION_PCROPENABLED = 0x1 , FLASHIF_PROTECTION_WRPENABLED = 0x2 , FLASHIF_PROTECTION_RDPENABLED = 0x4 , }; /* protection update */ enum { FLASHIF_WRP_ENABLE , FLASHIF_WRP_DISABLE }; /* Define the address from where user application will be loaded. Note: the 1st sector 0x08000000-0x08003FFF is reserved for the IAP code */ //根据实际的片内Flash大小修改结束地址，并删除不用的宏定义 #define APPLICATION_ADDRESS (uint32_t)0x08004000 /* Start user code address */ /* Notable Flash addresses */ #define USER_FLASH_END_ADDRESS (uint32_t)0x0807FFFF /* Define the user application size */ #define USER_FLASH_SIZE (USER_FLASH_END_ADDRESS - APPLICATION_ADDRESS + 1) /* Small default template application */ /* Exported macro -------------------------------------------------------*/ /* ABSoulute value */ #define ABS_RETURN(x,y) ((x) < (y)) ? ((y)-(x)) : ((x)-(y)) /* Get the number of sectors from where the user program will be loaded */ #define FLASH_SECTOR_NUMBER ((uint32_t)(ABS_RETURN(APPLICATION_ADDRESS,FLASH_START_BANK1))>>12) /* Compute the mask to test if the Flash memory, where the user program will be loaded, is write protected */ #define FLASH_PROTECTED_SECTORS (~(uint32_t)((1 << FLASH_SECTOR_NUMBER) - 1)) /* Exported functions --------------------------------------------------*/ void FLASH_If_Init ( void ); uint32_t FLASH_If_Erase ( uint32_t StartSector ); uint32_t FLASH_If_GetWriteProtectionStatus ( void ); uint32_t FLASH_If_Write ( uint32_t destination , uint32_t * p_source , uint32_t length ); uint32_t FLASH_If_WriteProtectionConfig ( uint32_t modifier ); #endif /* __FLASH_IF_H */ /******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ flash_if.c 修改后如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ #include \"flash_if.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ /* Private function prototypes ------------------------------------------*/ //增加获取扇区的函数，方便获取扇区编号 static uint32_t GetSector ( uint32_t Address ); /* Private functions ----------------------------------------------------*/ /** * @brief Unlocks Flash for write access * @param None * @retval None */ void FLASH_If_Init ( void ) { /* Unlock the Program memory */ HAL_FLASH_Unlock (); /* Clear all FLASH flags */ //根据实际的MCU清除FLASH标志位 __HAL_FLASH_CLEAR_FLAG ( FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR ); /* Unlock the Program memory */ HAL_FLASH_Lock (); } /** * @brief This function does an erase of all user flash area * @param start: start of user flash area * @retval FLASHIF_OK : user flash area successfully erased * FLASHIF_ERASEKO : error occurred */ uint32_t FLASH_If_Erase ( uint32_t start ) { //将相关的Page参数均修改为M4的Sector 参数 uint32_t UserStartSector = FLASH_SECTOR_1 ; uint32_t NbrOfSector = 0 ; uint32_t SectorError = 0 ; FLASH_EraseInitTypeDef pEraseInit ; HAL_StatusTypeDef status = HAL_OK ; /* Unlock the Flash to enable the flash control register access *************/ HAL_FLASH_Unlock (); /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); NbrOfSector = FLASH_SECTOR_7 - UserStartSector ; pEraseInit . TypeErase = FLASH_TYPEERASE_SECTORS ; pEraseInit . Sector = UserStartSector ; pEraseInit . Banks = FLASH_BANK_1 ; pEraseInit . NbSectors = NbrOfSector ; pEraseInit . VoltageRange = FLASH_VOLTAGE_RANGE_3 ; status = HAL_FLASHEx_Erase ( & pEraseInit , & SectorError ); /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); if ( status != HAL_OK ) { /* Error occurred while Sector erase */ return FLASHIF_ERASEKO ; } return FLASHIF_OK ; } /* Public functions -----------------------------------------------------*/ /** * @brief This function writes a data buffer in flash (data are 32-bit aligned). * @note After writing data buffer, the flash content is checked. * @param destination: start address for target location * @param p_source: pointer on buffer with data to write * @param length: length of data buffer (unit is 32-bit word) * @retval uint32_t 0: Data successfully written to Flash memory * 1: Error occurred while writing data in Flash memory * 2: Written Data in flash memory is different from expected one */ uint32_t FLASH_If_Write ( uint32_t destination , uint32_t * p_source , uint32_t length ) { uint32_t i = 0 ; /* Unlock the Flash to enable the flash control register access *************/ HAL_FLASH_Unlock (); for ( i = 0 ; ( i < length ) && ( destination <= ( USER_FLASH_END_ADDRESS - 4 )); i ++ ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( HAL_FLASH_Program ( FLASH_TYPEPROGRAM_WORD , destination , * ( uint32_t * )( p_source + i )) == HAL_OK ) { /* Check the written value */ if ( * ( uint32_t * ) destination != * ( uint32_t * )( p_source + i )) { /* Flash content doesn't match SRAM content */ return ( FLASHIF_WRITINGCTRL_ERROR ); } /* Increment FLASH destination address */ destination += 4 ; } else { /* Error occurred while writing data in Flash memory */ return ( FLASHIF_WRITING_ERROR ); } } /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); return ( FLASHIF_OK ); } /** * @brief Returns the write protection status of application flash area. * @param None * @retval If a sector in application area is write-protected returned value is a combinaison of the possible values : FLASHIF_PROTECTION_WRPENABLED, FLASHIF_PROTECTION_PCROPENABLED, ... * If no sector is write-protected FLASHIF_PROTECTION_NONE is returned. */ uint32_t FLASH_If_GetWriteProtectionStatus ( void ) { uint32_t ProtectedSector = FLASHIF_PROTECTION_NONE ; FLASH_OBProgramInitTypeDef OptionsBytesStruct ; /* Unlock the Flash to enable the flash control register access ********/ HAL_FLASH_Unlock (); /*Check if there are write protected sectors inside the user flash area*/ HAL_FLASHEx_OBGetConfig ( & OptionsBytesStruct ); /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); /* Get Sectors already write protected *********************************/ //后面的保护区域，没有看懂，所以直接屏蔽掉了 ProtectedSector = ~ OptionsBytesStruct . WRPSector ; /* Check if desired Sectors are already write protected ****************/ if ( ProtectedSector != 0 ) { /* Some sectors inside the user flash area are write protected */ return FLASHIF_PROTECTION_WRPENABLED ; } else { /* No write protected sectors inside the user flash area */ return FLASHIF_PROTECTION_NONE ; } } /** * @brief Configure the write protection status of user flash area. * @param protectionstate : FLASHIF_WRP_DISABLE or FLASHIF_WRP_ENABLE the protection * @retval uint32_t FLASHIF_OK if change is applied. */ uint32_t FLASH_If_WriteProtectionConfig ( uint32_t protectionstate ) { uint32_t ProtectedSector = 0x0 ; FLASH_OBProgramInitTypeDef config_new , config_old ; HAL_StatusTypeDef result = HAL_OK ; /* Get Sectors write protection status *********************************/ HAL_FLASHEx_OBGetConfig ( & config_old ); /* The parameter says whether we turn the protection on or off */ config_new . WRPState = ( protectionstate == FLASHIF_WRP_ENABLE ? OB_WRPSTATE_ENABLE : OB_WRPSTATE_DISABLE ); /* We want to modify only the Write protection */ config_new . OptionType = OPTIONBYTE_WRP ; /* No read protection, keep BOR and reset settings */ config_new . RDPLevel = OB_RDP_LEVEL_0 ; config_new . USERConfig = config_old . USERConfig ; /* Get Sectors already write protected *********************************/ //后面的保护区域，没有看懂，所以直接屏蔽掉了 ProtectedSector = config_old . WRPSector ; /* Unlock the Flash to enable the flash control register access *******/ HAL_FLASH_Unlock (); /* Unlock the Options Bytes ********************************************/ HAL_FLASH_OB_Unlock (); /* Erase all the option Bytes ******************************************/ //在HAL_F4的库中没有找到擦除命令位的函数，故在此注释掉 //result = HAL_FLASHEx_OBErase(); //if (result == HAL_OK) //{ config_new . WRPSector = ProtectedSector ; result = HAL_FLASHEx_OBProgram ( & config_new ); //} return ( result == HAL_OK ? FLASHIF_OK : FLASHIF_PROTECTION_ERRROR ); } /** * @brief 根据送入地址获取其所在扇区位置 * @param 需要知道所在扇区位置的地址 * @retval 扇区位置（FLASH_SECTOR_0——FLASH_SECTOR_7） */ //增加扇区编号的获取函数 static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_SECTOR_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_SECTOR_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_SECTOR_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_SECTOR_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_SECTOR_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_SECTOR_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_SECTOR_6 ; } else { sector = FLASH_SECTOR_7 ; } return sector ; } /** * @} */ /******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 四、Keil需要修改的位置 1、需要根据设置的APP程序起始的位置，设置KEIL的起始编译位置与程序空间大小 2、需要在User选项卡中增加自定义处理字符串， C:\\Program Files\\Keil\\ARM\\ARMCC\\bin\\fromelf.exe --bin -o .\\存放bin的路径\\bin文件的名称.bin .\\Keil编译后生成的axf的路径\\axf文件的名称.axf 五、结语 关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。","tags":"STM32F411VET6","loc":"http://dhlx.wang/Porting_AN4657_STM32Cube_IAP_using_UART_to_STM32F411VET6.html","title":"移植AN4657到STM32F411VET6"},{"text":"首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我们在移植IAP的过程中主要用到以下三个东西，一个是STM32F411VET6的开发板，一个是待移植的官方的STM32F4-IAP-USART程序，最后一个就是上位机（支持ymodem），这里最好选用官方建议使用的超级终端（Hypertrm）进行测试。 32F411EDISCOVERY STM32F4 IAP using the USART (AN3965) Hypertrm 二、修改串口通讯接口 由于STM32F411VET6中没有USART3，我需要将USART3的配置修改为USART2。这个里面我个人建议修改为与USART3在同一总线上的USART，否则需要进行大量的代码修改。由于我只是进行工程远程调试，暂时不考虑大费周章进行移植和修改，如果后续需要使用，可能会做基于HAL的移植，并对读取Flash的权限做出详细的限制。 下面我们就开始正式的移植过程，我们需要修改工程中的 stm324xg_eval.h 文件中关于USART的宏定义部分。 原始宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART3 */ #define EVAL_COM1 USART3 #define EVAL_COM1_CLK RCC_APB1Periph_USART3 #define EVAL_COM1_TX_PIN GPIO_Pin_10 #define EVAL_COM1_TX_GPIO_PORT GPIOC #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_TX_SOURCE GPIO_PinSource10 #define EVAL_COM1_TX_AF GPIO_AF_USART3 #define EVAL_COM1_RX_PIN GPIO_Pin_11 #define EVAL_COM1_RX_GPIO_PORT GPIOC #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_RX_SOURCE GPIO_PinSource11 #define EVAL_COM1_RX_AF GPIO_AF_USART3 #define EVAL_COM1_IRQn USART3_IRQn 修改后宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART2 */ #define EVAL_COM1 USART2 #define EVAL_COM1_CLK RCC_APB1Periph_USART2 #define EVAL_COM1_TX_PIN GPIO_Pin_2 #define EVAL_COM1_TX_GPIO_PORT GPIOA #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_TX_SOURCE GPIO_PinSource2 #define EVAL_COM1_TX_AF GPIO_AF_USART2 #define EVAL_COM1_RX_PIN GPIO_Pin_3 #define EVAL_COM1_RX_GPIO_PORT GPIOA #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_RX_SOURCE GPIO_PinSource3 #define EVAL_COM1_RX_AF GPIO_AF_USART2 #define EVAL_COM1_IRQn USART2_IRQn P.S.注意您选择USART2的管脚分配，我这里分配的GPIOA2（TX）和GPIOA3（RX）。 三、修改Flash大小定义 由于STM32F411VET6和STM32F407系列的Flash大小不一致，故需要简单修改下Flash的相关函数和定义。 首先，我们需要修改 flash_if.c 中 uint32_t FLASH_If_Erase 的函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_11 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 需要将 FLASH_Sector_11 修改为 FLASH_Sector_7 ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_7 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 其次我们需要修改 flash_if.c 中的 static uint32_t GetSector 函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else if (( Address < ADDR_FLASH_SECTOR_8 ) && ( Address >= ADDR_FLASH_SECTOR_7 )) { sector = FLASH_Sector_7 ; } else if (( Address < ADDR_FLASH_SECTOR_9 ) && ( Address >= ADDR_FLASH_SECTOR_8 )) { sector = FLASH_Sector_8 ; } else if (( Address < ADDR_FLASH_SECTOR_10 ) && ( Address >= ADDR_FLASH_SECTOR_9 )) { sector = FLASH_Sector_9 ; } else if (( Address < ADDR_FLASH_SECTOR_11 ) && ( Address >= ADDR_FLASH_SECTOR_10 )) { sector = FLASH_Sector_10 ; } else /*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_11))*/ { sector = FLASH_Sector_11 ; } return sector ; } 根据实际情况适当增删 FLASH_Sector ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else { sector = FLASH_Sector_7 ; } return sector ; } 四、修改Main函数 在移植过程中根据您的需要，修改Main函数，下面放上原Main函数和我个人根据 32F411EDISCOVERY 修改后的Main函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is pressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } /* Keep the user application running */ else { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } while ( 1 ) {} } 根据 32F411EDISCOVERY 修改后的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is unpressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } /* Keep the user application running */ else { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } while ( 1 ) { ; } } 五、修改IAP_Init函数 根据您的实际情况修改 IAP_Init 函数中的参数。 原函数代码如下： /** * @brief Initialize the IAP: Configure USART. * @param None * @retval None */ void IAP_Init ( void ) { USART_InitTypeDef USART_InitStructure ; /* USART resources configuration (Clock, GPIO pins and USART registers) ----*/ /* USART configured as follow: - BaudRate = 115200 baud - Word Length = 8 Bits - One Stop Bit - No parity - Hardware flow control disabled (RTS and CTS signals) - Receive and transmit enabled */ USART_InitStructure . USART_BaudRate = 115200 ; // 串口波特率 USART_InitStructure . USART_WordLength = USART_WordLength_8b ; USART_InitStructure . USART_StopBits = USART_StopBits_1 ; USART_InitStructure . USART_Parity = USART_Parity_No ; USART_InitStructure . USART_HardwareFlowControl = USART_HardwareFlowControl_None ; USART_InitStructure . USART_Mode = USART_Mode_Rx | USART_Mode_Tx ; STM_EVAL_COMInit ( COM1 , & USART_InitStructure ) ; } 六、结语 关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。 后续，如果我在工作之余或者工作中有需要，我可能会将IAP的代码移植到HAL库上，如果您已经做了相关工作，希望您可以在不涉及保密条款和其他利益的情况下，抄送一份给我，用于后续研究与参考。谢谢！","tags":"STM32F411VET6","loc":"http://dhlx.wang/Simple_transplant_IAP_STSW-STM32067_to_STM32F411VET6.html","title":"简单移植IAP（STSW-STM32067）到STM32F411VET6"},{"text":"上周的周末，新买的SSD硬盘到了，需要把旧系统盘的数据迁移至新的SSD上，最开始考虑了Winodws系统映像的方法进行迁移，但通过恢复U盘进入到恢复步骤时，总是提示我无法格式化硬盘，所以放弃了这个方案。 在查询无数资料后，考虑到Win 8.1 Update的组成，突然灵光一现，尝试用Win 8.1的系统盘格式化新的SSD，从而使新的磁盘系统分区和原来的保持一致，通过备份分区数据，还原分区数据的方式，完成系统迁移。 本文就是就是记录下这个操作流程，以备后人参考，如果您有更好的方法，请您不吝赐教，谢谢！ 废话也说完了，我们下面进入到正题。 一、准备工具 天意u盘维护系统技术员版3.0 UltraISO cn_windows_8.1_with_update_x64_dvd_6051473.iso cn_windows_8.1_with_update_x86_dvd_6051523.iso Windows 8 USB Installer Maker DiskGenius v4.7.1 免费版 16G U盘 可量产 如果遇到上述链接无法访问，请您自行想办法。 友情提示：中国拥有世界八大奇迹——长城。 二、制作Winodws 8.1 Upadate U盘安装盘 这个大家应该已经很熟悉了吧！用我提供的Windows 8 USB Installer Maker工具，基本制作过程是傻瓜式安装。 三、安装Winodws 8.1 Upadate到新系统盘 这步我也就简单说下，基本上都会做，说一下几个需要注意的地方。 1、重启进入Bios把安全启动关闭，以免后续从PE、U盘安装盘启动不了。 2、一定保证新盘的分区方式和旧盘一样，我一般采用的系统盘自动分区。 3、进入不进入系统都可以，等会儿都要覆盖的。 四、安装天意U盘PE 这步在天意大大贴子中已经写的很清楚了，我就不重复给出制作U盘PE的教程了。这里仅给出一个UltraISO可用的用户名和注册码。 用户名：王涛 注册码：7C81-1689-4046-626F 五、备份旧系统盘数据 1、如下图所示，进入到天意PE中，打开DiskGenius。 2、选中原系统分区，单机鼠标右键，可以看到备份分区到镜像文件，点击它。 在这里您需要注意查看下旧系统分区的数据量是否远小于新系统盘的分区大小。 3、选择文件路径，并点击开始，就可以开始备份了。 六、还原旧系统盘数据到新系统盘 1、选中新系统分区，单机鼠标右键，可以看到从镜像文件还原分区，点击它。 2、选择刚刚备份的文件，并点击开始，进行系统迁移。 七、重新设置引导参数 1、在天意PE中默认没有给引导分区指派盘符，所以我们需要找到系统的引导分区，单机鼠标右键，可以指派新的驱动器号，点击它。 2、选择您想要赋予的盘符，选择它，记住它，并单击确定。 3、打开开始菜单，找到BIOS+UEFI引导修复工具，打开它。 4、按照提示填写Windows系统分区盘符，引导分区盘符，并按下回车，确认信息后，再次按下回车。 5、出现上图最后一行的提示，您可以关闭程序，并重启电脑。 八、结语 以上就是我此次系统迁移的基本过程，如果您有没看懂的地方，您可以留言，我看到后会及时回复。 P.S. 天意大大说我提供这个版本PE中DiskGenius有一些问题，但是在操作过程中我没有遇到，如果您遇到了，可以用DiskGenius的原版（在第一章节中有提供下载地址）尝试下。","tags":"Windows","loc":"http://dhlx.wang/Win8-1-Update-System-Migration.html","title":"Windows 8.1 Update 系统迁移"}]}