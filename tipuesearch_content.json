{"pages":[{"title":"FM1702Q （ MFRC500 ）天綫調試","text":"一、參考文檔 FM1702Q 通用讀卡機芯片產品說明書 設計 MFRC500 的匹配電路和天線的應用指南 13.56 MHz RFID讀寫器天線的設計與仿真 二、硬件設計 因為FM1702Q的硬件設計不太複雜，所以我這主要以文字進行描述。 TVDD 、RVDD採用5V 2596電源，近芯片端均加入0.1uF的濾波電容，並在5V的輸入口放置10uF 6.3V的大電容，以提供低紋波的直流電源。 DVDD採用3V3 LDO供電，用於節省和STM32F1系列片子配合的74邏輯電平轉換電路。 SPI均採用外置強上拉。 天線設計時，參考MFRC500的應用指南，有天線線圈、屏蔽、內外補償、固定去調（鐵氧體）四個部分組成。 發送和接收、匹配的設計如下圖所示： 天綫設計中，根據《设计MF RC500 的匹配电路和天线的应用指南》中的第五章介紹和《13.56 MHz RFID讀寫器天線的設計與仿真》論文，雙層板也應在天綫背面增加覆銅（模擬鉄屏蔽），給天綫固定一個去調。在天綫正面應根據設計，適當增加内外補償綫圈。 天線部分電路設計應該遵循以下原則： Cs 、Cp都分成2只並聯的電容，便於將來調整參數。 C1、Cs 、Cp要選用精度為±2％或者更高等級，COG材質（溫度係數小）的電容。這樣才能保證批量生產時產品的性能一致性。 電感應該用0805以上的封裝，且電感額定電流要在150毫安以上。在無極其成本敏感地方，應盡量采用TDK的鐵氧體屏蔽電感（1uH 400mA）。 PCB線圈的設計的一般原則是設計為與所讀的卡片大小一致最好。 PCB線圈的圈數問題，長寬在3x3cm以上4圈即可，如果是在3x3cm以下將圈數增加至6圈或者更多。 PCB線圈的綫寬建議選用20mil-40mil之間，綫與綫之間的間距等於綫寬，線圈拐角以圓弧過渡最好。 在應用於有金屬平面的情況下，建議采用4層板屏蔽的畫法，如果是兩層板也一定要在背面加屏蔽和鐵氧體層。 整個發射電路所有器件的地必須連接到同一根地線上並且返回芯片的TVSS腳，且天線電路器件附近不可大面積覆銅，器件之間以導線連接。 三、天綫調試 主要有以下步驟： 调试EMC电路 调试天线谐振点（如果能調） 调试Match电路 调试接收电路，保证RX端的Vpp在0. 5RVDD ~ RVDD之间 上訴示意圖中天綫的各個器件的作用説明： Cp的作用是改變天線的諧振頻率，更改這個值會改變天線的出口電壓和空中感應電壓（可用示波器組環狀探頭測試），此值可以通過理論計算得到初值，然後上下調整容值，看下變化趨勢，將天綫的出口電壓調到最大即可。 Cs的作用是做天線阻抗匹配，理論經驗值為10pF - 30pF，調節此處容值，主要表現在發送調制信號時，過冲和振鈴的大小，按照ISO14443A中的規定，過冲應控制在天綫的幅度的90%-110%，振鈴幅度應小於天綫的幅度的5%。 C1、C3、C4和L1基本上按照芯片手冊推薦選值即可。 調整RX電路的接收賦值時，應當根據DVDD的供電電壓進行選擇，如果DVDD為3V，空載下，RX的值應在1.5Vpp到3Vpp之間，幅值越大越好；DVDD為5V，空在下，RX的值應在2.5Vpp到5Vpp之間，幅值越大越好。 R2/R1的值越大，RX的接收電壓也越大，黨RX值不在推薦值，應當適當調整。 EMC C1 x L1的截止頻率應在13.56mHz，故在L1為1uH的情況下，C1的選值應爲136pF（68pF x 2），但爲了簡化設計，可考慮單電容120pF，大概截止頻率在14.5mHz。 以下的調試過程中保證天綫背面無鉄平面： 由於我個人的調試設備過於簡單，只有示波器可用（阻抗為1M），所以我簡單對我的調試過程做下記錄： EMC的電路選擇為1uH和136pF。 確認Cs為20pF。 按照芯片手冊的Cp計算值，在此值上下尋找合適容值，使天綫兩端電壓達到最大的Vpp，且不失真。 調整R2/R1的值，使RX在正常的Vpp範圍内。 看下過冲和振鈴，如果有問題，改變Cs的值重新調整，調Cp時也會改變，但此處一般不用調。 正常的波形如下所示（電感前端、天綫兩端、RX管脚）： 確認讀卡器是否可以正常工作，就是看下對應的調製波形，是否發出命令，卡片有返回，下圖為尋卡指令的示意圖： 以下為調試過程中走過的彎路，電源供電不足時，電感前後端的波形和RX上的波形： 下面這個就是過冲和振鈴，如果過大，請調節Cs：","tags":"FM1702Q","url":"/Electron_Technology/FM1702Q_Antenna_Debug.html"},{"title":"烟花三月下徽州 春色如烟人如畫","text":"對於婺源的瞭解，源於我大學畢業旅行的選擇目的地，當時看到婺源的景色，就決定一定要和朋友去一次，可惜等到她要結婚了，我們一直也沒有時間可以去了，蠻可惜的。所以我寫游記是爲了記錄當時的游玩的狀況，爲了將來如果有機會再去的時候留一個參考，如果沒有機會了就當做回憶了！ 此次行程中有許多的第一次（每一次旅途中都會許多的第一次），比如説： 第一次參加驢友團的長途活動（火車） 第一次乘坐火車過長江大橋 第一次去江西省 第一次近距離觀看熱氣球 第一次看見徽派建築和山水形成一種自然的風水畫 …… 接下來我們來説我們的旅途吧，三宿兩天的旅途 2017年3月17日 夜宿在Z67北京西-九江的火車上 2017年3月18日 游玩曉起，江嶺，江灣，夜宿在李坑民宿中 2017年3月19日 游玩月亮灣，思溪延村，夜宿在Z72九江-北京的火車上 以上是我的實際旅程，實際上領隊計劃是第一游玩東綫——曉起，江嶺，江灣，月亮灣，李坑；第二天游玩北綫——思溪延村，彩虹橋，臥龍谷，嚴田古樟，按照計劃來講，我們實際完成60%左右，主要原因是天氣和時間上，游玩的兩天一直連續的陰雨天，時大時小，不好掌握，很符合烟花三月下江南的詩句，所以打算這個時節來江南游玩的話，一定要考慮下天氣的因素，另外一個原因就是領隊的時間把握不是很好，感覺路上都很急促，可能是由於領隊沒有來過婺源吧，衹是參考其他人攻略來説做的計劃吧！ 好了，下面進入照片欣賞環節。 三月的婺源真的很美，春天盛開的油菜花，水墨丹青的建築，飄渺的雲烟構成了一副巨大的畫卷，照片衹能表達我看待景色的角度，如果不符合你的審美方式，還請您見諒。我的觀點是婺源的美體現在古老的人文、顔色畫面的渾然天成和同行的人。但此次婺源之旅也讓我真的瞭解了下面這句話： 你知道他們不是壞人。他們只是沒有受過教育，不諳世故，沒出過遠門，不道德，不文明，外加愚蠢 - 蒂姆·高特羅 沒有一次我比這次更傷心，如此優美的景色和白色垃圾混合在一起，本來是清澈的河水汎著油光，本來應該安寧祥和的村落，由於游客的到來，變爲了一個季節性的商業小鎮，看到這些我衹能說我以我的所做所爲來做我力所能及的改變。 好了，我們不談這些傷心的事情了，讓我來聊一些愉快的事情。首先我們來先吐槽一下北京西站的40元一套的牛肉麵套餐。 曉起村 早晨7：00我們從九江站乘坐租租賃的大巴車出發，前往我們今天的第一站——曉起村，我們需要在這裏做短暫休息，領取購買的門票，之後再前往今天的主要目的地——江嶺。在這裏我多說兩句，婺源的景點很分散，游客很集中，這樣帶來的麻煩就是交通不便，到哪裏都是人，所以非必要，强烈建議不要選擇周末來徽州游玩。 我在等待領隊拿票過程中隨手拍的路邊的油菜花，婺源真的可以説是十步一景。 據説下面這棵樹是曉起村最著名的景點——神樟。 這個可以說是曉起村的一角，全貌談不上，畢竟身在此山中，不知云深處，但曉起村給我的第一印象真的很不好，商業化嚴重，每一步都是一個店鋪，這也是婺源古村的一個悲劇吧！ 要出曉起村，隨手拍了一張脚下的路和路邊的樟樹。 出曉起村，正好快中午了，早飯也沒有喫好，就在路邊隨意喫點當地的特色，可能是店鋪的原因吧，真心覺得不好喫！ 喫完清明果和餛飩，看著時間尚早，我就隨意在路邊走走看看，看到鳥兒很漂亮，就偷拍了兩張，在北方，這個時節除了麻雀和喜鵲，我真的不知道還有什麽鳥了！ 江嶺：青山梯田花海 中午在江嶺的農家院，大家AA喫了一些飯菜，做的還不錯，家裏的味道。 下面這個酒，老伯說是自家釀的米酒泡的紅杉子，但是酒中帶著少許辣味，不知道是不是蒸餾過，但味道嘗起來有一股水果的清香甜味，喝完不上頭。 和一幫子喫貨喫飯的後果就是，十道菜，我衹拍到兩道菜（紅燒紅鯉魚和梅菜扣肉），因爲我再拍照的話，中午我就要餓肚子了！ 另外我在提一下，到你不熟悉的地方喫飯，點相同的菜名的菜，一定要問做法，一定要問做法，一定要問做法，重要的事情說三遍。 江嶺的景色可以説是婺源油菜花景色最好的地方之一，從江嶺向下看，層層梯田、曲折盤旋的山路、蜿蜒流淌的小溪，山谷中三、四個村莊，構成了一幅極美的婺源農村風光畫卷。 婺源的花不止有黃色的，還有粉色的，下面這個應該是桃花吧，我也不是很確定。 江灣 江灣，聽説是江澤民的老家，江澤民執政后，曾大修一番，但依稀殘留著文化大革命那場動亂留下的一些痕跡，但也很少了，大部分都已經整修過，樣子很古典，但已經不是千年古村的面目了。 這個地方可説是江灣重要的一景，畢竟一位領導人在此坐過，看望老師。 2001年5月30日上午,在江西考察工作的江澤民總書記來江灣,看望任教40年的退休老教師江啟昌,總書記與江老師親切交談,使江老師興奮不已,終生難忘。 \"江啟昌宅\"因此而得名。 這位年近九旬的退休老教師江啟昌，身體依然硬朗，精神矍爍，見到客人就熱情地訴說著那令他難忘的一幕。他的桌前擺放著不少折扇，有的墨跡尚未乾，可以看出都是由江老師自己寫的，遇到知己就訴説一下自己的設計理念：因江澤民屬虎，又是真命天子，故將\"龍\"和\"虎\"二字位居中央。從右往左、從上往下來看，第一行寫著\"蕭江\"，用來説明江澤民和江灣江傢的來歷——蕭何的後代；接下來是\"龍騰新世紀\"，是在誇獎江澤民——新世紀第一位國家領導人；再往右看：\"虎躍步民昌\"，這句也不用説了，也是在誇獎江總書記帶領人民走向繁榮昌盛，最後寫明時間（丁酉鷄年）和地點（江灣村）。最後，估計也是老先生最爲得意的一處吧，從最下面的一行從右往左看，正好是一句藏頭——\"江啟昌書\"，點明了作者。聽完老先生這番介紹感覺還是漫游意思的。 説實話我覺得江灣外這一遠眺的景色，要比江灣好看很多，可能是我對人文歷史不感興趣吧！ 李坑：小橋流水人家 當我們到達李坑的時候，已經是晚上了，所以我們就先解決住宿和喫飯的問題了，晚上和司機大哥小酌了幾杯當地的特色白酒——四特酒。至於飯菜沒有拍的原因，我想你們應該是知道的——我真的太餓了，喫晚了，估計就什麽都沒有了。 李坑的夜景是不錯的，但是在李坑看到的悲傷。在這還發生點小插曲，喫完飯半個小時，全村就停電了，一直停到第二天凌晨，所以夜景照片很少。 早晨起來，走進村落，明清古建遍布，粉牆黛瓦，參差錯落;村內街巷溪水貫通，九曲十彎，青石板道縱橫交錯，構築一幅小橋，流水，人家的美麗畫卷。 李坑的建築風格大都是明清民居風格，是一組集贛中民居之精華，融木雕，石雕，磚雕，彩繪為一體的經典建築群，一腳踏進去，說不准就是某個朝代某人官家人，商賈豪富的深宅大院。不論是官家府邸還是普通民居，一只有從房子大小，磚雕門樓，木雕窗欄以及各種彩繪的精緻程度上，才能辨出當年主人的身份與家境。歲月的灰塵與時間的粘連，使這些明清百年老屋斑駁成一種古老深邃的寧靜與寂寞 估計這種行爲——侵鼠籠，一個孩子把這種滅絕生物的行爲當作是一場游戲，衹能說勝者爲王，敗者為寇！ 在李坑感覺最有意思的還是這麽一群鴨子，有著王的蔑視首領，有著正在溪水中洗澡的愜意。 月亮灣：一灣春水碧綠 月亮灣是去往李坑半路上的一個小景點，因江河中有一個長長彎彎的小島，如一彎眉月而得名。從遠處眺望這小島，但見一灣春水碧綠，金黃的油菜花遍野盛開，江南小竹排於河邊搖晃，兩岸倒影在水中輕漾，美得內斂，沉靜，如江南小家女子，安隅於婺源。 因領隊給的時間，比較多，所以決定和同行的美女，打算下水坐坐竹筏，享受一下划竹筏的樂趣，並體會下被人當作畫中人的感受。 估計要沒有他，我的體重可能會把整個竹筏給弄沉了吧，現在想來也是自黑一下了！ 有趣害羞的船夫大哥，希望有機會和你再相見！ 思溪延村 可能是我更喜歡風景一些吧，也可能是突如其來的一張大雨把我游玩的好心情破壞了吧，也有可能是昨天看的太多了，衹是隨手拍了一些紀念景色，大家一起看看吧！ 來到婺源，我建議大家可以去品嘗下正宗的江南果酒，比如這十五年的狀元紅口感醇厚、酸中帶甜，不管男女應該都很喜歡喝。 世上無不散的宴席，過往兩天的人與事，宛如夢中。 回歸正常生活的第一頓早餐，KFC活力早餐，沒辦法，馬上要去新國展，參加展會，路上沒有喫的，衹好凑合一口了！ 最後，給大家簡單報下花銷，給以後的想去的人做個參考吧！全程共花費車票、車費、住宿（1000元）門票（180元）喫飯、酒錢（飯錢全程AA，酒錢單算，可以控制300以内）。","tags":"游记","url":"/Travels/2017_HuiZhou.html"},{"title":"端午去青岛看海","text":"清明后，与同学约好，端午一起去青岛看海。于是我们在端午节前夕（6月8号）从三座城市到达同一目的地——青岛。 青岛在我的印象中一直是阳光明媚，非常适合人居住和生活的城市，但这回去青岛，彻底改变了我对这座海滨小城的印象，下面听我慢慢的讲述。 准确说，我是6月7日晚上乘坐Z7到达前往青岛，一路上在睡梦中还梦见了青岛的排骨米饭和一个记忆中的姑娘，或许真的是因为有着青春的回忆，让我喜欢上了这座海滨小城。 6月8日 有着一个良好开端，但确实很糟糕的一天 我从来不怎么睡懒觉，但早上叫醒我的不是闹钟就是我的梦想，而这天我确却被一个潍坊的女生叫醒的，说话的声音很甜，大方得体又文雅的一个姑娘，我很喜欢看她笑，虽然被她和家里打电话吵醒了，但我并没有什么抱怨，听她说话，感觉很舒服，回到北京以后，我很后悔当时为什么不要个电话呢！ 早上6：40到达青岛北站， 叫了一辆UBER从青岛北站到北九水，但我和司机成功的被百度地图坑了，在走了10公里左右的正常的城市道路，突然百度地图要我们拐到走到山村小路上，由于我和司机谁都没有去过北九水，所以只好按照百度地图的导航走了，又走了10多公里的村路和山路，终于到达了一个已经荒废的检票站，司机说按照导航已经给我送到地方了，说什么也不肯再向山里走了。司机人还是蛮不错的，就是被百度坑了。说句玩笑话，自己找的，闭着眼睛也要走完，按照百度地图的指示，我又大概走了4公里才到达九水十八潭的上站停车场。 从停车场大概又走了2公里的山路栈道，我才到达北九水的检票口，但此时我的心又凉了半截，游客中心正在重建，路上几乎没有什么游客，在进入检票口问一个卖水的老大娘才知道，我觉得青岛靠海不应该会大旱，但事实是最近几年北九水始终干旱，除了九水还有一些，其余的八水十八潭基本上都干了。 又走了700多米，终于见到了，九水十八潭的面目。 《庄子·外物》：\"筌者所以在鱼，得鱼而忘筌。蹄者所以在兔，得兔而忘蹄。言者所以在意，得意而忘言。吾安得夫忘言之人而与之言哉！\" 可惜得鱼谭仅仅只剩1丈见方，得意谭已经根本没有水了。 历经千难万险，终于到达了目的地——九水。水流很小，但水很清，泉水泡的茶，很好喝，同样泉水泡的海凉粉，足够凉，也足够好吃。 在九水品品茶，唠唠嗑，1个小时过去了，也就下山了，下到山下的停车场，也就用了90分钟左右，也在此之后，终于见到了北九水售票处的真面目。 之后就是艰难的去宾馆的路程，等了1个小时，才有去往市内的公交车过来，又坐了快2个半小时的车才终于到达今晚住宿的宾馆（在火车站附近）。进到宾馆睡了一会儿，我就起来去吃晚饭，今天一天都没怎么吃东西，晚上一定要吃顿好的，弥补一下，所以我去了大家都很推荐的九龙餐厅（老店），离我住的宾馆很近，走路过去只要5分钟左右。 以上就是我的晚餐，外加一瓶牛栏山二锅头去去潮气和寒气，一碗大米饭用来填饱肚子。 吃过晚饭，就回宾馆准备一下，去火车站接我的朋友了。 6月9日 海雾弥漫，美食，美酒之旅 早上起来，在我住的宾馆旁边吃的青岛的特有早餐，甜沫（请自行百度）和虾酱。 吃过早饭，我们一行三人准备去青岛有名的基督教堂看看，但是路上我们被青岛的海雾吓到了，距离不到50米之外的大楼，一小半已经不见了踪影。 但从路口回头看了下基督教堂还在，心有余悸的走向我们的第一个目的地。 与我同行的美女和帅哥都在秀恩爱，我也没有办法，单身狗的悲剧。 走进基督教堂始终给我一种沉重的心情，不知道为什么感觉很不舒服，当天还有老牧师在用管风琴演奏，把这种情感推到了极致。 教堂内部不能照相，虽然有很多人违反规定，毫无顾忌的去照相，但对于我这种相信头上三尺有神明的乖宝宝，我还是老实的遵守规定吧，只能给大家看下极度教堂的中世纪古堡风格的外景了。 从江苏路基督教堂出来，我们就直奔栈桥而去，心里虽然有了一些心理准备，今天的海雾会很大，但到了栈桥，我们觉得低估了青岛的海雾。雾中的栈桥，简直就是犹抱琵琶半遮面呀！ 远处的摩托艇、快艇和小型渔船，勉强还能看清，但我真的不知道，这么大的雾，他们出海去干嘛！ 秀恩爱的二人组，又来了，这次是在栈桥上。 由于海边起雾了，原本计划着今天海边一日游，眼看着泡汤了，我也没有办法，但出来毕竟还是要玩的，所以我们就改变了计划，去了青岛啤酒博物馆。里面当然是美酒美食咯，只可意会不可言传，大家如果感兴趣，可以自己去看看，但是一定要尝尝啤酒豆，就是下面这个东东。 中午在博物馆附近的台东八路的万聚和饭店（万和春老店）吃的排骨米饭，和两年前一样的味道，如果你要去附近逛，一定要去尝尝。 中午吃够午饭，由于青岛一直都是雾蒙蒙的，而且天气比预想中的要冷不少，妹子没怎么带衣服，所以我们先陪妹子在台东八路买的衣服，用于避寒。下午4:00多，看着雾气有些散了，我们才去的八大关溜达一圈，可惜有得必有失，我们看了帆船、美女、阳光沙滩，但是花石楼和公主楼已经不让进人了，我去过，倒还好，他们两略感遗憾。 在第二海水浴场碰到的一个不知名的文艺萌妹子，拿着微单左拍拍右拍拍，当然如果你知道她的手机号，希望你可以告诉我，我是实在没还意思问。 从八大关出来我们就直奔闽江路上的三宝粥店，去尝尝青岛的海鲜，可惜当天已经饿的不行不行的，就忘记留下美食的照片。 晚上从三宝粥店感到火车站附近去坐隧道1路，前往新黄岛，我们的今天晚上要休息的旅店。 6月10日 搞砸了日出，搞砸了出海，搞砸了下午茶，但美食还是会有的 早上3:50就起来了，我们打算去看日出，由于天气不好，他们不是很想去了，于是我独自一人还是抱着希望前往金沙滩去看日出。有的时候真的是希望越大，失望也越大。 看着天空由黎明前的黑暗到东方既白，没有了日出，只有早起和我一样的人民，早起出海的渔船，还有细如面粉的沙子。 看着时间流转，到了6点，我饿了，在我寻找早餐的艰辛道路上，居然看到这么一小片的世外桃源，也是很值得的说下的。 历经我的一个小时的步行，我终于找到了一个早餐店，吃上了我的早餐。不得不说，金沙滩的附近公寓和小区不少，但是都没啥人气（生灵之气）。 我吃完早餐，便又回到了我住的地方，等待我的朋友睡醒，悄悄地说句，他们两真的很能睡，一直睡到9点多才醒。我和他们在酒店收拾完，再次前去金沙滩，一起再金沙滩上漫步，悲剧的事情又来了，今天海上起风了，还起了大风浪，不让下海游泳。我们不知道做什么的时候，看到旁边有快艇，皮划艇等小船，我们觉得我们可以靠自己划皮划艇可以冲破风浪出海看看，但现实是残酷的，我们被大自然完虐。 玩完皮划艇，由于身上都是海盐，我们就直接回宾馆了，简单洗漱，我们就又朝着青岛市内进发了。 p.s. 我们去的时候，金沙滩边上的淡水浴室还没有开，听说，每年7月份才能开放使用。 今天可能是我们太不注意了，也可能是我们的运气不太好，同行的女生到了市内的宾馆就病倒了，身体有些冷，想要休息，那只好让她睡了，我和我朋友去八大峡附近的船歌鱼水饺，简单的吃了一口中午饭。强烈建议你们去尝尝墨鱼馅饺子、鲅鱼馅饺子和比管豆腐汤。 下午他们有些难受，只好在宾馆休息了，我也有些累了，主要是早上起的太早了，所以我也在宾馆睡了3个小时。 晚上睡醒，第一件事情就是找地吃饭，因为想要去奥帆中心，所以特意在奥帆中心附近搜索了下，比较好吃的饭馆，正好看到兰公馆做活动，而且评价还不错，最主要的是我特别喜欢这种复古的装修，可能是我看现代的装修风格看的很腻歪吧！ 在大众点评（这个是一个妹子告诉我的秘诀，不知道吃啥就上大众点评上看看，只要城市不是太小，这招基本上通用）上团购了5道菜，才60元，真的很便宜，卖相也不错，最主要的味道也很好，哈哈哈，我就一个吃货。 菜没上来之前，我以为价格这么便宜，可能菜品很精致，菜量会很少，但是我失误了，最主要的是，我最后还是全吃掉了。大家快来看吃货。 出了大厅，我看见了我进来时没有注意到的鹦鹉，人就是这样，在不同的时候，注意力总是不一样的，进来的时候我都没有注意到这么个可爱的动物。 从兰公馆出来就直奔奥帆中心，我自己没啥感觉，就是感觉青岛的海雾无处不在，上些图，大家自己看吧。 这里乱入一张，让你们看看青岛的雾有多大。 6月10日 海底半日游，有什么好吃的吗？ 如果你的住宿地点选在八大峡附近，一定要去西陵峡三路的味为先(可能其他地方也有)豆腐脑喝上一碗豆腐脑，来上两个酥饼，这才叫生活。 昨晚就定好了今天要去青岛海昌极地海洋世界，我对于这个地方一定兴趣都提不起来，但是同行的妹子想去，我也没有办法了，只好陪着去了（主要全是雾，我自己一个人根本不知道去哪，千万不要告诉我朋友哈）。 南极考察，北极熊的标本，但我始终觉得是假的。 维京海盗人偶，对于动漫提不起兴趣。 美人鱼表演，之前在大连看，好像美人鱼是有尾巴的，哎呀呀，虽然没有尾巴，但美女还是很好看的哟，原来我色色的看着人家。 接下来就是各种海洋馆都会有的热带鱼展示，其实我很喜欢这些热带鱼的，最起码很漂亮，我们对于美的事物都会有追求的。 最后就是每个海洋馆（至少我去过的）海豚表演。 我的四天青岛之旅就在这里画上的一个句号，我们三个人各回各家咯（北京、大同、济南）。这次让我对\"人生哪能多如意，万事只求半称心\"理解更深了一层。期待着下次的出行，我就是一个旅者，一辈子注定都在行走，直到遇见她，在她的城市停留下来。 定性，知事，选梦，遇人，择城，终老","tags":"游记","url":"/Travels/2016_QingDao.html"},{"title":"BQ24610 详细调试过程和心得","text":"年前接手了一项我从来没有搞过的项目——DCDC电源Demo板的制作，本文中将会详细记录从无到有的调试过程，以及一些心得。 文中会有部分的材料来源于网络和各个公司的应用手册，我只挑了一些我用的到片段进行汇总，大部分会给出出处，少部分无法查证，可能就不给出来，如果侵犯了您的版权，请您发邮件和我说明。 一、开关电源简述 开关电源（Switching Mode Power Supply，常常简化为SMPS），是一种高频电能转换装置。其功能是将电压透过不同形式的架构转换为用户端所需求的电压或电流。 开关电源的拓扑指开关电源电路的构成形式。一般是根据输出地线与输入地线有无电气隔离，分为隔离及非隔离变换器。非隔离即输入端与输出端相通，没有隔离措施，常见的DC/DC变换器大多是这种类型。所谓隔离是指输入端与输出端在电路上不是直接联通的，使用隔离变压器通过电磁变换方式进行能量传递，输入端和输出端之间是完全电气隔离的。 对于开关变换器来说，只有三种基本拓扑形式，即： Buck（降压） Boost（升压） Buck-Boost（升降压） 三种基本拓扑形式，是电感的连接方式决定。若电感放置于输出端，则为Buck拓扑；电感放置于输入端，则是Boost拓扑。当电感连接到地时，就是Buck-Boost拓扑。 二、BQ24610典型应用 BQ24610的典型应用如下图所示： 一个典型Buck拓扑的同步开关电源，Q4和Q5分别构成高低边开关，电流和电压经过L1和C12、C13趋于平滑，给外部电池组充电。由于BQ24610带电源路径管理，所以它有两个检流电阻，一个是RAC，检查ADAPTER的输入电流；一个是RSR，检查BUCK拓扑给电池包的充电电流，当系统侧电流和电池包的充电电流达到ADAPTER的最大输入电流时，会优先供给系统，减少电池包的充电功率，以保证后续系统在充电时可以正常工作。其次比较重要的就是一些参数的设置，由于BQ24610是一个低成本的大功率充电的解决方案，所以参数设置采用模拟设置方式，也就是根据输入电压设置，所以这里的一些关键电阻需要采用高精度电阻（1%，0.5%），如R1、R2、R3、R4、R5、R6、R7、R8、R9、R10等，这里特别建议R1和R2采用0.5%的精度，这样可以保证电池不过充，同时电池电压刚刚好。其次就是RSR和RAC一定要选用大品牌大厂家（国巨，Vishay）的检流电阻，否则的话有可能会造成不必要的麻烦。其余部分电路应该很好理解了，D1，C5，C6利用电容两端电压不能突变，构成了一个小型电荷泵，用来驱动NMOS工作；D2，D3，D4用来指示芯片的工作状态；R20、C16构成一个简易的滤波器，滤除ADAPTER的交流分量，也减少充电系统对前级系统的影响；Q1和Q2构成了ADAPTER的控制开关，Q3是电池包供电的开关；C8，C9用来进行储能，减少后续系统对前级系统的干扰。特意说明下，有些电容也存在一定可能性会对系统产生不必要的干扰，建议选用大厂（三星）X7R的5%精度的电容，如CCTC的定时电容。 三、调试过程中遇到的问题 由于在接手这个设计任务之前，对于开关电源的了解，仅限于会使用LM2576、 LM2577 、LM2596等常用电路，了解开关电源的常用的三种模型。所以可以说我是电源界的小白吧！经历了这个任务遇到了许多问题，伴随着问题不断的解决，我也逐渐的更加深入的了解了开关电源的特性。下面我就说说我碰到的问题： STAT1和STAT2状态指示灯均熄灭，PG指示灯正常 芯片检测不到电池 电池包充电电压不对 低边MOS（Q5）、升压二极管（D1）、芯片（U1）烧毁 BQ24610充电系统对ADAPTER的干扰大 定频的BQ24610的L1前端开关频率和波形不对 定时保护被误触发（ TTC ） 制作高端检流电阻（ RSR ）两端的共模放大器，放大数据不对 在电池包前级加入低端检流电阻，烧毁电压检测电阻（VFB的分压电阻R1、R2） 电感L1啸叫 电感L1前端波形存在振铃 电感L1前端存在尖峰脉冲 高低边的驱动波形存在问题 低边MOS（Q5）的DS两端加入RC减震器，导致RC过热 高边MOS（Q6）的GDS全部短路、芯片烧毁 电池包产生过流过压保护异常 系统侧带载充电曲线异常 系统侧不带载充电电流不够设定值 人际关系（ FAE ，Manager）处理问题 四、一步一步解决碰到的坑 这个部分中我可能会抱怨一些事情，也会陈述一些事实，更会详实的记录我的调试过程，如果您看我的文章只是为了寻找BQ24610的应用解决办法，我建议您不要看这节了，直接跳过去看第五节，正如TI原厂FAE所说，我们的芯片没有问题，有问题的是客户，客户的硬件技能不过关， PCB Layout做的不好，才可能出现各种各样的问题。 电路板的Layout即是一门工程学术问题，也是一个哲学问题，艺术的表达。 首先我想说的人际关系的处理问题，在此次的问题解决过程中，主要涉及四个人:供应商FAE、TI原厂FAE、小组组长、项目经理。 以下的描述基于个人感受，或许有积极的一面，或许也有消极的一面。 供应商FAE：之前和我接触的一直是另外一家的FAE，但新来的项目经理换了供货商，无奈供应商的FAE也换掉了，新换的FAE对这款芯片不了解，所以过去一个月基本上是我们同时从无到有的去了解这款芯片，一起讨论这款芯片的各种性能和波形，可以说是我们相处比较愉快，尽心尽责的好FAE，当然这中间也被他坑过，这个后面我会讲给大家听。 TI原厂FAE：对待我们这些小厂，十分霸气的说了一句话——我们的芯片没有问题，有问题的是客户，客户的Layout不过关。之后，就没有在提供任何有用的信息了，但最后解决问题的途径，确实是PCB Layout。 小组组长：这个可能是一个巨坑，希望你们不要和我一样遇到这种巨坑，求助问题说：你的工资又不给我一半，帮你是人情，不帮你，你也没啥可说的，这个确实让我无话可说，但是你给我的帮助都是顺嘴胡说，这个我忍不了，你不看芯片手册，上来就和我说这块你的电阻选大了，电流过小，导致什么什么的问题，不详细看原理图和手册，就和我说，这个下拉电阻是必须的，因为芯片会上电检测一个低电平，不看看我的Layout就和我说，你的layout太次了，这样吧，你按照EVM的原理图你给我画一个，我给你Layout一下吧，最后说我画的EVM电路又是各种不对，看起来差太多，要我画个一模一样的，你不画，你就接着自己研究吧，我不能说什么了，只能祝愿你们有一个好的小组组长。 项目经理：这个职位在我们公司的定义有些混乱，既要监督项目的进度，又要协调各种资源，采买器件，管理器件等，但是在研发阶段过渡的压缩硬件成本是不是有些不靠谱，这回有些坑就是由于器件问题造成的。这个问题确实可能大家都没有想到，无可厚非。 以上，我简单的抱怨了一下，设计验证过程中，碰到各种人际关系处理的坑，下面让我们进入到正题，后续可能很无聊，应该是一个平淡无奇的记叙文（ P.S. 我的语文不是很好）。 2016年2月24日 焊接完毕，开始调试，插入电池和温度电阻，STAT1和STAT2状态指示灯均熄灭，PG指示灯正常。 2016年2月25日 对照手册，开始测量芯片的VCC， VREF ， RRGN ， TTC ,TS和EN等关键节点电压均正常，但用示波器测量L前端的波形，发现波形频率不对，并伴有周期性的下降脉冲，在L后端测量仍出现下降脉冲，和兴业的FAE联系，共同解决问题，由于他已经下班，并且没有使用过这款芯片，未能及时给出解决办法。 2016年2月26日 FAE猜测在电荷泵附近的电容（C6）驱动能力不够，导致波形异常，将0.1uF的电容换成1uF，未果，未能解决波形问题，后来相互探讨，怀疑所选的MOS的带载能力不够，采用电阻做阻性负载，试验ACFET和BATFET的功能和芯片的电源链路管理是否正常，电源和电池可以正常带载，链路管理正常，但是电池带载时，电感会有异响。重新阅读芯片手册，发现芯片的内置程序上电会先检测是否存在电池PACK，但电池组的插上与拔下，电感的前端和后端波形无变化。 2016年2月28日 变更VFB的反馈电压，换用不同的电池组，发现用磷酸铁锂的PACK，芯片可以检测到，当出现了一个新的问题，芯片的STAT1指示灯会有规律闪烁。 2016年2月29日 焊接三块新的充电板子，并查询高边电流放大电路以及运放的选型的信息。 2016年3月1日 磷酸铁锂PACK做了放电后，充电，发现芯片给PACK充电时时断时续，监测STAT1，发现存在4S的周期，50%的占空比的方波。电感有吱吱的响声，FAE猜测电感量过小，可能产生饱和。串联电感测试，问题没有解决，波形不对，声音有所减小，充电仍是时断时续。 2016年3月3日 和FAE进行现场调试，看到板子后说电源的地平面不够完整，需要通过粗导线完善地平面的，但调试过程中四块板子均因为不明原因损坏，关键节点(REGN等)电压不正常。没有良好的结果。 2016年3月4日 查找板子损坏的原因，经测量三块板子中的低边MOS（Q5）、升压二极管（D1）、芯片（U1）烧毁，一块板子芯片没有焊接好，因为有两块板子刚刚上电就烧毁，所以翻译可能是电源稳压器刚刚上电产生过大的尖峰，或者夹子之间不稳，产生一种尖峰电压烧毁板子，修复板子之后，加大电感量从6.8uH到15uH，发现可以正常充电，电感伴有啸叫，而且还出现充电定时器不定时被触发，停止充电，因为电容用的是X5R的20%电容，所以怀疑可能是电容的质量问题造成的。后经查看手册计划，将TTC接到高电平进行测试，看看可否正常充电。 2016年3月6日 将TTC电平接到Vref上，未出现充电中断的问题，初步判定是电容引起的，由于测试过程中总会烧低边MOS（Q5）、升压二极管（D1）、芯片（U1）和电池PACK不靠谱等原因，将6S参数换成2S进行测试，充电未中断，电感有啸叫。 2016年3月7日 新的电池Pack到了，三组国产5200mAH，一组进口6400mAH进行测试，仍存在充电板损坏的问题。项目经理重新采买X7R 5%的电容的，进行测试，发现中断时间好转，但仍存在充电过程中，充电定时器会被误触发的问题，同时发现L1前端的波形尖峰，振铃严重。 2016年3月8日 尝试加入RC减震器，L1前端波形没有好转，有可能是加入RC参数不对，下午的时候寻找TTC误触发的问题时候，发现模拟地上有很大的正弦波干扰，和FAE讨论，觉得这些问题最大可能性是由于地平面不够完整造成的。 2016年3月10-16日 找相关的资料，关于地平面，尖峰，振铃干扰方面，发现说地平面的间距问题可能会造成问题，敷铜的直角可能会造成一定问题，FAE说高频回路太长，驱动线太长，尝试减小高频回路的距离，减小驱动线的距离，增加驱动线上的阻抗等解决办法，由于TI给出的PDF上布线不清晰，没有给到我明确的参考，只参考了布局和布线。 2016年3月17-20日 打样（B版和C版），并做高端电流采样的电路等。 2016年3月21日 焊接调试（B版），L的前端波形好了很多，可见尖峰消失，但仍有振铃，芯片仍在某种情况下会损坏，REGN无输出，MOS管DS、二极管击穿。电感换用15uH，有振铃，波形不对，电感有噪音，但可以充电，TTC定时仍会不定时失效。FAE认为有噪声正常，但是我觉得噪声不正常。 2016年3月22日 没有找到良好的解决办法，将购买EVM重新提上日程进行购买。 2016年3月24日 尝试一些方式，没有找到良好的解决办法，芯片就剩最后一枚。 2016年3月25日 和兴业FAE调试一天，没有解决，和TI原厂FAE简单谈了下，给了我一个结论就是芯片应该没问题，就是PCB Layout的问题。 2016年3月27-31日 重新布板，参考官方的EVM板，注意地平面完整性，继续减少地平面与其他信号的间距到0.2mm，增加RC减震器的解决验证方案，将驱动线的过孔之间的间距加大，将VFB引脚的引线从就近，改为从输电容后级引出，注意地平面就近形成回路等解决办法。 2016年4月5-7日 焊接调试，波形没有问题了，但上管在某些情况下GDS会全部击穿，经查询资料，可能是由于MOS的G极阻抗过大引起的，去掉G极外加的电阻，解决此问题，加入RC减震后，1S2P充电正常，波形正常，但6S可以充电，但波形不正常，所以去掉RC解决此问题，波形正常，无尖峰，无振铃，基本可以证明电路现在稳定好用了。 2016年4月8日 测试并描绘实际电池的充电曲线发现电池曲线的恒流段有问题，最大电流只有2.8A，远超出应有的误差，带载测试，发现恒流段电流从充电开始不断减少，直到2.4A左右。恒压段还算稳定。但测试ISET1、 ISET2 、ACSET的电压与EVM、计算值无异。 2016年4月10日 测试并描绘EVM的充电曲线，发现带载充电曲线很正常，只有最后ADAPTER输出到4A以后，才会逐渐减少充电电流，但ADAPTER始终输出到4A左右电流，与FAE进行讨论，FAE认为已经满足我们的是要求，当我觉得是Demo，各方面应该尽量调节到足够好，我们之后讨论相关问题，总结出可能是由于布线仍不是很理想，器件可能有问题，尝试换用国巨的电流采样电阻，进行初步测试，还算理想，电流可以控制在2.95A以上，满足手册上的误差（3%-4%）。 2016年4月11日 进行电池比对曲线测试，放电测试等，并进行多次充放电试验，验证Demo板足够稳定。 2016年4月15日 焊接新的两块充电板（D版），并测试其参数，充电曲线。 2016年4月17日 补充项目调试中的记录，并完成项目总结。 五、 BQ24610 PCB Layout的注意事项 在这里我写的一些注意事项，可能都是电源新手Layout碰到的一些问题，如果有描述不正确，或者不明白的地方，应该是我才疏学浅，能力不到家所致，还请您不吝赐教。 BQ24610主要的等下电路如下图所示： 布板布局时应遵从高频回路最短的原则进行布局布线，使开关接点处的开启和关断时间降至最低，减少开关过程中的损耗，同时注意减少高频环路电流，基于这个基本原则，我给出以下的布局布线的意见： 输入电容应尽可能接近开关MOSFET电源和地，最好是紧贴着高边MOS的输入和低边MOS的输出，并用最短的铜箔进行连接。同时输入电容和高低边MOS应在同一层，走线应无过孔链接。 BQ24610应靠近开关MOSFET栅极端子放置，并有意加粗栅极的PCB走线（最好是20mil以上，周围包裹着电源地平面，在爬墙间距下，保证地线和信号线的间距为PCB厂商可以加工的最小间距即可），从而保持栅极驱动信号走线足够短，驱动信号足够干净。BQ24610到MOSFET的驱动走线可以走底层PCB。 将电感尽可能靠近开关MOSFET放置。尽量减少此处电场和磁场辐射，保证最小的敷铜面积（足够通过足量电流即可），不能使用多层链接，尽量不打过孔。 检流电阻应就近放置在输入输出位置上。布线上一定要单独引出测量线，如上图所示，在测量线上主要尽量走差分线，不打过孔。 如有需要，在可能产生高频影响的位置，增加旁路或者去耦电容。 地线一定要模拟地和数值地分开，并通过芯片的PAD进行单点接地，不要形成回路，同时需要注意两个地平面的完整性。 开关MOS、电感、芯片，要注意散热的布局，如芯片的PAD一定要可靠的和地平面链接，最好和整块铜层链接，增加散热面积。 所有线路的宽度和过孔数量、大小，应保证可以正常走流，无温升。 VFB的接线一定要从PACK的输出电容后级单独引线。 地平面和其他走线的间距一定要最小，减少寄生电容和寄生电感。 模拟器件一定要远离LX节点放置，适当增加旁路电容，减少干扰。 五、总结 切忌浮躁 执着，顽强,自信 举一反三 以上三点就是这回调试过程中，我总结出来最重要的东西。在开发过程中，做的比较深的时候，出现的问题已经太依赖你现在的环境，如果要找人来帮我，我还要花很长时间给他解释问题产生的原因，他也不会肯花大量时间从头跟进去。像这种问题在网上也找不到类似的答案。此时，虽然没人能帮我，但是我还是可以通过跟别人的讨论来得到一些有用的信息；虽然在网上找不到类似的答案，但我还是在网上一些类似应用的相关信息（比如找到了一个讲Boost的布线原则的，但还是可以应用Buck中的）；结合别人的指导，网络的信息，自己的分析，以前的经验，各种实验的排除，我这次才能完美的几角这个问题。","tags":"Electron Technology","url":"/Electron_Technology\\BQ24610_Debugging_Process.html"},{"title":"2016，启程","text":"在去年的圣诞的时候接到了接到一个不知道是什么滋味的电话，心情不知道怎么了有些不开心，想要出去散散心，也想祭奠下我已经逝去的青春，更想给自己的2016年一个不一样的开始。 有人说，十年中国看深圳，百年中国看上海，千年中国看北京，三千年中国看西安，五千年中国看山西。上回从新疆回来路过西安咸阳机场，就有想去西安看看的想法，忽然有了个想法：去一个陌生的城市——西安跨年，也看看秦一统六国的内史，大唐盛世中的京兆，八水绕长安的胜景。 2015年12月29日 晚上一下班就奔赴北京西站，乘坐晚上8点的Z43到西安去。一夜中，除了卧铺是上铺，空调开的比较冷，其他的都还好。顺道说下，如果有时间，千万要吃完饭再去火车站，火车站的东西真是又贵又难吃。 在等火车的过程中，接到一条通知短信，原定1号晚上ZH9404的航班被取消，被保护至3号晚上的ZH9404的航班，虽然这样有理由多玩两天，但是还要飞公司干活，时间紧，任务重，只好致电深航改签，一定要和客服说明，你要当天回来，第二天有事，要不深航客服，才不会帮你想办法。当然了结局都是不完美的，改签到了23点多的海航，真正的红眼航班，今年第一次哟！ 2015年12月30日 今天一早起来就到达西安站，很可惜我没有出西安站看看，这回时间上的安排有些不是很好，时间太紧了，8:30左右下了Z43次火车，不出站换乘，出发去华山站，我已经记不清有多久没有在火车上听到单口相声了，都快遗忘了这种腔调，好像是上了大学以后，坐车的时候就是喜欢做晚上的车，第二天早上下了车，就去玩或者办事。当听到火车上的单口相声，童年的记忆瞬时如潮涌般涌现，小时候我最喜欢的就是从姥姥家做火车，第一个是回家快，第二个不用在公交车上冻上2个小时。 下了火车，看到华山站，一股熟悉感铺面而来，感觉又回到了小时候，在姥姥家寒暑假过完，要乘火车回家的场景，但是，子欲养而亲不待，今年应该是姥姥走的第四个年头了！ 华山站看起来小小的，比华山北小多了。如果真想要一天往返华山，最好的建议是做早班的动车到华山北，做晚班的动车回西安，回西安的动车一直到晚上十点多，但是晚上要从华山景区到华山北站只能打车了，价格还算能接受吧，大概10分钟的路程，20元，基本上都是这个价。 不知道为什么华山游客中心的大门和售票处要设置这么远，大概从大门处下了出租车，往里走，要走8分钟左右吧！ 由于时间的问题，这回爬华山选择的是西峰索道上山，北峰索道下山，这也是我第一次坐索道上山，之前我都是在时间充足的前提下一步一步的征服大山。 从景区的游客中心，不管你是想步行上山，还是索道上山，都得坐景区的区间车。而且到西峰索道的时间比较长，大概得坐40多分钟的区间车，才可以到达索道下的停车场，这时从停车场开始爬山，大概需要10分钟左右才能到达索道检票口。这个有些比较坑，就算索道上下，爬华山您也要准备5-6小时，才可以玩的尽兴。 从早上到现在一直在路上奔波，都没有来得及吃口东西，现在到了索道下面，我得抓紧时间好好补充下体力，点了一碗拌面。华山景区的视频和水的价格不是一般的贵，时间充足，建议在华山市准备得当，再去华山游客中心，否则就只能认了，这样一碗热气腾腾的拌面要我40的软妹币，一瓶脉动要了我18。 缆车和设备看起来很新，安全性问题，应该可以不用担心，但是有恐高症的，我强烈建议不要乘坐华山的缆车。 华山的西峰缆车的运行轨迹有些像是大写字母\"N\"。 虽然华山的缆车上的风景很漂亮，很值一回票价，但是拍出的照片真的没有找到太好看的，始终有些不完美，因为缆车上你只能透过玻璃拍照、看景，基本上可以说是全密封吧！ 这辆铲车来头不小，据\"史书\"记载：\"公元2009年上站施工，数十名壮士肩扛背驮，运送本物到此，功垂索道建设大业！今存此以志华山精神。\" 华山如此陡峭，还能运送如此庞大的工具到此，可见人的潜能是无限的，只是缺少适当的环境去发挥而已。 在去往西峰山顶的路上碰到了华山上的挑山工，不能说华山的商店上宰客，确实卖给你们的东西都是由人力一步一步的挑上来的。 从华山西峰远眺华山市，从这你们应该不难看出，天上是蓝天，山下是雾霾成海。真希望今后有机会再来华山时，看到的不是霾海，而是华山市。 华山西峰登顶的必经之路，真的是在绝壁中爬上爬下。 华山其实很有意思，五座山峰像是人的五根手指一样，北峰是大拇指，东峰是食指，南峰是中指，西峰是无名指，中锋是小拇指。 这个照片中，还算勉强可以看清华山市。 据说这个叫神龟探海，看起来还真有些像。 好像每座名山中的松树或多或少都有些讲究，这颗松树好像叫拜公松。 华山最高峰，虽然比较俗气，但还是拍了个照片留作纪念。 从南峰顶眺望远处三公山，看起来山势连绵，非常大气。 在华山上，感觉最坑的就是这个华山论剑了，基本上每个山峰都有这么一块碑，都是金庸写的。 从华山顶远眺西峰顶，华山上的建筑真的是建在绝壁之上。 华山的南天门，从这过去就是华山的著名景点——长空栈道，如果大家时间不多，我不建议大家下长空栈道，不如去鹞子翻身走上一遭。 去往长空栈道上有劝你悬崖勒马的石刻，可惜俺就是来尝试下长空栈道的景象刺激的。 去往长空栈道的小路，确实很窄，仅能容一人上下。但从这一眼望去，山脉连绵不绝，确实很雄伟。 从山上小道下到长空栈道，虽然长空栈道不收门票钱，但是收租用安全绳的费用（30元）。这个建议大家都下去尝试下，我感觉还是蛮安全的。而且山下的风景比山上的风景要好很多。 但是长空栈道的尽头比较无聊，只有这么一颗松树，但是我也很佩服，有人能把红绳系到那么靠前去。 南天门后的钟，有什么传说，这个我就不知道了，只是当时看到了，随手拍了一张。 从南天门下来去，去玩东峰的小路，这段路，我感觉应该是华山中最好走的道了。 坑爹的华山论剑石碑！ 从东峰远眺下棋亭，可惜这回没有时间去了，听从鹞子翻身回来的朋友说，比长空栈道好，人还超少。下棋亭远眺群山的景色，也很超值了。 华山上的松树真的很多，东峰的登顶路。 中锋基本上没有拍照片了，感觉无聊一些，从中锋去金锁关的险道。 金锁关真的有很多的\"金锁\"，密密麻麻的！ 远眺北峰和北峰索道，北峰很值得登顶，据说有宝藏哟！ 华山是真的需要爬的，爬的你毫无俊男美女的形象可言。 自古华山一条路，如果体力不好，还是走新开辟的上山道吧！那里坡要缓一些，好走一些，当然要多走不少路。 华山最大的特点，感觉就是是和白桦树一样的山体颜色，还有万仞的悬崖绝壁，毫无着力点，估计攀岩的人，都不能从这上华山吧！ 这次华山的行程要结束了，有遗憾，有震撼，有可惜，遗憾是没有在东峰看到日出，没有在西峰看到日落，只在北峰的日月石看了下日落，也还蛮漂亮的；震撼的是华山的万仞绝壁，可惜的是我没有征服华山。 从北峰索道下来，看见了华山的冰瀑和危险的智取华山路，也算弥补了30号没有看到壶口瀑布的冰瀑的一个遗憾吧！ 华山北站，看起来真的比华山站大气很多，但是没有华山站的历史和记忆。华山，再见，希望有机会再见。 回到西安，第一件事就是直奔钟楼附近的同盛祥去尝一尝陕西特色——羊肉泡馍，但是累了一天了，还让我把两个馍掰成豆粒大小实在有些力不从心。除了羊肉泡馍，还买了柿子饼和炒凉粉，我个人觉得晚上吃羊肉泡馍有些太腻了，应该中午吃，但是柿子饼真不错。 找回青旅的上，走到了回民街，头一回见这么巨大的望远镜，你们猜猜这是干什么的，居然是看星星，当天雾霾，我反正用肉眼一颗星星也看不见，也就没有尝试用这么高大上的东西看下星星。 晚上的钟楼真的很漂亮，就是晚上不让进，有些可惜。 历经千辛万苦找到了我要住的旅舍，看着外面我以为关门了，还想着今晚睡在外面，但这些都是表象，外面很清静，里面非常热闹，这两天可能因为是元旦的原因，再一个西安是唐朝的长安城，所以住的外国人特别多。这家青旅很有特色，是个四合院，建议大家可以去尝试住下，一定不虚此行。 2015年12月31日 今天是很无聊的一天，我如同朝圣者一般，来回坐了快12个小时的大巴，只为了看一眼世界上最大的黄色瀑布、中国第二大的瀑布——黄河壶口瀑布。 早上起来，没有来得及吃早饭，就奔赴纺织城客运站准备乘坐去玩宜川、壶口的车，还好在客运站看到了魏家凉皮，值得尝试一下，味道很特别。 坐上车就睡着了，睡醒了就看到了陕西窑洞。 陕西以面食闻名天下，到了陕西，当然要尝试下各种面食，所以中午吃的是壶口特色臊子面，说实话，感觉没有大学中陕西人开的面馆里做的好吃。 重要的事情说三遍，壶口瀑布真的只有瀑布，真的只有瀑布，真的只有瀑布。 当我看到这么大流量的瀑布以及美丽的彩虹，感觉一切的努力都是值得的。 山西和陕西以黄河为界，所以壶口瀑布也分为陕西景区和山西景区，在陕西景区基本上看不到冰挂，只有从对岸看冰挂才会有一种震撼。 到了黄河，真有一种白日依山尽，黄河入海流的真实写照。 黄河瀑布的壮观美丽景象，手机真的拍摄不出来，应该弄个无人机过来，那就太赞了！ 以下就是号称陕西特色羊肉串，谈不上特别好吃，但是最起码是真羊肉！ 店家跑了，大串大家随便拿咯！ 晚上回到西安城，已经9点多了，德发长的饺子宴关门了，只好在大厅里点了三屉蒸饺，自己吃，还有酸汤水饺，酸汤水饺推荐大家尝一下，还是很不错的。 重要的事情说三遍，回民街逛逛就可以了，回民街逛逛就可以了，回民街逛逛就可以了。 一个很逗乐的老外，非要借人家三轮车来骑。 在一个岔道中找到了陕西人比较推荐的老米家大雨泡馍，虽然他家还没有关门，但是刚刚在德发长吃的太多了，到这已经吃不下了，只好下次到西安的时候来尝试一下了。 2016年1月1日 今天早上时间比较宽松，定的旅行团8：30在鼓楼附近集合，所以在旅舍周边找了一家老李家肉夹馍，尝了一下羊肉汤和腊牛肉肉夹馍，真的好好吃，和我们常吃的肉夹馍根本就是两种味道，羊肉汤熬得也很好，基本上没有膻味。 早起的西安，看起来灰蒙蒙的，到哪都是雾霾，这是我新年中比较郁闷的事了，白天的鼓楼也觉得不如晚上的鼓楼漂亮，但多了一种历史的沧桑感！ 今天行程的第一站，半坡遗址，了解下黄河流域的史前文化。 我个人觉得拍一下墓葬或者陪葬品不是很好，所以只是拍了一些模拟的生活照。 半坡遗址中最有明的人面鱼尾纹。 今天第二站就是华清宫，据说是杨贵妃洗澡的地方，这里我感觉是今天去的最无聊的地方。 华清宫中的腊梅，非常的漂亮，我感觉也很幸运，在他乡可以看到已经开放的腊梅。 据说是周恩来用过的澡堂，在当时算是比较豪华的了。 我不会被请去喝茶吧，俺怕怕的！ 团餐看起来还不错，但是我这要说的是，千万不要报团，说是没有购物，全程无购物，但是用餐时间安排了1个半小时，在路上反复强调蓝田玉有多么多么的好，但是蓝田现在不产玉，不产玉，不产玉。所以如果时间和金钱充足，一定要自己去，直接去秦始皇兵马俑，不要去骊山和华清宫，当然了如果有长恨歌表演，倒可以看看。 铜车马出土的照片，看起来真的很惨，据说兵马俑在历史上遭过两次灾。 铜车马一号车，做工真的很考究，栩栩如生。 铜车马二号车，也是所谓的帝驾，但是这回看到的赝品，正品据说在外巡回展览。 秦始皇兵马俑，真的像是1:1制造的，完全找到两个一模一样的佣人，穿戴，面目表情，各式各样，但也有这个1号坑看起来很震撼。 据说这个是三号坑中唯一一个没有经过修复的佣人，出土是就是这个模样。 三号坑中的军吏俑，据说三号坑是特种部队，一号坑是正规军，二号坑是作战指挥部，说起来还真有些像是那么回事。 骑兵俑 据说下面这个叫立射俑，刚刚听到的时候，我特别的想笑。 下面就是我们的二号坑，也是所谓作战指挥部，也是今天的最后一个景点。 秦始皇陵，一定要自己去，一定要自己去，一定要自己去，要不会很不爽，全程讲解员都在说蓝田玉怎么怎么的好，你一定要买，要不我就白讲解了！ 虽然有不开心的地方，但是也有好的，就是当地的火晶柿子饼和甜石榴确实很好吃，这个讲解员推荐的倒还可以，确实是又大又难看又白的石榴是最甜的！ 回到西安城以后，就要解决下晚饭了，尝了下陕西比较有名的biangbaing麺，在汉民街有一家面麺面里面做的还不错。 从汉民街步行回宾馆拿包，路过德福巷，也就是宾馆附近的酒吧一条街。 马上就要做机场大巴前往机场乘坐本年第一次的红眼航班回北京了！ 城内晚上感觉雾霾还算可以，或许我只是注意到了城内的繁华吧，但是上了机场高速就明显感觉到了雾霾的严重性，浓见度已经不足2公里。 新的一年，第一次红眼航班，第一次乘坐空客A330-243，第一次从西安机场起飞，第一次爬山坐缆车，第一次吃腊牛肉，这次旅途有太多的第一次了，也有太多的回忆了，让我忘记了2015年的忧伤，迎接2016年。 行程花费 行程花费预算，远远超标，我自己的预算经费，大概在2000左右，但是最后整个行程下来大概花费在2500左右，已经远远超出预算，看来下回出去玩，真的不能随性，应该好好查查攻略，做好资金预算。 项目类型 费用 占比 交通费用 ¥1032.64 41.4% 住宿费用 ¥105.00 4.2% 景点门票 ¥813.00 32.5% 美食费用 ¥266.00 10.7% 其他费用 ¥281.00 11.2% 总结 不要报名参加西北国旅，不要坐缆车上华山，不要只准备三天就来西安，别的都不重要了。","tags":"游记","url":"/Travels/2016_Start.html"},{"title":"写给自己，2015年末","text":"上了大学以后，每年都想要回顾一下这一年的经历，可是每每当我想要提笔，不知道怎么去写，一年拖一年，拖到现在。 2015年中，走过许多地方，经历很多事情。许多事情已经遗忘，化作时间长河中的一缕缕金沙。下面我就从四个方面简单的总结下2015年的自己，有好的，也有坏的。权当是给2016年的自己的激励吧！ 一、从生活上来讲 2015年一共365天，只陪父母在家呆了24天，其中春节有11天，元宵节4天，其余时间可以说是基本上没有回过家。虽有古话：父母在，不远游，游必有方。虽说是为了自己的将来在打拼，但这一年中还是感觉没有尽到为人子女的责任，期待来年会有更多的时间来回家敬养父母。 在2015年中，我走过8省12市3直辖市，乘坐过22次火车、2次汽车出行和10次飞机。走过的地方多了，认识的朋友也就多了，经历的事情也就多了，对很多的东西也有新的看法。我们明天起床，都是新的一天，不管昨天怎么样，我们都应该快乐的迎接新的一天，不该为了过去的、未来的事情愁眉苦脸，做好当下。 2015年中，还看了10多本的书，但多半是些杂书，小说，只有两本有关技术精进的书籍，今年总是抱怨没有时间看书，只有在地铁上的一点时间可以用来看书，今年年初时，我还想着翻译一本外文手册，一直也没有动笔，这是我比较遗憾的事情之一。 两天前，我在大学中有些暗恋（或许这种感情是暗恋吧，我也不知道，比朋友多一些，比恋人少一些）的女孩告诉我她有男朋友了。这是我唯一不知道心里是什么感觉的事情，就在几天前，我还在为她挑选一块粉晶，希望她可以在2016年找到她的幸福，但我真正听到她告诉我她有男朋友了，我真的不知道是应该祝福，还是应该懊悔，或许我就像我朋友说的一样吧，永远想的太多了。想我们的家庭、地理上的隔离、对她的一切不了解，不知道她在现在想什么，做什么，吃什么，今天高兴与否，或许正是这些担忧，注定了我们只能做朋友，希望今后，我们不要走着走着就散了。 二、从工作上来说 2015年，是我做出改变的一年，从边陲之地——哈尔滨来到了帝都——北京，从简单的制作DIY机器人传感器模块，到设计家庭服务机器人的主控板和基本执行程序。 在这一年中，虽然学会了许多的东西，但主要是待人接物的处事方法，但我还是喜欢以诚待人，即使被人说成傻子，但我本来也不是很奸，也不是很懂得拒绝别人。还有就是产品的总体设计和扫地机的相关技术，了解了一款产品从最初的模型到成品的不容易，和基本上的几个过程。 唯一让我感觉很无奈的事情就是：不知道为什么来到北京之后，感觉自特别忙碌，不知道整日都在忙些什么，春夏秋冬过的特别快，我还以为昨天我刚刚来到北京呢！没有原来在哈尔滨搞设计的成就感，或许感觉上很空虚，实际上还很充实吧！ 三、从财政上来看 2015年的个人的账务，可以说是一个很糟糕的情况，从年初的基本无负债，到现在负债15000多（大部分是JD的12期、24期的无息分期）的严重赤字。我都有些不敢想象一旦我没有了工资了，我要怎么办，我想是时候对我花销方式做出改变和规划了，要不欠账只会越来越多。 目前，我想到的方式只有，在买东西的时候，多问自己一句，有必要去花费这些钱来买这些东西吗？在打算出大笔花销的时候，问问自己这么做值得吗？ 四、从健康上来瞧 今天称了下体重，感觉来到北京之后，体重好像有又涨了5公斤，可能和我整日没有运动量，在电脑前干活有关，感觉自己应该适当增加运动量了，不能一天宅在家了。 2015年中，还有一件大事，估计就是工作中不慎摔落，导致小臂骨错位，这次受伤估计是我小学毕业以后最严重的一次，估计还得需要2-3个月的休养，胳膊才能恢复正常的使用功能。 总结 2015，有过欢笑，有过痛苦，现在只剩下4个数字，和数不清的结果，有好的，也有坏的，毕竟都是自己的选择，不曾后悔，问心无愧。 2016，我来了！我带着梦想而来！ 2016，学会拒绝！ 2016，能做100个俯卧撑！ 2016，日本，我等你！ 2016，Led Art！ 2016，啃下自动化！ 2016，English，I Love You！ 2016，110kg！","tags":"日记","url":"/Diary/The_end_of_2015_wrote_to_myself.html"},{"title":"超频变砖不用怕，自己动手不求人","text":"人非圣贤，马有失蹄。虽然说NETGEAR 8000刷机和设置过程还是相对安全的，万一遇到断电等不可抗因素和设置过程中误设置，还是有成砖头的危险。一般来说，只要硬件无损坏，不去刷死CFE，都是可以救回来的。 如何刷DD固件就不在这里说了，直接升级就可以了！想刷回固件也很方便，第一种方法也是采用直接升级就好了，第二种就是下面这种应付各种意外情况的刷机。 一、准备工具 Waveshare FT232 USB to TTL Putty R8000-V1.0.2.44_1.0.96.chk 如果遇到上述链接无法访问，请您自行想办法。 友情提示：中国拥有世界上第八大奇迹——长城。 二、安装TFTP客户端 这步基本上很简单，按照下面图示操作就好了。 基本流程就是：找到计算机中的卸载或更改程序（程序和功能），在左侧的打开或关闭Windows功能中，勾选TFTP客户，点击确定就好。 三、拆解R8000，并连接TTL 要说明的是，拆解会让你的R8000失去保修。拆掉R8000螃蟹壳上的10壳螺丝，其中有一颗螺丝在贴纸下方，需要揭掉贴纸。并拆掉天线连接，拿出主板，按照下图说明，和买来USB to TTL连接，进入准备刷机的状态。 P.S. 建议拆机，手接触主板之前，用手摸摸暖气，把自己脱个精光。 四、设置Putty 1、在计算机的设备管理器中检查COM端口，并设置为\"115200\"，数据位\"8\"，停止位\"1\"。 2、打开PuTTY，按照下图进行设置。 3、回到PuTTY的主页面，选择连接方式为Serial并填入相对的COM端口，传输速率会自动变成之前设置好的。 4、运行PuTTY，在R8000未通电开启之前，PuTTY窗口样式为下图。 五、满血复活 1、插入R8000电源，可以看到Putty界面上会显示一堆初始化，开机信息，这个时候，点进Puttty窗口中，不断的按CTRL-C，终止初始化，进入CFE模式，此时会显示如下信息： Startup Canceled CFE> 2、通过以下命令擦除现有固件 CFE> nvram erase 3、重启R8000 CFE> reboot 4、重复1中的动作，再次进入CFE模式。 5、进入TFTP模式，键入命令后，会出现如下界面。 CFE> tftpd Start TFTP Server Reading : : 6、到此路由器设置，完毕，下面我们将网线插入R800的LAN口中，另一端与电脑相连，并在电脑上对以太网属性，进行如下设置。 7、以管理员打开命令提示符，并确认R8000进入TFTP模式（ TTL = 100）。 ping 192.168.1.1 8、使用CMD的CD命令定位刚刚下载的CHK文件的所在目录，并执行以下命令上传至R8000。 tftp -i 192.168.1.1 PUT R8000-V1.0.2.44_1.0.96.chk 9、等待，大概需要3-5分钟，访问192.168.1.1会看到熟悉的界面。 六、结束语 因为误设置导致R8000变砖，但实际刷完DD- WRT ，感觉性能还不如原版固件，不知道是不是因为我设置不对的问题，求大神讲解设置过程。","tags":"Computer Hardware","url":"/Computer-Hardware/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself.html"},{"title":"吴军《浪潮之巅》书评","text":"这本书读完有一段时间了，一直不知道怎么把它推荐给大家，其中虽没有光怪陆离的世界，但有互联网过去几十年的发展历程，或许其中带有一些作者的主观色彩，但总体来说还是以局外人纪实写些发生的事情，初起的时候，我并不是很喜欢这本书，但读着读着，我也喜欢这本书的叙事风格，平实不乏有趣，又了解了IT行业的历史和更迭。 一、您在哪里可以找到它 1、 google的黑板报 2、 亚马逊 二、这本书写了些什么 计算机领域的发展在吴军看来是一波波的浪潮，幸运的公司可以借浪前行，但更多的是在大海深处长眠。互联网、计算机使得时间变短，也就意味着技术更迭加快，浪潮的时间短，三年河东三年河西，变为了现实，记得我刚上高中时，我都不知道iphone是什么品牌，只知道诺基亚和三星，三年过后，我拿着iphone进入到大学中，同学都问我这是什么手机，当时很多人真的只是喜欢iphone的简洁易用，现在iphone已经满大街都是，已经成了一款装逼利器，很少见到有人能用明白iphone，100%发挥其功能的，但不管怎么说，Apple公司在智能手持终端这个浪潮中赚的盆满钵满。 这本书也是详细讲诉了浪潮的形成原因、过程，和过往的公司的丰功伟绩、过失。详细的展现了IT领域的70-20-10的规律，就是在一个细分的市场，往往只能容下一家大的，占有7成的市场份额，还有一家老二，占有2成的份额，其它的若干公司，只能分剩下的1成份额。赢者通吃，在IT领域显现的尤为明显。所以如果做不成老大，是很难办的。就像今天的云服务、大数据、机器人、无人机等行业，百家争鸣，确实热闹，我们都能看到这是未来发展的趋势，但无限的机会中并不代表你就可以借浪前行。 这时你会问，传统的巨头就这么看着你们蚕食它们的市场吗？答案很明显，是已经固化的基因和思维阻挡了他们的前行的脚步，就像人的性格和思维很难改变一样，公司的基因和思维方式也是很难改变的。在吴军的书中是这么写的：一个公司在一个领域越成功，它积累的文化、做事方式、流程、决策机制等，越适合这一个领域，那么在面对新市场时，越扭转不过来思维。 书中描述了一波波浪潮的特征。但就像说人这一辈子一样，虽然生来含着金汤匙，但不是一辈子就能永远顺风顺水。公司的发展不可能只靠浪潮来推进，这样的公司也做不大。管理、创始人的个人能力、资源等等，都是影响到一个公司的未来发展的者重要因素。但了解浪潮，可以避免自己在择业、创业过程中不要做出不自量力的事。 三、我了解到了什么 \"读史使人明智\"，这句话不是白说的，至少我了解了一些大公司的过往，所谓的天使投资、风投等一些经济常识。这本可以说是IT界的《史记》，从过往的公司，历史留名的人物，描述了一个IT时代历史。当然，由于作者的时间和学识有限，从中了解历史十分有限，不够详细，很多时候要查一些资料才能更了解当时的情况，但大纲讲的已经比较清晰明了。 最后，值得说的是，吴军的文笔实在太好了，读起他的文字完全是一种享受，很平实，很靠谱。","tags":"书评","url":"/Book_Review/On_Top_of_Tides.html"},{"title":"雷米《心理罪》系列书评","text":"好像从初中毕业后，也看过不少的书籍，有专业书籍，也有小说、散文等，但好像从初中毕业以后就没有写过读后感和书评了。今天把雷米写的心理罪系列的小说看完了，忽然想要写下我自己的书评，或许这个系列小说，给我的印象太深刻了吧！即使您不是一个喜欢看犯罪类、刑侦类小说的人，我个人也建议您有时间可以看下，您会喜欢上心理罪的。 心理罪 ，我个人认为是值得为之付出RMB的，故在此给出正版书籍的购买链接，希望大家可以支持下作者。 如果您的资金有限，又想赏读大师之作，你可以通过 百度网盘链接 和密码(qshi)进行下载阅读试看，但个人真心希望您在看完免费的以后，会和我一样，购买一套正版书籍进行收藏。 不管您是否购买了正版书籍，您都应当下载下电子版的书籍，因为电子版中有四篇番外篇不曾出版，这四篇番外篇会帮助您更好的理解心理罪。以下是我推荐给您的心理罪系列小说的阅读顺序。 1 、 前传 第七个读者 2 、 番外一 毒树之果 3 、 心理罪一 画像 4 、 番外二 斯金纳之箱 5 、 心理罪二 教化场 6 、 番外三 月光的谎言 7 、 心理罪三 暗河 8 、 心理罪四 城市之光 9 、 番外四 两生花 心理罪系列小说既是连贯的，也是独立的。说它是连贯的，是因为这部小说，您必须从第一部开始都，才能真正的体会到作者对人性的理解。说它是各部分是独立的，是因为每部小说中发生的案件，与前后会有一些关联，单都可以独立成文，案件前后并无悬念。 主人公：方木，天才犯罪心理学家，也是一个悲剧的猪脚，或许天生自带灾难光环吧。但不影响我们看出他的个性以及天赋，在大学中就连破大案，看透人性。但随着时间和案件的发展，他的信仰摇摇欲坠，作者赋予他了破案的天赋，但缺利用这种天赋塑造了一个悲剧的开始，和一个还算美好的轮回。 或许很长时间没有写书评了，都不会写内容的简介了，那我再此也不要献丑了，详细的内容，还是由大家自己去看心理罪的书籍吧！我这里只能说，光明不存在，存在的或许只是黑暗中一盏指路的明灯。或许悲观，或许有些宗教，但是我们不正是这样劝自己活着幸福就好，但幸福是什么，谁也说不清，道不明。 看完本书之后，我只想说世上多是轮回，在罪恶之深处的轮回。也许没有他方木，就不会带来这么多死亡…… 最后说下，我推荐心理罪的原因吧，原因有三，一是非常好的犯罪小说，二是它同时也是一部非常好的悬疑小说，三是来看看这个叫方木这个男人吧！ 感谢雷米（lane_lau）大侠给了我这么一本书，这么一个让我可以经历不同人生的书。我最喜欢的一句话就是一段光影，一段人生，我想现在我可以将它改为一段光阴，一段人生，一部书籍，一个世界。","tags":"书评","url":"/Book_Review/Psychological_Crime.html"},{"title":"基于STM32CubeF4移植FreeModbus到STM32F411VET6","text":"首先，本人需要声明一下，本文所移植FreeModbus的过程仅能用作参考，虽然FreeModbus的库已经用在工程很多年，但是由于移植的代码，本人经验等问题，所以本人不建议您直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我在此次移植过程中，主要用到以下几个程序与工具： 32F411EDISCOVERY FreeModbus v1.5 Modbus Poll v6.3.0 STM32CubeMX_V4.8.0 STM32Cube_FW_F4_V1.6.0 Keil_MDK_ARM_V5.15.0 在移植过程中，主要用到芯片的外设有USART1（ PB6 、 PB7 ）和TIMER11，请您根据实际情况进行设置。其中TIMER的设置，您需要设置时钟的信号基准为50uS，时钟产生中断的时间为1750uS（串口波特率大于19200时，在mbrtu.c中有具体的描述），也就是35个基准时间。 二、拷贝需要的文件到工程目录下 1、解压缩通过下载得到的freemodbus-v1.5.zip。 2、按照下列的文件列表拷贝相应的文件到对应的目录（没有路径，需要自己建），并在 keil中设置好相应的头文件引用路径和源码文件的引用。 拷贝文件到工程文件夹示例： 工程文件夹 │ . mxproject │ < 工程名 > . ioc │ ├─ Drivers // 底层驱动文件夹 ├─ Inc // 头文件存放位置 │ │ gpio . h │ │ stm32f4xx_hal_conf . h │ │ stm32f4xx_it . h │ │ tim . h │ │ usart . h │ │ │ └─ Modbus // Modbus 需要用到的头文件 │ ├─ modbus_driver // Modbus 函数等头文件 │ │ ├─ include // Modbus 通用函数头文件 │ │ │ mb . h │ │ │ mbconfig . h │ │ │ mbframe . h │ │ │ mbfunc . h │ │ │ mbport . h │ │ │ mbproto . h │ │ │ mbutils . h │ │ │ │ │ └─ rtu // Modbus RTU 函数头文件 │ │ mbcrc . h │ │ mbrtu . h │ │ │ └─ modbus_user // Modbus 用户配置头文件 │ port . h │ ├─ MDK - ARM │ BPEER_USART_TEST . uvprojx │ └─ Src │ gpio . c │ main . c │ stm32f4xx_hal_msp . c │ stm32f4xx_it . c │ tim . c │ usart . c │ └─ Modbus // Modbus 需要用到的源码文件 ├─ modbus_driver │ │ mb . c // Modbus 基本函数和设置源码文件 │ │ │ ├─ functions // Modbus 通用函数源码文件 │ │ mbfunccoils . c │ │ mbfuncdiag . c │ │ mbfuncdisc . c │ │ mbfuncholding . c │ │ mbfuncinput . c │ │ mbfuncother . c │ │ mbutils . c │ │ │ └─ rtu // Modbus RTU 函数源码文件 │ mbcrc . c │ mbrtu . c │ └─ modbus_user // Modbus 用户配置源码文件 portevent . c portserial . c porttimer . c 三、搞定Timer Timer的移植过程中，应该算是比较简单的了，需要简单的设置一下初始化的返回值，完整写出开启Timer的函数，停止Timer的函数，并对Timer回掉函数进行设置下，就OK了。 porttimer.c移植后的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* ----------------------- Platform includes ----------------------------*/ #include \"port.h\" #include \"stm32f4xx_hal.h\" #include \"tim.h\" /* ----------------------- Modbus includes ------------------------------*/ #include \"mb.h\" #include \"mbport.h\" /* ----------------------- static functions -----------------------------*/ /* ----------------------- Private define -------------------------------*/ #ifndef Modbus_TimHandle #define Modbus_TimHandle htim11 #endif /* ----------------------- Start implementation -------------------------*/ BOOL xMBPortTimersInit ( USHORT usTim1Timerout50us ) { /*系统初始化已经完成定时器的初始化，故在此不在进行初始化*/ return TRUE ; } inline void vMBPortTimersEnable ( ) { /* Enable the timer with the timeout passed to xMBPortTimersInit( ) */ /*Disable Timer and Reset Counter*/ HAL_TIM_Base_Stop_IT ( & Modbus_TimHandle ); __HAL_TIM_SET_COUNTER ( & Modbus_TimHandle , 0x0000 ); /*Enable Timer*/ HAL_TIM_Base_Start_IT ( & Modbus_TimHandle ); } inline void vMBPortTimersDisable ( ) { /* Disable any pending timers. */ HAL_TIM_Base_Stop_IT ( & Modbus_TimHandle ); } /* Create an ISR which is called whenever the timer has expired. This function * must then call pxMBPortCBTimerExpired( ) to notify the protocol stack that * the timer has expired. */ void prvvTIMERExpiredISR ( void ) { ( void ) pxMBPortCBTimerExpired (); } stm32f4xx_it.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* Includes ------------------------------------------------------------------*/ #include \"stm32f4xx_hal.h\" #include \"stm32f4xx.h\" #include \"stm32f4xx_it.h\" /* USER CODE BEGIN 0 */ #include \"mb.h\" #include \"mbport.h\" extern void prvvUARTTxReadyISR ( void ); extern void prvvUARTRxISR ( void ); extern void prvvTIMERExpiredISR ( void ); /* USER CODE END 0 */ …… …… …… /* USER CODE BEGIN 1 */ void HAL_TIM_PeriodElapsedCallback ( TIM_HandleTypeDef * htim ) { /* NOTE : This function Should not be modified, when the callback is needed, the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file */ prvvTIMERExpiredISR ( ); } /* USER CODE END 1 */ 四、搞定串口 串口比较难搞一些了，需要设置中断处理函数、串口初始化函数、串口输入输出函数、串口中断服务函数。 portserial.c移植后的代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #include \"port.h\" #include \"usart.h\" #include \"stm32f4xx_hal.h\" #include \"stm32f4xx_it.h\" /* ----------------------- Modbus includes ------------------------------*/ #include \"mb.h\" #include \"mbport.h\" /* ----------------------- static functions -----------------------------*/ void prvvUARTTxReadyISR ( void ); void prvvUARTRxISR ( void ); /* ----------------------- Private define -------------------------------*/ #ifndef Modbus_UartHandle #define Modbus_UartHandle huart1 #endif /* ----------------------- Start implementation -------------------------*/ void vMBPortSerialEnable ( BOOL xRxEnable , BOOL xTxEnable ) { /* If xRXEnable enable serial receive interrupts. If xTxENable enable * transmitter empty interrupts. */ if ( xRxEnable ) { /* Enable the UART Data Register not empty Interrupt */ __HAL_UART_ENABLE_IT ( & Modbus_UartHandle , UART_IT_RXNE ); } else { /* Disable the UART Data Register not empty Interrupt */ __HAL_UART_DISABLE_IT ( & Modbus_UartHandle , UART_IT_RXNE ); } if ( xTxEnable ) { /* Enable the UART Transmit data register empty Interrupt */ __HAL_UART_ENABLE_IT ( & Modbus_UartHandle , UART_IT_TXE ); prvvUARTTxReadyISR (); } else { /* Disable the UART Transmit data register empty Interrupt */ __HAL_UART_DISABLE_IT ( & Modbus_UartHandle , UART_IT_TXE ); /* Enable the UART Transmit Complete Interrupt */ __HAL_UART_ENABLE_IT ( & Modbus_UartHandle , UART_IT_TC ); } } BOOL xMBPortSerialInit ( UCHAR ucPORT , ULONG ulBaudRate , UCHAR ucDataBits , eMBParity eParity ) { /*由于已经在系统初始化中已经完成串口初始化，故在此不需要再一次进行初始化*/ return TRUE ; } BOOL xMBPortSerialPutByte ( CHAR ucByte ) { /* Put a byte in the UARTs transmit buffer. This function is called * by the protocol stack if pxMBFrameCBTransmitterEmpty( ) has been * called. */ if ( HAL_UART_Transmit ( & Modbus_UartHandle ,( uint8_t * ) & ucByte , 1 , 0x01 ) != HAL_OK ) { return FALSE ; } else { return TRUE ; } } BOOL xMBPortSerialGetByte ( CHAR * pucByte ) { /* Return the byte in the UARTs receive buffer. This function is called * by the protocol stack after pxMBFrameCBByteReceived( ) has been called. */ if ( HAL_UART_Receive ( & Modbus_UartHandle ,( uint8_t * ) pucByte , 1 , 0x01 ) != HAL_OK ) { return FALSE ; } else { return TRUE ; } } /* Create an interrupt handler for the transmit buffer empty interrupt * (or an equivalent) for your target processor. This function should then * call pxMBFrameCBTransmitterEmpty( ) which tells the protocol stack that * a new character can be sent. The protocol stack will then call * xMBPortSerialPutByte( ) to send the character. */ void prvvUARTTxReadyISR ( void ) { pxMBFrameCBTransmitterEmpty ( ); } /* Create an interrupt handler for the receive interrupt for your target * processor. This function should then call pxMBFrameCBByteReceived( ). The * protocol stack will then call xMBPortSerialGetByte( ) to retrieve the * character. */ void prvvUARTRxISR ( void ) { pxMBFrameCBByteReceived ( ); } stm32f4xx_it.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @brief This function handles USART1 global interrupt. */ void USART1_IRQHandler ( void ) { /* USER CODE BEGIN USART1_IRQn 0 */ if ( __HAL_UART_GET_IT_SOURCE ( & huart1 , UART_IT_RXNE ) != RESET ) { prvvUARTRxISR (); //接收中断处理函数 } if ( __HAL_UART_GET_IT_SOURCE ( & huart1 , UART_IT_TXE ) != RESET ) { prvvUARTTxReadyISR (); //发送完成终端处理函数 } HAL_NVIC_ClearPendingIRQ ( USART1_IRQn ); /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler ( & huart1 ); /* USER CODE BEGIN USART1_IRQn 1 */ /* USER CODE END USART1_IRQn 1 */ } 五、搞定其他配置 1、搞定开关中断操作 port.h移植后的部分代码如下所示： 1 2 3 4 /*禁用全部中断*/ #define ENTER_CRITICAL_SECTION( ) __disable_irq() /*开启全部中断*/ #define EXIT_CRITICAL_SECTION( ) __enable_irq() 2、搞定系统配置 mb.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /*设置启用Modbus RTU 模式，减少编译后的代码量*/ #if MB_RTU_ENABLED == 1 #include \"mbrtu.h\" #endif /*减少编译后代码错误以及修改，将判定值由1改为0，并修改MB_ASCII_ENABLED的定义为0， 想要了解原因，请自行修改编译查看*/ #if MB_ASCII_ENABLED == 1 #include \"mbascii.h\" #endif /*减少编译后代码大小，将判定值由0改为1，并修改MB_TCP_ENABLED的定义为0，想要了解 原因，请自行修改编译查看*/ #if MB_TCP_ENABLED == 1 #include \"mbtcp.h\" #endif 3、搞定寄存器地址差一的问题 需要在源码中注释掉所有的 usRegAddress++; 。 4、搞定keil编译过程中出现的各种警告 mb.h移植后的部分代码如下所示： 1 2 3 4 5 6 extern void xMBUtilSetBits ( UCHAR * ucByteBuf , USHORT usBitOffset , UCHAR ucNBits , \\ UCHAR ucValue ); extern UCHAR xMBUtilGetBits ( UCHAR * ucByteBuf , USHORT usBitOffset , UCHAR ucNBits ); mbrtu.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 eMBErrorCode eMBRTUReceive ( UCHAR * pucRcvAddress , UCHAR ** pucFrame , USHORT * pusLength ) { /*处女座心理，必须要求无错误、无警告、可过PC-Lint，目前也没有发现这个定义的用处*/ // BOOL xFrameReceived = FALSE; eMBErrorCode eStatus = MB_ENOERR ; ENTER_CRITICAL_SECTION ( ); assert ( usRcvBufferPos < MB_SER_PDU_SIZE_MAX ); /* Length and CRC check */ if ( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN ) && ( usMBCRC16 ( ( UCHAR * ) ucRTUBuf , usRcvBufferPos ) == 0 ) ) { /* Save the address field. All frames are passed to the upper layed * and the decision if a frame is used is done there. */ * pucRcvAddress = ucRTUBuf [ MB_SER_PDU_ADDR_OFF ]; /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus * size of address field and CRC checksum. */ * pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC ); /* Return the start of the Modbus PDU to the caller. */ * pucFrame = ( UCHAR * ) & ucRTUBuf [ MB_SER_PDU_PDU_OFF ]; // xFrameReceived = TRUE; } else { eStatus = MB_EIO ; } EXIT_CRITICAL_SECTION ( ); return eStatus ; } 5、未知原因的添加代码 这部分代码没有明白，为什么需要添加，有些没有研究透，希望有大神可以指点。 mbrtu.c移植后的部分代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 eMBErrorCode eMBRTUSend ( UCHAR ucSlaveAddress , const UCHAR * pucFrame , USHORT usLength ) { eMBErrorCode eStatus = MB_ENOERR ; USHORT usCRC16 ; ENTER_CRITICAL_SECTION ( ); /* Check if the receiver is still in idle state. If not we where to * slow with processing the received frame and the master sent another * frame on the network. We have to abort sending the frame. */ if ( eRcvState == STATE_RX_IDLE ) { /* First byte before the Modbus-PDU is the slave address. */ pucSndBufferCur = ( UCHAR * ) pucFrame - 1 ; usSndBufferCount = 1 ; /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */ pucSndBufferCur [ MB_SER_PDU_ADDR_OFF ] = ucSlaveAddress ; usSndBufferCount += usLength ; /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */ usCRC16 = usMBCRC16 ( ( UCHAR * ) pucSndBufferCur , usSndBufferCount ); ucRTUBuf [ usSndBufferCount ++ ] = ( UCHAR )( usCRC16 & 0xFF ); ucRTUBuf [ usSndBufferCount ++ ] = ( UCHAR )( usCRC16 >> 8 ); /* Activate the transmitter. */ eSndState = STATE_TX_XMIT ; /*插入代码 启动第一次发送，这样才可以进入发送完成中断*/ xMBPortSerialPutByte ( ( CHAR ) * pucSndBufferCur ); pucSndBufferCur ++ ; usSndBufferCount -- ; vMBPortSerialEnable ( FALSE , TRUE ); } else { eStatus = MB_EIO ; } EXIT_CRITICAL_SECTION ( ); return eStatus ; } 六、搞定主函数 主函数需要设置数组和处理函数，无其他设置，我放上我移植的代码以供参考。 main.c移植后的代码如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 /* Includes -------------------------------------------------------------*/ #include \"stm32f4xx_hal.h\" #include \"adc.h\" #include \"tim.h\" #include \"usart.h\" #include \"gpio.h\" /* USER CODE BEGIN Includes */ #include \"mb.h\" #include \"mbport.h\" /* USER CODE END Includes */ /* Private variables ----------------------------------------------------*/ /* USER CODE BEGIN PV */ /*线圈状态寄存器*/ #define REG_COILS_START 0x0000 #define REG_COILS_SIZE 8 /*线圈状态输入寄存器*/ #define REG_DISCRETE_START 0x0000 #define REG_DISCRETE_SIZE 8 /*保持寄存器*/ #define REG_HOLDING_START 0x0000 #define REG_HOLDING_NREGS 10 /*输入寄存器*/ #define REG_INPUT_START 0x0000 #define REG_INPUT_NREGS 1 /* USER CODE END PV */ /* Private function prototypes ------------------------------------------*/ void SystemClock_Config ( void ); /* USER CODE BEGIN PFP */ /* USER CODE END PFP */ /* USER CODE BEGIN 0 */ /*定义线圈状态寄存器的地址起始值和存储数组*/ uint8_t ucRegCoilsStart = REG_HOLDING_START ; uint8_t ucRegCoilsBuf [ REG_COILS_SIZE / 8 ]; /*定义线圈输入状态寄存器的地址起始值和存储数组*/ uint8_t ucRegDiscreteStart = REG_HOLDING_START ; uint8_t ucRegDiscreteBuf [ REG_DISCRETE_SIZE / 8 ]; /*定义保持寄存器的地址起始值和存储数组*/ uint16_t usRegHoldingStart = REG_HOLDING_START ; uint16_t usRegHoldingBuf [ REG_HOLDING_NREGS ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 }; /*定义输入寄存器的地址起始值和存储数组*/ uint16_t usRegInputStart = REG_INPUT_START ; uint16_t usRegInputBuf [ REG_INPUT_NREGS ]; /* USER CODE END 0 */ int main ( void ) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration-------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init (); /* Configure the system clock */ SystemClock_Config (); /* Initialize all configured peripherals */ MX_GPIO_Init (); MX_ADC1_Init (); MX_TIM1_Init (); MX_TIM4_Init (); MX_TIM11_Init (); MX_USART1_UART_Init (); /* USER CODE BEGIN 2 */ /*设置Modnbus以RTU模式运行，从机ID为0x01，串口为默认串口，串口波特率为115200，无奇偶校验*/ eMBInit ( MB_RTU , 0x01 , 1 , 115200 , MB_PAR_NONE ); /* Enable the Modbus Protocol Stack. */ eMBEnable (); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while ( 1 ) { ( void ) eMBPoll (); __HAL_TIM_SetCompare ( & htim4 , TIM_CHANNEL_1 , usRegHoldingBuf [ 0 ]); __HAL_TIM_SetCompare ( & htim4 , TIM_CHANNEL_2 , usRegHoldingBuf [ 1 ]); __HAL_TIM_SetCompare ( & htim4 , TIM_CHANNEL_3 , usRegHoldingBuf [ 2 ]); __HAL_TIM_SetCompare ( & htim4 , TIM_CHANNEL_4 , usRegHoldingBuf [ 3 ]); HAL_TIM_PWM_Start ( & htim4 , TIM_CHANNEL_1 ); HAL_TIM_PWM_Start ( & htim4 , TIM_CHANNEL_2 ); HAL_TIM_PWM_Start ( & htim4 , TIM_CHANNEL_3 ); HAL_TIM_PWM_Start ( & htim4 , TIM_CHANNEL_4 ); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } /** System Clock Configuration */ void SystemClock_Config ( void ) { RCC_OscInitTypeDef RCC_OscInitStruct ; RCC_ClkInitTypeDef RCC_ClkInitStruct ; __PWR_CLK_ENABLE (); __HAL_PWR_VOLTAGESCALING_CONFIG ( PWR_REGULATOR_VOLTAGE_SCALE2 ); RCC_OscInitStruct . OscillatorType = RCC_OSCILLATORTYPE_HSI ; RCC_OscInitStruct . HSIState = RCC_HSI_ON ; RCC_OscInitStruct . HSICalibrationValue = 16 ; RCC_OscInitStruct . PLL . PLLState = RCC_PLL_ON ; RCC_OscInitStruct . PLL . PLLSource = RCC_PLLSOURCE_HSI ; RCC_OscInitStruct . PLL . PLLM = 8 ; RCC_OscInitStruct . PLL . PLLN = 200 ; RCC_OscInitStruct . PLL . PLLP = RCC_PLLP_DIV4 ; RCC_OscInitStruct . PLL . PLLQ = 4 ; HAL_RCC_OscConfig ( & RCC_OscInitStruct ); RCC_ClkInitStruct . ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 ; RCC_ClkInitStruct . SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK ; RCC_ClkInitStruct . AHBCLKDivider = RCC_SYSCLK_DIV1 ; RCC_ClkInitStruct . APB1CLKDivider = RCC_HCLK_DIV2 ; RCC_ClkInitStruct . APB2CLKDivider = RCC_HCLK_DIV1 ; HAL_RCC_ClockConfig ( & RCC_ClkInitStruct , FLASH_LATENCY_3 ); HAL_SYSTICK_Config ( HAL_RCC_GetHCLKFreq () / 1000 ); HAL_SYSTICK_CLKSourceConfig ( SYSTICK_CLKSOURCE_HCLK ); } /* USER CODE BEGIN 4 */ /** * @brief 输入寄存器处理函数，输入寄存器可读，但不可写。 * @param pucRegBuffer 返回数据指针 * usAddress 寄存器起始地址 * usNRegs 寄存器长度 * @retval eStatus 寄存器状态 */ eMBErrorCode eMBRegInputCB ( UCHAR * pucRegBuffer , USHORT usAddress , USHORT usNRegs ) { eMBErrorCode eStatus = MB_ENOERR ; int16_t iRegIndex ; // 用作例子 usRegInputBuf [ 0 ] = 0x11 ; // 例子结束 //查询是否在寄存器范围内 //为了避免警告，修改为有符号整数 if ( (( int16_t ) usAddress >= REG_INPUT_START ) \\ && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) ) { //获得操作偏移量，本次操作起始地址-输入寄存器的初始地址 iRegIndex = ( int16_t )( usAddress - usRegInputStart ); //逐个赋值 while ( usNRegs > 0 ) { //赋值高字节 * pucRegBuffer ++ = ( uint8_t )( usRegInputBuf [ iRegIndex ] >> 8 ); //赋值低字节 * pucRegBuffer ++ = ( uint8_t )( usRegInputBuf [ iRegIndex ] & 0xFF ); //偏移量增加 iRegIndex ++ ; //被操作寄存器数量递减 usNRegs -- ; } } else { //返回错误状态，寄存器数量不对 eStatus = MB_ENOREG ; } return eStatus ; } /** * @brief 保持寄存器处理函数，保持寄存器可读，可读可写 * @param pucRegBuffer 读操作时--返回数据指针，写操作时--输入数据指针 * usAddress 寄存器起始地址 * usNRegs 寄存器长度 * eMode 操作方式，读或者写 * @retval eStatus 寄存器状态 */ eMBErrorCode eMBRegHoldingCB ( UCHAR * pucRegBuffer , USHORT usAddress , USHORT usNRegs , eMBRegisterMode eMode ) { //错误状态 eMBErrorCode eStatus = MB_ENOERR ; //偏移量 int16_t iRegIndex ; //判断寄存器是不是在范围内 if ( ( ( int16_t ) usAddress >= REG_HOLDING_START ) \\ && ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) ) { //计算偏移量 iRegIndex = ( int16_t )( usAddress - REG_HOLDING_START ); switch ( eMode ) { //读处理函数 case MB_REG_READ : while ( usNRegs > 0 ) { * pucRegBuffer ++ = ( uint8_t )( usRegHoldingBuf [ iRegIndex ] >> 8 ); * pucRegBuffer ++ = ( uint8_t )( usRegHoldingBuf [ iRegIndex ] & 0xFF ); iRegIndex ++ ; usNRegs -- ; } break ; //写处理函数 case MB_REG_WRITE : while ( usNRegs > 0 ) { usRegHoldingBuf [ iRegIndex ] = * pucRegBuffer ++ << 8 ; usRegHoldingBuf [ iRegIndex ] |= * pucRegBuffer ++ ; iRegIndex ++ ; usNRegs -- ; } break ; } } else { //返回错误状态 eStatus = MB_ENOREG ; } return eStatus ; } /** * @brief 线圈寄存器处理函数，线圈寄存器可读，可读可写 * @param pucRegBuffer 读操作---返回数据指针，写操作--返回数据指针 * usAddress 寄存器起始地址 * usNRegs 寄存器长度 * eMode 操作方式，读或者写 * @retval eStatus 寄存器状态 */ eMBErrorCode eMBRegCoilsCB ( UCHAR * pucRegBuffer , USHORT usAddress , USHORT usNCoils , eMBRegisterMode eMode ) { //错误状态 eMBErrorCode eStatus = MB_ENOERR ; //寄存器个数 int16_t iNCoils = ( int16_t ) usNCoils ; //寄存器偏移量 int16_t usBitOffset ; //检查寄存器是否在指定范围内 if ( ( ( int16_t ) usAddress >= REG_COILS_START ) && ( usAddress + usNCoils <= REG_COILS_START + REG_COILS_SIZE ) ) { //计算寄存器偏移量 usBitOffset = ( int16_t )( usAddress - REG_COILS_START ); switch ( eMode ) { //读操作 case MB_REG_READ : while ( iNCoils > 0 ) { * pucRegBuffer ++ = xMBUtilGetBits ( ucRegCoilsBuf , usBitOffset , ( uint8_t )( iNCoils > 8 ? 8 : iNCoils ) ); iNCoils -= 8 ; usBitOffset += 8 ; } break ; //写操作 case MB_REG_WRITE : while ( iNCoils > 0 ) { xMBUtilSetBits ( ucRegCoilsBuf , usBitOffset , ( uint8_t )( iNCoils > 8 ? 8 : iNCoils ), * pucRegBuffer ++ ); iNCoils -= 8 ; } break ; } } else { eStatus = MB_ENOREG ; } return eStatus ; } /** * @brief 开关输入寄存器处理函数，开关输入寄存器，可读 * @param pucRegBuffer 读操作---返回数据指针，写操作--返回数据指针 * usAddress 寄存器起始地址 * usNRegs 寄存器长度 * eMode 操作方式，读或者写 * @retval eStatus 寄存器状态 */ eMBErrorCode eMBRegDiscreteCB ( UCHAR * pucRegBuffer , USHORT usAddress , USHORT usNDiscrete ) { //错误状态 eMBErrorCode eStatus = MB_ENOERR ; //操作寄存器个数 int16_t iNDiscrete = ( int16_t ) usNDiscrete ; //偏移量 uint16_t usBitOffset ; //判断寄存器时候再制定范围内 if ( ( ( int16_t ) usAddress >= REG_DISCRETE_START ) && ( usAddress + usNDiscrete <= REG_DISCRETE_START + REG_DISCRETE_SIZE ) ) { //获得偏移量 usBitOffset = ( uint16_t )( usAddress - REG_DISCRETE_START ); while ( iNDiscrete > 0 ) { * pucRegBuffer ++ = xMBUtilGetBits ( ucRegDiscreteBuf , usBitOffset , ( uint8_t )( iNDiscrete > 8 ? 8 : iNDiscrete ) ); iNDiscrete -= 8 ; usBitOffset += 8 ; } } else { eStatus = MB_ENOREG ; } return eStatus ; } /* USER CODE END 4 */ #ifdef USE_FULL_ASSERT /** * @brief Reports the name of the source file and the source line number * where the assert_param error has occurred. * @param file: pointer to the source file name * @param line: assert_param error line source number * @retval None */ void assert_failed ( uint8_t * file , uint32_t line ) { /* USER CODE BEGIN 6 */ /* User can add his own implementation to report the file name and line number, ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */ /* USER CODE END 6 */ } #endif /** * @} */ /** * @} */ /*************** (C) COPYRIGHT STMicroelectronics *****END OF FILE********/ 七、结语 本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。","tags":"STM32F411VET6","url":"/STM32F411VET6/Porting_FreeModbus_to_STM32F411VET6_based_on_STM32CubeF4.html"},{"title":"移植AN4657到STM32F411VET6","text":"首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我们在移植AN4657到STM32F411VET6的过程中主要用到以下程序和工具： 32F411EDISCOVERY X- CUBE - IAP - USART ( AN4657 ) Hypertrm STM32CubeMX_V4.8.0 STM32Cube_FW_F4_V1.6.0 Keil_MDK_ARM_V5.15.0 AN4657 -STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Inc AN4657 -STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Src 二、拷贝需要的文件到工程目录下 1、解压缩通过下载得到的AN4657压缩包。 2、拷贝路径（ AN4657 -STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Inc）中的 common.h 、 flash_if.h 、 menu.h 、 ymodem.h 到我们自己的工程路径下的Inc文件夹中。 3、拷贝路径（ AN4657 -STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Src）中的 common.c 、 flash_if.c 、 menu.c 、 ymodem.c 到我们自己的工程路径下的Src文件夹中，并在keil中添加相应的文件。 三、修改串口的基本设置 串口的基本设置在STM32Cube可以进行设置，并生成相应的设置代码，但在我们的移植文件中需要用到串口设置，故我们需要在 common.c 、 menu.c 、 ymodem.c 三个文件中进行修改，我的示例代码是用USART1作为演示。 common.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** @addtogroup STM32F4xx_IAP_Main * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"common.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ /* Private function prototypes ------------------------------------------*/ /* Private functions ----------------------------------------------------*/ menu.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"common.h\" #include \"flash_if.h\" #include \"menu.h\" #include \"ymodem.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ ymodem.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"flash_if.h\" #include \"common.h\" #include \"ymodem.h\" #include \"string.h\" #include \"menu.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif #define CRC16_F /* activate the CRC16 integrity */ /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ P.S. 1、 common.h 、 menu.h 、 ymodem.h 基本不需要任何修改，直接就可以用。 2、如果使用 32F411EDISCOVERY ，请您注意不要使用默认的USART1的IO设置，需要更改为 PB6 、 PB7 ，才可以正常使用，默认的TX引脚上接了一个uF级的电容，我因为这个事情调试了很长时间。 三、修改FLASH操作函数及其定义 在整个移植过程中，重头戏就是对 flash_if.h 和 flash_if.c 的移植，里面涉及到很多 处修改，大部分修改是因为M4系列的MCU对FLASH的操作，没有页（Page）的概念，只有扇区（Sector）的操作函数造成的。 所以，综上所述需要先将各种Page（ PAGE 、page）换成Sector，这样基本上可以解决掉一批错误。 flash_if.h 修改后如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 /* Define to prevent recursive inclusion --------------------------------*/ #ifndef __FLASH_IF_H #define __FLASH_IF_H /* Includes -------------------------------------------------------------*/ //修改引用的头文件为F4的 #include \"stm32f4xx_hal.h\" /* Exported types -------------------------------------------------------*/ /* Exported constants ---------------------------------------------------*/ /* Base address of the Flash sectors */ //定义扇区名和地址之间的关系，方便根据地址获取扇区的编号 #define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000) /* Base @ of Sector 0, 16 Kbyte */ #define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08004000) /* Base @ of Sector 1, 16 Kbyte */ #define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08008000) /* Base @ of Sector 2, 16 Kbyte */ #define ADDR_FLASH_SECTOR_3 ((uint32_t)0x0800C000) /* Base @ of Sector 3, 16 Kbyte */ #define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08010000) /* Base @ of Sector 4, 64 Kbyte */ #define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08020000) /* Base @ of Sector 5, 128 Kbyte */ #define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08040000) /* Base @ of Sector 6, 128 Kbyte */ #define ADDR_FLASH_SECTOR_7 ((uint32_t)0x08060000) /* Base @ of Sector 7, 128 Kbyte */ /* Error code */ enum { FLASHIF_OK = 0 , FLASHIF_ERASEKO , FLASHIF_WRITINGCTRL_ERROR , FLASHIF_WRITING_ERROR , FLASHIF_PROTECTION_ERRROR }; /* protection type */ enum { FLASHIF_PROTECTION_NONE = 0 , FLASHIF_PROTECTION_PCROPENABLED = 0x1 , FLASHIF_PROTECTION_WRPENABLED = 0x2 , FLASHIF_PROTECTION_RDPENABLED = 0x4 , }; /* protection update */ enum { FLASHIF_WRP_ENABLE , FLASHIF_WRP_DISABLE }; /* Define the address from where user application will be loaded. Note: the 1st sector 0x08000000-0x08003FFF is reserved for the IAP code */ //根据实际的片内Flash大小修改结束地址，并删除不用的宏定义 #define APPLICATION_ADDRESS (uint32_t)0x08004000 /* Start user code address */ /* Notable Flash addresses */ #define USER_FLASH_END_ADDRESS (uint32_t)0x0807FFFF /* Define the user application size */ #define USER_FLASH_SIZE (USER_FLASH_END_ADDRESS - APPLICATION_ADDRESS + 1) /* Small default template application */ /* Exported macro -------------------------------------------------------*/ /* ABSoulute value */ #define ABS_RETURN(x,y) ((x) < (y)) ? ((y)-(x)) : ((x)-(y)) /* Get the number of sectors from where the user program will be loaded */ #define FLASH_SECTOR_NUMBER ((uint32_t)(ABS_RETURN(APPLICATION_ADDRESS,FLASH_START_BANK1))>>12) /* Compute the mask to test if the Flash memory, where the user program will be loaded, is write protected */ #define FLASH_PROTECTED_SECTORS (~(uint32_t)((1 << FLASH_SECTOR_NUMBER) - 1)) /* Exported functions --------------------------------------------------*/ void FLASH_If_Init ( void ); uint32_t FLASH_If_Erase ( uint32_t StartSector ); uint32_t FLASH_If_GetWriteProtectionStatus ( void ); uint32_t FLASH_If_Write ( uint32_t destination , uint32_t * p_source , uint32_t length ); uint32_t FLASH_If_WriteProtectionConfig ( uint32_t modifier ); #endif /* __FLASH_IF_H */ /******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ flash_if.c 修改后如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ #include \"flash_if.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ /* Private function prototypes ------------------------------------------*/ //增加获取扇区的函数，方便获取扇区编号 static uint32_t GetSector ( uint32_t Address ); /* Private functions ----------------------------------------------------*/ /** * @brief Unlocks Flash for write access * @param None * @retval None */ void FLASH_If_Init ( void ) { /* Unlock the Program memory */ HAL_FLASH_Unlock (); /* Clear all FLASH flags */ //根据实际的MCU清除FLASH标志位 __HAL_FLASH_CLEAR_FLAG ( FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR ); /* Unlock the Program memory */ HAL_FLASH_Lock (); } /** * @brief This function does an erase of all user flash area * @param start: start of user flash area * @retval FLASHIF_OK : user flash area successfully erased * FLASHIF_ERASEKO : error occurred */ uint32_t FLASH_If_Erase ( uint32_t start ) { //将相关的Page参数均修改为M4的Sector 参数 uint32_t UserStartSector = FLASH_SECTOR_1 ; uint32_t NbrOfSector = 0 ; uint32_t SectorError = 0 ; FLASH_EraseInitTypeDef pEraseInit ; HAL_StatusTypeDef status = HAL_OK ; /* Unlock the Flash to enable the flash control register access *************/ HAL_FLASH_Unlock (); /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); NbrOfSector = FLASH_SECTOR_7 - UserStartSector + 1 ; pEraseInit . TypeErase = FLASH_TYPEERASE_SECTORS ; pEraseInit . Sector = UserStartSector ; pEraseInit . Banks = FLASH_BANK_1 ; pEraseInit . NbSectors = NbrOfSector ; pEraseInit . VoltageRange = FLASH_VOLTAGE_RANGE_3 ; status = HAL_FLASHEx_Erase ( & pEraseInit , & SectorError ); /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); if ( status != HAL_OK ) { /* Error occurred while Sector erase */ return FLASHIF_ERASEKO ; } return FLASHIF_OK ; } /* Public functions -----------------------------------------------------*/ /** * @brief This function writes a data buffer in flash (data are 32-bit aligned). * @note After writing data buffer, the flash content is checked. * @param destination: start address for target location * @param p_source: pointer on buffer with data to write * @param length: length of data buffer (unit is 32-bit word) * @retval uint32_t 0: Data successfully written to Flash memory * 1: Error occurred while writing data in Flash memory * 2: Written Data in flash memory is different from expected one */ uint32_t FLASH_If_Write ( uint32_t destination , uint32_t * p_source , uint32_t length ) { uint32_t i = 0 ; /* Unlock the Flash to enable the flash control register access *************/ HAL_FLASH_Unlock (); for ( i = 0 ; ( i < length ) && ( destination <= ( USER_FLASH_END_ADDRESS -4 )); i ++ ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( HAL_FLASH_Program ( FLASH_TYPEPROGRAM_WORD , destination , * ( uint32_t * )( p_source + i )) == HAL_OK ) { /* Check the written value */ if ( * ( uint32_t * ) destination != * ( uint32_t * )( p_source + i )) { /* Flash content doesn't match SRAM content */ return ( FLASHIF_WRITINGCTRL_ERROR ); } /* Increment FLASH destination address */ destination += 4 ; } else { /* Error occurred while writing data in Flash memory */ return ( FLASHIF_WRITING_ERROR ); } } /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); return ( FLASHIF_OK ); } /** * @brief Returns the write protection status of application flash area. * @param None * @retval If a sector in application area is write-protected returned value is a combinaison of the possible values : FLASHIF_PROTECTION_WRPENABLED, FLASHIF_PROTECTION_PCROPENABLED, ... * If no sector is write-protected FLASHIF_PROTECTION_NONE is returned. */ uint32_t FLASH_If_GetWriteProtectionStatus ( void ) { uint32_t ProtectedSector = FLASHIF_PROTECTION_NONE ; FLASH_OBProgramInitTypeDef OptionsBytesStruct ; /* Unlock the Flash to enable the flash control register access ********/ HAL_FLASH_Unlock (); /*Check if there are write protected sectors inside the user flash area*/ HAL_FLASHEx_OBGetConfig ( & OptionsBytesStruct ); /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); /* Get Sectors already write protected *********************************/ //后面的保护区域，没有看懂，所以直接屏蔽掉了 ProtectedSector = ~ OptionsBytesStruct . WRPSector ; /* Check if desired Sectors are already write protected ****************/ if ( ProtectedSector != 0 ) { /* Some sectors inside the user flash area are write protected */ return FLASHIF_PROTECTION_WRPENABLED ; } else { /* No write protected sectors inside the user flash area */ return FLASHIF_PROTECTION_NONE ; } } /** * @brief Configure the write protection status of user flash area. * @param protectionstate : FLASHIF_WRP_DISABLE or FLASHIF_WRP_ENABLE the protection * @retval uint32_t FLASHIF_OK if change is applied. */ uint32_t FLASH_If_WriteProtectionConfig ( uint32_t protectionstate ) { uint32_t ProtectedSector = 0x0 ; FLASH_OBProgramInitTypeDef config_new , config_old ; HAL_StatusTypeDef result = HAL_OK ; /* Get Sectors write protection status *********************************/ HAL_FLASHEx_OBGetConfig ( & config_old ); /* The parameter says whether we turn the protection on or off */ config_new . WRPState = ( protectionstate == FLASHIF_WRP_ENABLE ? OB_WRPSTATE_ENABLE : OB_WRPSTATE_DISABLE ); /* We want to modify only the Write protection */ config_new . OptionType = OPTIONBYTE_WRP ; /* No read protection, keep BOR and reset settings */ config_new . RDPLevel = OB_RDP_LEVEL_0 ; config_new . USERConfig = config_old . USERConfig ; /* Get Sectors already write protected *********************************/ //后面的保护区域，没有看懂，所以直接屏蔽掉了 ProtectedSector = config_old . WRPSector ; /* Unlock the Flash to enable the flash control register access *******/ HAL_FLASH_Unlock (); /* Unlock the Options Bytes ********************************************/ HAL_FLASH_OB_Unlock (); /* Erase all the option Bytes ******************************************/ //在HAL_F4的库中没有找到擦除命令位的函数，故在此注释掉 //result = HAL_FLASHEx_OBErase(); //if (result == HAL_OK) //{ config_new . WRPSector = ProtectedSector ; result = HAL_FLASHEx_OBProgram ( & config_new ); //} return ( result == HAL_OK ? FLASHIF_OK : FLASHIF_PROTECTION_ERRROR ); } /** * @brief 根据送入地址获取其所在扇区位置 * @param 需要知道所在扇区位置的地址 * @retval 扇区位置（FLASH_SECTOR_0——FLASH_SECTOR_7） */ //增加扇区编号的获取函数 static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_SECTOR_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_SECTOR_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_SECTOR_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_SECTOR_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_SECTOR_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_SECTOR_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_SECTOR_6 ; } else { sector = FLASH_SECTOR_7 ; } return sector ; } /** * @} */ /******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 四、Keil需要修改的位置 1、需要根据设置的APP程序起始的位置，设置KEIL中APP程序起始位置与程序空间大小 2、需要在User选项卡中增加自定义处理字符串， C:\\Program Files\\Keil\\ARM\\ARMCC\\bin\\fromelf.exe --bin -o .\\存放bin的路径\\bin文件的名称.bin .\\Keil编译后生成的axf的路径\\axf文件的名称.axf 五、设置中断向量表偏移 需要在 main.c 文件中的 /* USER CODE BEGIN 1 */ 和 /* USER CODE END 1 */ 之间增加一条设置中断向量表的语句 SCB->VTOR = FLASH_BASE | 0x4000; ，如下所示。 main.c增加的代码示意如下： 1 2 3 /* USER CODE BEGIN 1 */ SCB -> VTOR = FLASH_BASE | 0x4000 ; /* USER CODE END 1 */ 六、结语 关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。","tags":"STM32F411VET6","url":"/STM32F411VET6/Porting_AN4657_STM32Cube_IAP_using_UART_to_STM32F411VET6.html"},{"title":"移植tf-a 2.8, optee 3.19, u-boot 2022.10, linux6.1 (v23.06.21) 到正點原子( ALIENTEK ) STM32MP157D 開發板","text":"首先，本教程不是一個完整的初學者的教學手冊，需要閱讀人員，自行提前閱讀《【正點原子】STM32MP1嵌入式Linux驅動開發指南V2.0》和熟悉STM32相關工具的基本操作。 其次，本文的開發環境基於Windows 11 22H2 版本的WSL2 Ubuntu 22.04進行搭建，這樣的好處是直接利用Hyper-V的高效率和文件操作不需要自行設置，加快開發環境部署。 1 準備移植程序和工具 我們在移植的過程中主要用到以下程序和工具： STM32MP1STARTER STM32MP1Dev Yocto_SDKx86 stm32cubeprog 其中我們需要從【 STM32MP1STARTER 】獲取參考用的TSV，因爲新版本的固件名稱已經和正點原子的手冊中不一樣，變化比較大；然後由於現在各大廠商提供的支持越來越好，已經提供對應的開發工具包，我個人覺得沒有必要自己去一個個安裝，搭建開發環境，故在本教程中需要用到【Yocto_SDKx86】，進行開發環境的搭建；最後就是我們需要的相關源代碼包【STM32MP1Dev】和下載工具【stm32cubeprog】。 2 啓動流程和一些不明確的地方 2.1 啓動流程未清楚的地方 如上圖所示，STM32MP157系列支持兩種啓動方式，一種是安全啓動，一種是非安全啓動，但是找了許多資料，沒有查詢到第二種的方式實現，目前的資料都是第一種方式，通過 ROM —> FSBL —> OP - TEE —> U-boot —> Kernal —> USer,本教程也是基於這種方式移植。 2.2 關於STM32MP157D在800MHz運行下的情況 按照STM32官方的分立電源手冊【 AN5256 STM32MP151 、STM32MP153和STM32MP157分立电源硬件集成 】中的描述，個人的初略理解，STM32MP157如果要想在800Mhz運行，VDDCore應該在1.35V，但奇怪的是正點原子的板子只提供了1.2V，可測試固件可以跑到800MHz，所以現在沒有理解怎麽實現的。 3 配置開發環境 3.1 拷貝文件到工作目錄並解壓文件 在工作目录（stm32mp1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21）准备好下载好的三个压缩包並输入下列命令进行解压 $ tar -xvzf en.SOURCES-stm32mp1-openstlinux-5.15-yocto-kirkstone-mp1-v22.06.15.tar.xz $ tar -xvzf en.SDK-x86_64-stm32mp1-openstlinux-5.15-yocto-kirkstone-mp1-v22.06.15.tar.xz $ tar -xvzf en.FLASH-stm32mp1-openstlinux-5.15-yocto-kirkstone-mp1-v22.06.15.tar.xz 得到stm32mp1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21文件夹，里面就是源码、工具和镜像包。 stm32mp1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21 ├─images #官方开发板镜像包 │ └─stm32mp1 │ └─flashlayout_st-image-weston #參考flashlayout TSV │ ├─deleteall #擦除flashlayout TSV │ ├─extensible #用於SD卡flashlayout TSV │ └─optee #正常下載flashlayout TSV ├─sdk #交叉编译工具链 └─sources #源码 └─arm-ostl-linux-gnueabi ├─FIP_artifacts #FIP编译生成的结果存放目录 ├─gcnano-driver-stm32mp-6.4.13-stm32mp-r1-r0 #一个内核模块源码 ├─linux-stm32mp-6.1.28-stm32mp-r1-r0 #Linux源码及补丁 ├─optee-os-stm32mp-3.19.0-stm32mp-r1-r0 #OPTEE源码及补丁 ├─tf-a-stm32mp-v2.8.6-stm32mp-r1-r0 #TF-A源码及补丁 └─u-boot-stm32mp-v2022.10-stm32mp-r1-r0 #u-boot源码及补丁 3.2 安裝編譯工具鏈 进入到sdk目录下，輸入下列命令進行安裝 $ chmod +x ./st-image-weston-openstlinux-weston-stm32mp1-x86_64-toolchain-4.2.1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21.sh $ ./st-image-weston-openstlinux-weston-stm32mp1-x86_64-toolchain-4.2.1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21.sh 過程中的提示基本都默認即可。 安裝完成后，可以用以下命令測試下，輸入下令命令是否。 $ source /opt/st/stm32mp1/4.2.1-openstlinux-6.1-yocto-mickledore-mp1-v23.06.21/environment-setup-cortexa7t2hf-neon-vfpv4-ostl-linux-gnueabi $ arm-ostl-linux- 顯示如下信息，説明配置成功。 $ arm-ostl-linux- arm-ostl-linux-gnueabi-addr2line arm-ostl-linux-gnueabi-ld.gold arm-ostl-linux-musl-gcc-nm arm-ostl-linux-gnueabi-ar arm-ostl-linux-gnueabi-lto-dump arm-ostl-linux-musl-gcc-ranlib arm-ostl-linux-gnueabi-as arm-ostl-linux-gnueabi-nm arm-ostl-linux-musl-gcov arm-ostl-linux-gnueabi-c++filt arm-ostl-linux-gnueabi-objcopy arm-ostl-linux-musl-gcov-dump arm-ostl-linux-gnueabi-cpp arm-ostl-linux-gnueabi-objdump arm-ostl-linux-musl-gcov-tool arm-ostl-linux-gnueabi-dwp arm-ostl-linux-gnueabi-ranlib arm-ostl-linux-musl-gdb arm-ostl-linux-gnueabi-elfedit arm-ostl-linux-gnueabi-readelf arm-ostl-linux-musl-gdb-add-index arm-ostl-linux-gnueabi-g++ arm-ostl-linux-gnueabi-size arm-ostl-linux-musl-gprof arm-ostl-linux-gnueabi-gcc arm-ostl-linux-gnueabi-strings arm-ostl-linux-musl-ld arm-ostl-linux-gnueabi-gcc-ar arm-ostl-linux-gnueabi-strip arm-ostl-linux-musl-ld.bfd arm-ostl-linux-gnueabi-gcc-nm arm-ostl-linux-musl-addr2line arm-ostl-linux-musl-ld.gold arm-ostl-linux-gnueabi-gcc-ranlib arm-ostl-linux-musl-ar arm-ostl-linux-musl-lto-dump arm-ostl-linux-gnueabi-gcov arm-ostl-linux-musl-as arm-ostl-linux-musl-nm arm-ostl-linux-gnueabi-gcov-dump arm-ostl-linux-musl-c++filt arm-ostl-linux-musl-objcopy arm-ostl-linux-gnueabi-gcov-tool arm-ostl-linux-musl-cpp arm-ostl-linux-musl-objdump arm-ostl-linux-gnueabi-gdb arm-ostl-linux-musl-dwp arm-ostl-linux-musl-ranlib arm-ostl-linux-gnueabi-gdb-add-index arm-ostl-linux-musl-elfedit arm-ostl-linux-musl-readelf arm-ostl-linux-gnueabi-gprof arm-ostl-linux-musl-g++ arm-ostl-linux-musl-size arm-ostl-linux-gnueabi-ld arm-ostl-linux-musl-gcc arm-ostl-linux-musl-strings arm-ostl-linux-gnueabi-ld.bfd arm-ostl-linux-musl-gcc-ar arm-ostl-linux-musl-strip $ arm-ostl-linux- 4 TF -A 2.8移植 4.1 解壓源碼並編譯測試 進入之前準備好的源碼目錄 tf-a-stm32mp-v2.8.6-stm32mp-r1-r0 ，解壓並打好補丁文件。可以參考README.HOW_TO.txt文件，裡面說了怎麼解壓和打補丁，並且還說了如何編譯。 #解压源码 $ tar - xvf tf - a - stm32mp - v2 . 8 . 6 - stm32mp - r1 - r0 . tar . xz #进入源码目录 $ cd tf - a - stm32mp - v2 . 8 . 6 - stm32mp - r1 / #打补丁 $ for p in ` ls - 1 .. /*.patch`; do patch -p1 < $p; done 解壓好源碼，我們在源碼目錄執行以下命令完成編譯。 DEPLOYDIR =$FIP_DEPLOYDIR_ROOT/arm-trusted-firmware是TF-A編譯結果存放的目錄，如果不設置就會在上一級產生deploy目錄存放編譯結果，同級目錄下生成的build目錄存放編譯中間文件。 #设置编译器 $ source / opt / st / stm32mp1 / 4.2 . 1 - openstlinux - 6.1 - yocto - mickledore - mp1 - v23 . 06.21 / environment - setup - cortexa7t2hf - neon - vfpv4 - ostl - linux - gnueabi #设置FIP目录 $ export FIP_DEPLOYDIR_ROOT =$ PWD /../../ FIP_artifacts #编译 $ make - f $ PWD /../ Makefile . sdk all 如果配置得當，會順利編譯完成，無報錯。 4.2 處理Makefile.sdk 備份 Makefile.sdk 以用於防止改錯和參考如何寫 $ cp -ivp Makefile.sdk Makefile.sdk.backup 然後用 VS Code 打開 Makefile.sdk 找到如下行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 …… TF_A_DEVICETREE_optee ?= stm32mp157c-ed1 stm32mp157f-ed1 stm32mp157a-ev1 stm32mp157c-ev1 stm32mp157d-ev1 stm32mp157f-ev1 stm32mp135f-dk stm32mp157a-dk1 stm32mp157d-dk1 stm32mp157c-dk2 stm32mp157f-dk2 …… TF_A_DEVICETREE_optee ?= stm32mp157c-ed1 stm32mp157f-ed1 stm32mp157a-ev1 stm32mp157c-ev1 stm32mp157d-ev1 stm32mp157f-ev1 stm32mp135f-dk stm32mp157a-dk1 stm32mp157d-dk1 stm32mp157c-dk2 stm32mp157f-dk2 …… TF_A_DEVICETREE_nand ?= stm32mp157a-ev1 stm32mp157c-ev1 stm32mp157d-ev1 stm32mp157f-ev1 …… TF_A_DEVICETREE_nor ?= stm32mp157a-ev1 stm32mp157c-ev1 stm32mp157d-ev1 stm32mp157f-ev1 …… TF_A_DEVICETREE_sdcard ?= stm32mp135f-dk stm32mp157a-dk1 stm32mp157d-dk1 stm32mp157c-dk2 stm32mp157f-dk2 stm32mp157c-ed1 stm32mp157f-ed1 stm32mp157a-ev1 stm32mp157c-ev1 stm32mp157d-ev1 stm32mp157f-ev1 …… TF_A_DEVICETREE_uart ?= stm32mp157c-ed1 stm32mp157f-ed1 stm32mp157a-ev1 stm32mp157c-ev1 stm32mp157d-ev1 stm32mp157f-ev1 stm32mp135f-dk stm32mp157a-dk1 stm32mp157d-dk1 stm32mp157c-dk2 stm32mp157f-dk2 …… TF_A_DEVICETREE_usb ?= stm32mp157c-ed1 stm32mp157f-ed1 stm32mp157a-ev1 stm32mp157c-ev1 stm32mp157d-ev1 stm32mp157f-ev1 stm32mp135f-dk stm32mp157a-dk1 stm32mp157d-dk1 stm32mp157c-dk2 stm32mp157f-dk2 …… # Define default make options 變更編譯器參數 EXTRA_OEMAKE ?= PLAT = stm32mp1 ARCH = aarch32 ARM_ARCH_MAJOR = 7 CROSS_COMPILE = arm-ostl-linux-gnueabi- DEBUG = 1 LOG_LEVEL = 40 …… 根據實際需要改成自己要用的，這個名稱要和後面的設備樹名稱對應，下面以後續要用的設備樹名 stm32mp157d-atk.dts 為例，并且編譯器參數保持默認。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 …… TF_A_DEVICETREE_optee ?= stm32mp157d-atk …… TF_A_DEVICETREE_emmc ?= stm32mp157d-atk …… TF_A_DEVICETREE_nand ?= stm32mp157d-atk …… TF_A_DEVICETREE_nor ?= stm32mp157d-atk …… TF_A_DEVICETREE_sdcard ?= stm32mp157d-atk …… TF_A_DEVICETREE_uart ?= stm32mp157d-atk …… TF_A_DEVICETREE_usb ?= stm32mp157d-atk …… # Define default make options 變更編譯器參數 EXTRA_OEMAKE ?= PLAT = stm32mp1 ARCH = aarch32 ARM_ARCH_MAJOR = 7 CROSS_COMPILE = arm-ostl-linux-gnueabi- DEBUG = 1 LOG_LEVEL = 40 …… 也可以根據實際需要去掉不需要編譯鏡像選項，後續我們將要使用的有 TF_A_DEVICETREE_optee , TF_A_DEVICETREE_emmc , TF_A_DEVICETREE_usb 這三個鏡像。 4.3 源碼移植 4.3.1 創建 stm32mp157d-atk.dts 相關文件 由於正點原子的 STM32MP157D 的開發板是基於 STM32MP157D - EV1 進行改板的，又由於 stm32mp157d-ev1.dts 中引用 stm32mp157d-ed1.dts 的文件，所以我們以 ed1 的文件為 stm32mp157d-atk.dts 基底，後續將 ev1 中的差別内容融合到 stm32mp157d-atk.dts 。 $ cd tf-a-stm32mp-v2.8.6-stm32mp-r1 \\f dts $ cp -ivp stm32mp157d-ed1.dts stm32mp157d-atk.dts 4.3.2 拼接设备树文件 stm32mp157d-ev1.dts 内容如下所示，需要將fmc節點以後代碼複製到 stm32mp157d-atk.dts 文件結尾。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 / { model = \"STMicroelectronics STM32MP157D eval daughter on eval mother\" ; compatible = \"st,stm32mp157d-ev1\" , \"st,stm32mp157d-ed1\" , \"st,stm32mp157\" ; chosen { stdout-path = \"serial0:115200n8\" ; }; aliases { serial1 = & usart3 ; }; }; & fmc { pinctrl-names = \"default\" ; pinctrl-0 = <& fmc_pins_a > ; status = \"okay\" ; nand-controller @ 4,0 { status = \"okay\" ; nand @ 0 { reg = < 0 > ; nand-on-flash-bbt ; #address-cells = < 1 > ; #size-cells = < 1 > ; }; }; }; & qspi { pinctrl-names = \"default\" ; pinctrl-0 = <& qspi_clk_pins_a & qspi_bk1_pins_a > ; reg = < 0x58003000 0x1000 > , < 0x70000000 0x4000000 > ; #address-cells = < 1 > ; #size-cells = < 0 > ; status = \"okay\" ; flash0 : mx66l51235l @ 0 { compatible = \"jedec,spi-nor\" ; reg = < 0 > ; spi-rx-bus-width = < 4 > ; spi-max-frequency = < 108000000 > ; #address-cells = < 1 > ; #size-cells = < 1 > ; }; }; & usart3 { pinctrl-names = \"default\" ; pinctrl-0 = <& usart3_pins_b > ; uart-has-rtscts ; status = \"disabled\" ; }; stm32mp157d-atk.dts 文件中起始節點融合為如下代碼： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 / { model = \"Alientek STM32MP157D daughter\" ; compatible = \"st,stm32mp157d-ev1\" , \"st,stm32mp157d-ed1\" , \"st,stm32mp157\" ; chosen { stdout-path = \"serial0:115200n8\" ; }; memory @ c0000000 { device_type = \"memory\" ; reg = < 0xC0000000 0x40000000 > ; }; aliases { serial0 = & uart4 ; serial1 = & usart3 ; }; } 4.3.3 修改电源设备树 在 stm32mp157d-atk.dts 文件中，刪除 i2c4 節點内的 pmic: stpmic@33 的子節點全部内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 & i2c4 { pinctrl-names = \"default\" ; pinctrl-0 = <& i2c4_pins_a > ; i2c-scl-rising-time-ns = < 185 > ; i2c-scl-falling-time-ns = < 20 > ; clock-frequency = < 400000 > ; status = \"okay\" ; /* 删除这部分注释代码 pmic: stpmic@33 { compatible = \"st,stpmic1\"; reg = <0x33>; interrupts-extended = <&exti_pwr 55 IRQ_TYPE_EDGE_FALLING>; interrupt-controller; #interrupt-cells = <2>; status = \"okay\"; regulators { // 此处代码已省略 }; }; */ }; /* 删除以下这些节点 &v1v2_hdmi { // 此处代码已省略 }; &v1v8_audio { // 此处代码已省略 }; &v3v3 { // 此处代码已省略 }; &v3v3_hdmi { // 此处代码已省略 }; &vdd { // 此处代码已省略 }; &vdda { // 此处代码已省略 }; &vddcore { // 此处代码已省略 }; &vdd_ddr { // 此处代码已省略 }; &vdd_usb { // 此处代码已省略 }; &vref_ddr { // 此处代码已省略 }; &vtt_ddr { // 此处代码已省略 }; */ 刪除后代碼如下所示： 1 2 3 4 5 6 7 8 & i2c4 { pinctrl-names = \"default\" ; pinctrl-0 = <& i2c4_pins_a > ; i2c-scl-rising-time-ns = < 185 > ; i2c-scl-falling-time-ns = < 20 > ; clock-frequency = < 400000 > ; status = \"okay\" ; }; 然後在起始節點中增加分立電源配置，代碼如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 / { model = \"Alientek STM32MP157D daughter\" ; compatible = \"st,stm32mp157d-ev1\" , \"st,stm32mp157d-ed1\" , \"st,stm32mp157\" ; chosen { stdout-path = \"serial0:115200n8\" ; }; memory @ c0000000 { device_type = \"memory\" ; reg = < 0xC0000000 0x40000000 > ; }; aliases { serial0 = & uart4 ; serial1 = & usart3 ; }; vin : vin { compatible = \"regulator-fixed\" ; regulator-name = \"vin\" ; regulator-min-microvolt = < 5000000 > ; regulator-max-microvolt = < 5000000 > ; regulator-always-on ; }; vddcore : regulator-vddcore { compatible = \"regulator-fixed\" ; regulator-name = \"vddcore\" ; regulator-min-microvolt = < 1200000 > ; regulator-max-microvolt = < 1350000 > ; regulator-off-in-suspend ; regulator-always-on ; }; v3v3 : regulator-3p3v { compatible = \"regulator-fixed\" ; regulator-name = \"v3v3\" ; regulator-min-microvolt = < 3300000 > ; regulator-max-microvolt = < 3300000 > ; regulator-off-in-suspend ; regulator-always-on ; }; vdd : regulator-vdd { compatible = \"regulator-fixed\" ; regulator-name = \"vdd\" ; regulator-min-microvolt = < 3300000 > ; regulator-max-microvolt = < 3300000 > ; regulator-off-in-suspend ; regulator-always-on ; }; vdd_usb : regulator-vdd-usb { compatible = \"regulator-fixed\" ; regulator-name = \"vdd_usb\" ; regulator-min-microvolt = < 3300000 > ; regulator-max-microvolt = < 3300000 > ; regulator-off-in-suspend ; regulator-always-on ; }; }; 最後需要在平臺配置文件 plat/st/stm32mp1/stm32mp1_def.h 中修改分立電源數量: 1 2 3 #define PLAT_NB_FIXED_REGS U(2) //改为 #define PLAT_NB_FIXED_REGS U(5) 4.3.4 修改EMMC设备树 這個部分沒有變化，完全參考《【正點原子】STM32MP1嵌入式Linux驅動開發指南V2.0》中操作即可，修改前的代碼如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 & sdmmc1 { pinctrl-names = \"default\" ; pinctrl-0 = <& sdmmc1_b4_pins_a & sdmmc1_dir_pins_a > ; disable-wp ; st , sig-dir ; st , neg-edge ; st , use-ckin ; bus-width = < 4 > ; vmmc-supply = <& vdd_sd > ; sd-uhs-sdr12 ; sd-uhs-sdr25 ; sd-uhs-sdr50 ; sd-uhs-ddr50 ; status = \"okay\" ; }; & sdmmc2 { pinctrl-names = \"default\" ; pinctrl-0 = <& sdmmc2_b4_pins_a & sdmmc2_d47_pins_a > ; non-removable ; no-sd ; no-sdio ; st , neg-edge ; bus-width = < 8 > ; vmmc-supply = <& v3v3 > ; vqmmc-supply = <& vdd > ; mmc-ddr-3_3v ; status = \"okay\" ; }; 修改后的代碼如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 & sdmmc1 { pinctrl-names = \"default\" ; pinctrl-0 = <& sdmmc1_b4_pins_a & sdmmc1_dir_pins_a > ; st , neg-edge ; broken-cd ; bus-width = < 4 > ; vmmc-supply = <& v3v3 > ; status = \"okay\" ; }; & sdmmc2 { pinctrl-names = \"default\" ; pinctrl-0 = <& sdmmc2_b4_pins_a & sdmmc2_d47_pins_a > ; non-removable ; st , neg-edge ; bus-width = < 8 > ; vmmc-supply = <& v3v3 > ; vqmmc-supply = <& v3v3 > ; status = \"okay\" ; }; 4.4 修改Flashlayout文件 由於正點原子的 STM32MP157D 的開發板是基於 STM32MP157D - EV1 進行改板的，所以在上述 Flashlayout 文件夾中找到 optee 文件夾中找到 \"FlashLayout_emmc_stm32mp157d-ev1-optee.tsv\" 複製到一個下載目錄中。 #Opt Id Name Type IP Offset Binary - 0x01 fsbl-boot Binary none 0x0 arm-trusted-firmware/tf-a-stm32mp157d-ev1-usb.stm32 - 0x03 fip-boot FIP none 0x0 fip/fip-stm32mp157d-ev1-optee.bin P 0x04 fsbl1 Binary mmc1 boot1 arm-trusted-firmware/tf-a-stm32mp157d-ev1-emmc.stm32 P 0x05 fsbl2 Binary mmc1 boot2 arm-trusted-firmware/tf-a-stm32mp157d-ev1-emmc.stm32 P 0x06 metadata1 FWU_MDATA mmc1 0x00080000 arm-trusted-firmware/metadata.bin P 0x07 metadata2 FWU_MDATA mmc1 0x00100000 arm-trusted-firmware/metadata.bin P 0x08 fip-a FIP mmc1 0x00180000 fip/fip-stm32mp157d-ev1-optee.bin PED 0x09 fip-b FIP mmc1 0x00580000 none PED 0x0A u-boot-env ENV mmc1 0x00980000 none P 0x10 bootfs System mmc1 0x00A00000 st-image-bootfs-openstlinux-weston-stm32mp1.ext4 P 0x11 vendorfs FileSystem mmc1 0x04A00000 st-image-vendorfs-openstlinux-weston-stm32mp1.ext4 P 0x12 rootfs FileSystem mmc1 0x05A00000 st-image-weston-openstlinux-weston-stm32mp1.ext4 P 0x13 userfs FileSystem mmc1 0xC5A00000 st-image-userfs-openstlinux-weston-stm32mp1.ext4 在測試TF-A的移植中我們只用第一行和第二行即可，即USB模擬串口的TF-A的固件下載到STM32MP157中即可測試。 4.5 編譯並下載測試 4.5.1 編譯 由於TF-A的SP-MIN是被TF-A的BL2加載併運行的，STM32MP157使用了FIP將BL32( SP - MIN )和BL33(U-Boot)打包在一起，我們需要復制一份U-Boot改成自己的開發闆。 #進入FIP目錄下的u-boot目錄 $ cd ../../FIP_artifacts/u-boot/ #複製U-boot $ cp u-boot-stm32mp157d-ev1.dtb u-boot-stm32mp157d-atk.dtb #返回TF-A源碼目錄 $ cd ../../tf-a-stm32mp-v2.8.6-stm32mp-r1-r0/tf-a-stm32mp-v2.8.6-stm32mp-r1/ #編譯 $ make -f $PWD/../Makefile.sdk all 編譯完成后會顯示如下結尾： [ fiptool ] Create fip - stm32mp157d - atk - optee . bin fip binary into 'FIP_DEPLOYDIR_FIP' folder ... [ fiptool ] Done 4.5.2 下載測試 flashlayout如下所示： #Opt Id Name Type IP Offset Binary - 0x01 fsbl-boot Binary none 0x0 arm-trusted-firmware/tf-a-stm32mp157d-atk-usb.stm32 - 0x03 fip-boot FIP none 0x0 fip/fip-stm32mp157d-atk-trusted.bin 如果不會編寫，請參考 STM32CubeProgrammer_flashlayout WIKI 。 用STM32CubeProg打開燒寫腳本，註意二進制文件把目錄設置對，設置好闆子併連接OTG和串口，點擊下載。板子一直重啟，那是因為U-boot不對。從串口打印信息上可以看到BL2把BL32( SP - MIN )啟動起來， SP -MIN正常運行，最終U-Boot啟動。 NOTICE : CPU : STM32MP157DAA Rev . Z < \\ r >< \\ n > NOTICE : Model : Alientek STM32MP157D daughter < \\ r >< \\ n > INFO : Reset reason ( 0x15 ): < \\ r >< \\ n > INFO : Power - on Reset ( rst_por ) < \\ r >< \\ n > INFO : FCONF : Reading TB_FW firmware configuration file from : 0x2ffe2000 < \\ r >< \\ n > INFO : FCONF : Reading firmware configuration information for : stm32mp_io < \\ r >< \\ n > INFO : Using USB < \\ r >< \\ n > INFO : Instance 2 < \\ r >< \\ n > INFO : Boot used partition fsbl1 < \\ r >< \\ n > NOTICE : BL2 : v2 . 8 - stm32mp1 - r1 . 0 ( debug ):() < \\ r >< \\ n > NOTICE : BL2 : Built : 14 : 09 : 42 , Jul 11 2023 < \\ r >< \\ n > INFO : BL2 : Doing platform setup < \\ r >< \\ n > INFO : RAM : DDR3 - DDR3L 32 bits 533000 kHz < \\ r >< \\ n > INFO : Memory size = 0x40000000 ( 1024 MB ) < \\ r >< \\ n > INFO : DFU USB START ...< \\ r >< \\ n > INFO : phase ID : 3 , Manifestation 3 at c714d1fa < \\ r >< \\ n > INFO : Send detach request < \\ r >< \\ n > INFO : Receive DFU Detach < \\ r >< \\ n > INFO : DFU USB STOP ...< \\ r >< \\ n > INFO : BL2 : Loading image id 1 < \\ r >< \\ n > INFO : Loading image id = 1 at address 0x2ffff000 < \\ r >< \\ n > INFO : Image id = 1 loaded : 0x2ffff000 - 0x2ffff1ea < \\ r >< \\ n > INFO : FCONF : Reading FW_CONFIG firmware configuration file from : 0x2ffff000 < \\ r >< \\ n > INFO : FCONF : Reading firmware configuration information for : dyn_cfg < \\ r >< \\ n > INFO : FCONF : Reading firmware configuration information for : stm32mp1_firewall < \\ r >< \\ n > INFO : BL2 : Loading image id 4 < \\ r >< \\ n > INFO : Loading image id = 4 at address 0xfe000000 < \\ r >< \\ n > INFO : Image id = 4 loaded : 0xfe000000 - 0xfe00001c < \\ r >< \\ n > INFO : OPTEE ep = 0xfe000000 < \\ r >< \\ n > INFO : OPTEE header info : < \\ r >< \\ n > INFO : magic = 0x4554504f < \\ r >< \\ n > INFO : version = 0x2 < \\ r >< \\ n > INFO : arch = 0x0 < \\ r >< \\ n > INFO : flags = 0x0 < \\ r >< \\ n > INFO : nb_images = 0x1 < \\ r >< \\ n > INFO : BL2 : Loading image id 8 < \\ r >< \\ n > INFO : Loading image id = 8 at address 0xfe000000 < \\ r >< \\ n > INFO : Image id = 8 loaded : 0xfe000000 - 0xfe035b68 < \\ r >< \\ n > INFO : BL2 : Skip loading image id 9 < \\ r >< \\ n > INFO : BL2 : Loading image id 2 < \\ r >< \\ n > INFO : Loading image id = 2 at address 0xc0500000 < \\ r >< \\ n > INFO : Image id = 2 loaded : 0xc0500000 - 0xc0521628 < \\ r >< \\ n > INFO : BL2 : Skip loading image id 16 < \\ r >< \\ n > INFO : BL2 : Loading image id 5 < \\ r >< \\ n > INFO : Loading image id = 5 at address 0xc0100000 < \\ r >< \\ n > INFO : Image id = 5 loaded : 0xc0100000 - 0xc01f5d3c < \\ r >< \\ n > NOTICE : BL2 : Booting BL32 < \\ r >< \\ n > INFO : Entry point address = 0xfe000000 < \\ r >< \\ n > INFO : SPSR = 0x1d3 < \\ r >< \\ n > I / TC : Early console on UART #4<\\r><\\n> I / TC : < \\ r >< \\ n > I / TC : Embedded DTB found < \\ r >< \\ n > I / TC : OP - TEE version : 3.19 . 0 - dev ( gcc version 12.2 . 0 ( GCC )) #1 Fri Oct 14 19:00:05 UTC 2022 arm<\\r><\\n> I / TC : WARNING : This OP - TEE configuration might be insecure !< \\ r >< \\ n > I / TC : WARNING : Please check https : // optee . readthedocs . io / en / latest / architecture / porting_guidelines . html < \\ r >< \\ n > I / TC : Primary CPU initializing < \\ r >< \\ n > E / TC : 0 0 Panic < \\ r >< \\ n > 10 结语 關於具體的流程及操作，我在這裡就不多做敘述了，官方文檔和正點原子的手冊中說的已經非常清楚。本次移植過程也是個人摸索得出的，如果有不盡完善的地方，歡迎您提出，我進行驗證更正。","tags":"STM32MP157DAA1","url":"/STM32MP157DAA1/Porting_v23.06.21_to_ALIENTEK_STM32MP157D.html"},{"title":"简单移植IAP（ STSW - STM32067 ）到STM32F411VET6","text":"首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我们在移植IAP的过程中主要用到以下三个东西，一个是STM32F411VET6的开发板，一个是待移植的官方的STM32F4- IAP -USART程序，最后一个就是上位机（支持ymodem），这里最好选用官方建议使用的超级终端（Hypertrm）进行测试。 32F411EDISCOVERY STM32F4 IAP using the USART ( AN3965 ) Hypertrm 二、修改串口通讯接口 由于STM32F411VET6中没有USART3，我需要将USART3的配置修改为USART2。这个里面我个人建议修改为与USART3在同一总线上的USART，否则需要进行大量的代码修改。由于我只是进行工程远程调试，暂时不考虑大费周章进行移植和修改，如果后续需要使用，可能会做基于HAL的移植，并对读取Flash的权限做出详细的限制。 下面我们就开始正式的移植过程，我们需要修改工程中的 stm324xg_eval.h 文件中关于USART的宏定义部分。 原始宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART3 */ #define EVAL_COM1 USART3 #define EVAL_COM1_CLK RCC_APB1Periph_USART3 #define EVAL_COM1_TX_PIN GPIO_Pin_10 #define EVAL_COM1_TX_GPIO_PORT GPIOC #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_TX_SOURCE GPIO_PinSource10 #define EVAL_COM1_TX_AF GPIO_AF_USART3 #define EVAL_COM1_RX_PIN GPIO_Pin_11 #define EVAL_COM1_RX_GPIO_PORT GPIOC #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_RX_SOURCE GPIO_PinSource11 #define EVAL_COM1_RX_AF GPIO_AF_USART3 #define EVAL_COM1_IRQn USART3_IRQn 修改后宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART2 */ #define EVAL_COM1 USART2 #define EVAL_COM1_CLK RCC_APB1Periph_USART2 #define EVAL_COM1_TX_PIN GPIO_Pin_2 #define EVAL_COM1_TX_GPIO_PORT GPIOA #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_TX_SOURCE GPIO_PinSource2 #define EVAL_COM1_TX_AF GPIO_AF_USART2 #define EVAL_COM1_RX_PIN GPIO_Pin_3 #define EVAL_COM1_RX_GPIO_PORT GPIOA #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_RX_SOURCE GPIO_PinSource3 #define EVAL_COM1_RX_AF GPIO_AF_USART2 #define EVAL_COM1_IRQn USART2_IRQn P.S. 注意您选择USART2的管脚分配，我这里分配的GPIOA2（ TX ）和GPIOA3（ RX ）。 三、修改Flash大小定义 由于STM32F411VET6和STM32F407系列的Flash大小不一致，故需要简单修改下Flash的相关函数和定义。 首先，我们需要修改 flash_if.c 中 uint32_t FLASH_If_Erase 的函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_11 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 需要将 FLASH_Sector_11 修改为 FLASH_Sector_7 ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_7 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 其次我们需要修改 flash_if.c 中的 static uint32_t GetSector 函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else if (( Address < ADDR_FLASH_SECTOR_8 ) && ( Address >= ADDR_FLASH_SECTOR_7 )) { sector = FLASH_Sector_7 ; } else if (( Address < ADDR_FLASH_SECTOR_9 ) && ( Address >= ADDR_FLASH_SECTOR_8 )) { sector = FLASH_Sector_8 ; } else if (( Address < ADDR_FLASH_SECTOR_10 ) && ( Address >= ADDR_FLASH_SECTOR_9 )) { sector = FLASH_Sector_9 ; } else if (( Address < ADDR_FLASH_SECTOR_11 ) && ( Address >= ADDR_FLASH_SECTOR_10 )) { sector = FLASH_Sector_10 ; } else /*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_11))*/ { sector = FLASH_Sector_11 ; } return sector ; } 根据实际情况适当增删 FLASH_Sector ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else { sector = FLASH_Sector_7 ; } return sector ; } 四、修改Main函数 在移植过程中根据您的需要，修改Main函数，下面放上原Main函数和我个人根据 32F411EDISCOVERY 修改后的Main函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is pressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } /* Keep the user application running */ else { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } while ( 1 ) {} } 根据 32F411EDISCOVERY 修改后的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is unpressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } /* Keep the user application running */ else { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } while ( 1 ) { ; } } 五、修改IAP_Init函数 根据您的实际情况修改 IAP_Init 函数中的参数。 原函数代码如下： /** * @ brief Initialize the IAP : Configure USART . * @ param None * @ retval None */ void IAP_Init ( void ) { USART_InitTypeDef USART_InitStructure ; /* USART resources configuration ( Clock , GPIO pins and USART registers ) ----*/ /* USART configured as follow : - BaudRate = 115200 baud - Word Length = 8 Bits - One Stop Bit - No parity - Hardware flow control disabled ( RTS and CTS signals ) - Receive and transmit enabled */ USART_InitStructure . USART_BaudRate = 115200 ; // 串口波特率 USART_InitStructure . USART_WordLength = USART_WordLength_8b ; USART_InitStructure . USART_StopBits = USART_StopBits_1 ; USART_InitStructure . USART_Parity = USART_Parity_No ; USART_InitStructure . USART_HardwareFlowControl = USART_HardwareFlowControl_None ; USART_InitStructure . USART_Mode = USART_Mode_Rx | USART_Mode_Tx ; STM_EVAL_COMInit ( COM1 , & USART_InitStructure ); } 六、结语 关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。 后续，如果我在工作之余或者工作中有需要，我可能会将IAP的代码移植到HAL库上，如果您已经做了相关工作，希望您可以在不涉及保密条款和其他利益的情况下，抄送一份给我，用于后续研究与参考。谢谢！","tags":"STM32F411VET6","url":"/STM32F411VET6/Simple_transplant_IAP_STSW-STM32067_to_STM32F411VET6.html"},{"title":"Windows 8.1 Update 系统迁移","text":"上周的周末，新买的SSD硬盘到了，需要把旧系统盘的数据迁移至新的SSD上，最开始考虑了Winodws系统映像的方法进行迁移，但通过恢复U盘进入到恢复步骤时，总是提示我无法格式化硬盘，所以放弃了这个方案。 在查询无数资料后，考虑到Win 8.1 Update的组成，突然灵光一现，尝试用Win 8.1的系统盘格式化新的SSD，从而使新的磁盘系统分区和原来的保持一致，通过备份分区数据，还原分区数据的方式，完成系统迁移。 本文就是就是记录下这个操作流程，以备后人参考，如果您有更好的方法，请您不吝赐教，谢谢！ 废话也说完了，我们下面进入到正题。 一、准备工具 天意u盘维护系统技术员版3.0 UltraISO cn_windows_8.1_with_update_x64_dvd_6051473.iso cn_windows_8.1_with_update_x86_dvd_6051523.iso Windows 8 USB Installer Maker DiskGenius v4.7.1 免费版 16G U盘 可量产 如果遇到上述链接无法访问，请您自行想办法。 友情提示：中国拥有世界上第八大奇迹——长城。 二、制作Winodws 8.1 Upadate U盘安装盘 这个大家应该已经很熟悉了吧！用我提供的Windows 8 USB Installer Maker工具，基本制作过程是傻瓜式安装。 三、安装Winodws 8.1 Upadate到新系统盘 这步我也就简单说下，基本上都会做，说一下几个需要注意的地方。 1、重启进入Bios把安全启动关闭，以免后续从PE、U盘安装盘启动不了。 2、一定保证新盘的分区方式和旧盘一样，我一般采用的系统盘自动分区。 3、进入不进入系统都可以，等会儿都要覆盖的。 四、安装天意U盘PE 这步在天意大大贴子中已经写的很清楚了，我就不重复给出制作U盘PE的教程了。这里仅给出一个UltraISO可用的用户名和注册码。 用户名：王涛 注册码：7C81-1689-4046-626F 五、备份旧系统盘数据 1、如下图所示，进入到天意PE中，打开DiskGenius。 2、选中原系统分区，单机鼠标右键，可以看到备份分区到镜像文件，点击它。 在这里您需要注意查看下旧系统分区的数据量是否远小于新系统盘的分区大小。 3、选择文件路径，并点击开始，就可以开始备份了。 六、还原旧系统盘数据到新系统盘 1、选中新系统分区，单机鼠标右键，可以看到从镜像文件还原分区，点击它。 2、选择刚刚备份的文件，并点击开始，进行系统迁移。 七、重新设置引导参数 1、在天意PE中默认没有给引导分区指派盘符，所以我们需要找到系统的引导分区，单机鼠标右键，可以指派新的驱动器号，点击它。 2、选择您想要赋予的盘符，选择它，记住它，并单击确定。 3、打开开始菜单，找到BIOS+UEFI引导修复工具，打开它。 4、按照提示填写Windows系统分区盘符，引导分区盘符，并按下回车，确认信息后，再次按下回车。 5、出现上图最后一行的提示，您可以关闭程序，并重启电脑。 八、结语 以上就是我此次系统迁移的基本过程，如果您有没看懂的地方，您可以留言，我看到后会及时回复。 P.S. 天意大大说我提供这个版本PE中DiskGenius有一些问题，但是在操作过程中我没有遇到，如果您遇到了，可以用DiskGenius的原版（在第一章节中有提供下载地址）尝试下。","tags":"Windows","url":"/Windows/Win8-1-Update-System-Migration.html"}]}