{"pages":[{"text":"首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我们在移植IAP的过程中主要用到以下三个东西，一个是STM32F411VET6的开发板，一个是待移植的官方的STM32F4-IAP-USART程序，最后一个就是上位机（支持ymodem），这里最好选用官方建议使用的超级终端（Hypertrm）进行测试。 32F411EDISCOVERY STM32F4 IAP using the USART (AN3965) Hypertrm 二、修改串口通讯接口 由于STM32F411VET6中没有USART3，我需要将USART3的配置修改为USART2。这个里面我个人建议修改为与USART3在同一总线上的USART，否则需要进行大量的代码修改。由于我只是进行工程远程调试，暂时不考虑大费周章进行移植和修改，如果后续需要使用，可能会做基于HAL的移植，并对读取Flash的权限做出详细的限制。 下面我们就开始正式的移植过程，我们需要修改工程中的 stm324xg_eval.h 文件中关于USART的宏定义部分。 原始宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART3 */ #define EVAL_COM1 USART3 #define EVAL_COM1_CLK RCC_APB1Periph_USART3 #define EVAL_COM1_TX_PIN GPIO_Pin_10 #define EVAL_COM1_TX_GPIO_PORT GPIOC #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_TX_SOURCE GPIO_PinSource10 #define EVAL_COM1_TX_AF GPIO_AF_USART3 #define EVAL_COM1_RX_PIN GPIO_Pin_11 #define EVAL_COM1_RX_GPIO_PORT GPIOC #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_RX_SOURCE GPIO_PinSource11 #define EVAL_COM1_RX_AF GPIO_AF_USART3 #define EVAL_COM1_IRQn USART3_IRQn 修改后宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART2 */ #define EVAL_COM1 USART2 #define EVAL_COM1_CLK RCC_APB1Periph_USART2 #define EVAL_COM1_TX_PIN GPIO_Pin_2 #define EVAL_COM1_TX_GPIO_PORT GPIOA #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_TX_SOURCE GPIO_PinSource2 #define EVAL_COM1_TX_AF GPIO_AF_USART2 #define EVAL_COM1_RX_PIN GPIO_Pin_3 #define EVAL_COM1_RX_GPIO_PORT GPIOA #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_RX_SOURCE GPIO_PinSource3 #define EVAL_COM1_RX_AF GPIO_AF_USART2 #define EVAL_COM1_IRQn USART2_IRQn P.S.注意您选择USART2的管脚分配，我这里分配的GPIOA2（TX）和GPIOA3（RX）。 三、修改Flash大小定义 由于STM32F411VET6和STM32F407系列的Flash大小不一致，故需要简单修改下Flash的相关函数和定义。 首先，我们需要修改 flash_if.c 中 uint32_t FLASH_If_Erase 的函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_11 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 需要将 FLASH_Sector_11 修改为 FLASH_Sector_7 ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_7 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 其次我们需要修改 flash_if.c 中的 static uint32_t GetSector 函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else if (( Address < ADDR_FLASH_SECTOR_8 ) && ( Address >= ADDR_FLASH_SECTOR_7 )) { sector = FLASH_Sector_7 ; } else if (( Address < ADDR_FLASH_SECTOR_9 ) && ( Address >= ADDR_FLASH_SECTOR_8 )) { sector = FLASH_Sector_8 ; } else if (( Address < ADDR_FLASH_SECTOR_10 ) && ( Address >= ADDR_FLASH_SECTOR_9 )) { sector = FLASH_Sector_9 ; } else if (( Address < ADDR_FLASH_SECTOR_11 ) && ( Address >= ADDR_FLASH_SECTOR_10 )) { sector = FLASH_Sector_10 ; } else /*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_11))*/ { sector = FLASH_Sector_11 ; } return sector ; } 根据实际情况适当增删 FLASH_Sector ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else { sector = FLASH_Sector_7 ; } return sector ; } 四、修改Main函数 在移植过程中根据您的需要，修改Main函数，下面放上原Main函数和我个人根据 32F411EDISCOVERY 修改后的Main函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is pressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } /* Keep the user application running */ else { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } while ( 1 ) {} } 根据 32F411EDISCOVERY 修改后的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is unpressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } /* Keep the user application running */ else { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } while ( 1 ) { ; } } 五、修改IAP_Init函数 根据您的实际情况修改 IAP_Init 函数中的参数。 原函数代码如下： /** * @brief Initialize the IAP: Configure USART. * @param None * @retval None */ void IAP_Init ( void ) { USART_InitTypeDef USART_InitStructure ; /* USART resources configuration (Clock, GPIO pins and USART registers) ----*/ /* USART configured as follow: - BaudRate = 115200 baud - Word Length = 8 Bits - One Stop Bit - No parity - Hardware flow control disabled (RTS and CTS signals) - Receive and transmit enabled */ USART_InitStructure . USART_BaudRate = 115200 ; // 串口波特率 USART_InitStructure . USART_WordLength = USART_WordLength_8b ; USART_InitStructure . USART_StopBits = USART_StopBits_1 ; USART_InitStructure . USART_Parity = USART_Parity_No ; USART_InitStructure . USART_HardwareFlowControl = USART_HardwareFlowControl_None ; USART_InitStructure . USART_Mode = USART_Mode_Rx | USART_Mode_Tx ; STM_EVAL_COMInit ( COM1 , & USART_InitStructure ) ; } 六、结语 关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。 后续，如果我在工作之余或者工作中有需要，我可能会将IAP的代码移植到HAL库上，如果您已经做了相关工作，希望您可以在不涉及保密条款和其他利益的情况下，抄送一份给我，用于后续研究与参考。谢谢！","tags":"STM32F411VET6","loc":"http://dhlx.wang/Simple_transplant_IAP_STSW-STM32067_to_STM32F411VET6.html","title":"简单移植IAP（STSW-STM32067）到STM32F411VET6"},{"text":"上周的周末，新买的SSD硬盘到了，需要把旧系统盘的数据迁移至新的SSD上，最开始考虑了Winodws系统映像的方法进行迁移，但通过恢复U盘进入到恢复步骤时，总是提示我无法格式化硬盘，所以放弃了这个方案。 在查询无数资料后，考虑到Win 8.1 Update的组成，突然灵光一现，尝试用Win 8.1的系统盘格式化新的SSD，从而使新的磁盘系统分区和原来的保持一致，通过备份分区数据，还原分区数据的方式，完成系统迁移。 本文就是就是记录下这个操作流程，以备后人参考，如果您有更好的方法，请您不吝赐教，谢谢！ 废话也说完了，我们下面进入到正题。 一、准备工具 天意u盘维护系统技术员版3.0 UltraISO cn_windows_8.1_with_update_x64_dvd_6051473.iso cn_windows_8.1_with_update_x86_dvd_6051523.iso Windows 8 USB Installer Maker DiskGenius v4.7.1 免费版 16G U盘 可量产 如果遇到上述链接无法访问，请您自行想办法。 友情提示：中国拥有世界八大奇迹——长城。 二、制作Winodws 8.1 Upadate U盘安装盘 这个大家应该已经很熟悉了吧！用我提供的Windows 8 USB Installer Maker工具，基本制作过程是傻瓜式安装。 三、安装Winodws 8.1 Upadate到新系统盘 这步我也就简单说下，基本上都会做，说一下几个需要注意的地方。 1、重启进入Bios把安全启动关闭，以免后续从PE、U盘安装盘启动不了。 2、一定保证新盘的分区方式和旧盘一样，我一般采用的系统盘自动分区。 3、进入不进入系统都可以，等会儿都要覆盖的。 四、安装天意U盘PE 这步在天意大大贴子中已经写的很清楚了，我就不重复给出制作U盘PE的教程了。这里仅给出一个UltraISO可用的用户名和注册码。 用户名：王涛 注册码：7C81-1689-4046-626F 五、备份旧系统盘数据 1、如下图所示，进入到天意PE中，打开DiskGenius。 2、选中原系统分区，单机鼠标右键，可以看到备份分区到镜像文件，点击它。 在这里您需要注意查看下旧系统分区的数据量是否远小于新系统盘的分区大小。 3、选择文件路径，并点击开始，就可以开始备份了。 六、还原旧系统盘数据到新系统盘 1、选中新系统分区，单机鼠标右键，可以看到从镜像文件还原分区，点击它。 2、选择刚刚备份的文件，并点击开始，进行系统迁移。 七、重新设置引导参数 1、在天意PE中默认没有给引导分区指派盘符，所以我们需要找到系统的引导分区，单机鼠标右键，可以指派新的驱动器号，点击它。 2、选择您想要赋予的盘符，选择它，记住它，并单击确定。 3、打开开始菜单，找到BIOS+UEFI引导修复工具，打开它。 4、按照提示填写Windows系统分区盘符，引导分区盘符，并按下回车，确认信息后，再次按下回车。 5、出现上图最后一行的提示，您可以关闭程序，并重启电脑。 八、结语 以上就是我此次系统迁移的基本过程，如果您有没看懂的地方，您可以留言，我看到后会及时回复。 P.S. 天意大大说我提供这个版本PE中DiskGenius有一些问题，但是在操作过程中我没有遇到，如果您遇到了，可以用DiskGenius的原版（在第一章节中有提供下载地址）尝试下。","tags":"Windows","loc":"http://dhlx.wang/Win8-1-Update-System-Migration.html","title":"Windows 8.1 Update 系统迁移"}]}