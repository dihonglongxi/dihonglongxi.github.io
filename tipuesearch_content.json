{"pages":[{"text":"首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我们在移植AN4657到STM32F411VET6的过程中主要用到以下程序和工具： 32F411EDISCOVERY X-CUBE-IAP-USART(AN4657) Hypertrm STM32CubeMX_V4.8.0 STM32Cube_FW_F4_V1.6.0 Keil_MDK_ARM_V5.15.0 AN4657-STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Inc AN4657-STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Src 二、拷贝需要的文件到工程目录下 1、解压缩通过下载得到的AN4657压缩包。 2、拷贝路径（AN4657-STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Inc）中的 common.h 、 flash_if.h 、 menu.h 、 ymodem.h 到我们自己的工程路径下的Inc文件夹中。 3、拷贝路径（AN4657-STM32Cube_IAP_using_UART\\Projects\\STM3210C_EVAL\\IAP_Main\\Src）中的 common.c 、 flash_if.c 、 menu.c 、 ymodem.c 到我们自己的工程路径下的Src文件夹中，并在keil中添加相应的文件。 三、修改串口的基本设置 串口的基本设置在STM32Cube可以进行设置，并生成相应的设置代码，但在我们的移植文件中需要用到串口设置，故我们需要在 common.c 、 menu.c 、 ymodem.c 三个文件中进行修改，我的示例代码是用USART1作为演示。 common.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** @addtogroup STM32F4xx_IAP_Main * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"common.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ /* Private function prototypes ------------------------------------------*/ /* Private functions ----------------------------------------------------*/ menu.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"common.h\" #include \"flash_if.h\" #include \"menu.h\" #include \"ymodem.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ ymodem.c 修改部分如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ //根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和 //usart.h的引用。 #include \"flash_if.h\" #include \"common.h\" #include \"ymodem.h\" #include \"string.h\" #include \"menu.h\" #include \"stm32f4xx_hal.h\" #include \"usart.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ //为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置 //文件 #ifndef UartHandle #define UartHandle huart1 #endif #define CRC16_F /* activate the CRC16 integrity */ /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ P.S. 1、 common.h 、 menu.h 、 ymodem.h 基本不需要任何修改，直接就可以用。 2、如果使用 32F411EDISCOVERY ，请您注意不要使用默认的USART1的IO设置，需要更改为 PB6、PB7，才可以正常使用，默认的TX引脚上接了一个uF级的电容，我因为这个事情调试了很长时间。 三、修改FLASH操作函数及其定义 在整个移植过程中，重头戏就是对 flash_if.h 和 flash_if.c 的移植，里面涉及到很多 处修改，大部分修改是因为M4系列的MCU对FLASH的操作，没有页（Page）的概念，只有扇区（Sector）的操作函数造成的。 所以，综上所述需要先将各种Page（PAGE、page）换成Sector，这样基本上可以解决掉一批错误。 flash_if.h 修改后如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 /* Define to prevent recursive inclusion --------------------------------*/ #ifndef __FLASH_IF_H #define __FLASH_IF_H /* Includes -------------------------------------------------------------*/ //修改引用的头文件为F4的 #include \"stm32f4xx_hal.h\" /* Exported types -------------------------------------------------------*/ /* Exported constants ---------------------------------------------------*/ /* Base address of the Flash sectors */ //定义扇区名和地址之间的关系，方便根据地址获取扇区的编号 #define ADDR_FLASH_SECTOR_0 ((uint32_t)0x08000000) /* Base @ of Sector 0, 16 Kbyte */ #define ADDR_FLASH_SECTOR_1 ((uint32_t)0x08004000) /* Base @ of Sector 1, 16 Kbyte */ #define ADDR_FLASH_SECTOR_2 ((uint32_t)0x08008000) /* Base @ of Sector 2, 16 Kbyte */ #define ADDR_FLASH_SECTOR_3 ((uint32_t)0x0800C000) /* Base @ of Sector 3, 16 Kbyte */ #define ADDR_FLASH_SECTOR_4 ((uint32_t)0x08010000) /* Base @ of Sector 4, 64 Kbyte */ #define ADDR_FLASH_SECTOR_5 ((uint32_t)0x08020000) /* Base @ of Sector 5, 128 Kbyte */ #define ADDR_FLASH_SECTOR_6 ((uint32_t)0x08040000) /* Base @ of Sector 6, 128 Kbyte */ #define ADDR_FLASH_SECTOR_7 ((uint32_t)0x08060000) /* Base @ of Sector 7, 128 Kbyte */ /* Error code */ enum { FLASHIF_OK = 0 , FLASHIF_ERASEKO , FLASHIF_WRITINGCTRL_ERROR , FLASHIF_WRITING_ERROR , FLASHIF_PROTECTION_ERRROR }; /* protection type */ enum { FLASHIF_PROTECTION_NONE = 0 , FLASHIF_PROTECTION_PCROPENABLED = 0x1 , FLASHIF_PROTECTION_WRPENABLED = 0x2 , FLASHIF_PROTECTION_RDPENABLED = 0x4 , }; /* protection update */ enum { FLASHIF_WRP_ENABLE , FLASHIF_WRP_DISABLE }; /* Define the address from where user application will be loaded. Note: the 1st sector 0x08000000-0x08003FFF is reserved for the IAP code */ //根据实际的片内Flash大小修改结束地址，并删除不用的宏定义 #define APPLICATION_ADDRESS (uint32_t)0x08004000 /* Start user code address */ /* Notable Flash addresses */ #define USER_FLASH_END_ADDRESS (uint32_t)0x0807FFFF /* Define the user application size */ #define USER_FLASH_SIZE (USER_FLASH_END_ADDRESS - APPLICATION_ADDRESS + 1) /* Small default template application */ /* Exported macro -------------------------------------------------------*/ /* ABSoulute value */ #define ABS_RETURN(x,y) ((x) < (y)) ? ((y)-(x)) : ((x)-(y)) /* Get the number of sectors from where the user program will be loaded */ #define FLASH_SECTOR_NUMBER ((uint32_t)(ABS_RETURN(APPLICATION_ADDRESS,FLASH_START_BANK1))>>12) /* Compute the mask to test if the Flash memory, where the user program will be loaded, is write protected */ #define FLASH_PROTECTED_SECTORS (~(uint32_t)((1 << FLASH_SECTOR_NUMBER) - 1)) /* Exported functions --------------------------------------------------*/ void FLASH_If_Init ( void ); uint32_t FLASH_If_Erase ( uint32_t StartSector ); uint32_t FLASH_If_GetWriteProtectionStatus ( void ); uint32_t FLASH_If_Write ( uint32_t destination , uint32_t * p_source , uint32_t length ); uint32_t FLASH_If_WriteProtectionConfig ( uint32_t modifier ); #endif /* __FLASH_IF_H */ /******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ flash_if.c 修改后如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 /** @addtogroup STM32F4xx_IAP * @{ */ /* Includes -------------------------------------------------------------*/ #include \"flash_if.h\" /* Private typedef ------------------------------------------------------*/ /* Private define -------------------------------------------------------*/ /* Private macro --------------------------------------------------------*/ /* Private variables ----------------------------------------------------*/ /* Private function prototypes ------------------------------------------*/ //增加获取扇区的函数，方便获取扇区编号 static uint32_t GetSector ( uint32_t Address ); /* Private functions ----------------------------------------------------*/ /** * @brief Unlocks Flash for write access * @param None * @retval None */ void FLASH_If_Init ( void ) { /* Unlock the Program memory */ HAL_FLASH_Unlock (); /* Clear all FLASH flags */ //根据实际的MCU清除FLASH标志位 __HAL_FLASH_CLEAR_FLAG ( FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR ); /* Unlock the Program memory */ HAL_FLASH_Lock (); } /** * @brief This function does an erase of all user flash area * @param start: start of user flash area * @retval FLASHIF_OK : user flash area successfully erased * FLASHIF_ERASEKO : error occurred */ uint32_t FLASH_If_Erase ( uint32_t start ) { //将相关的Page参数均修改为M4的Sector 参数 uint32_t UserStartSector = FLASH_SECTOR_1 ; uint32_t NbrOfSector = 0 ; uint32_t SectorError = 0 ; FLASH_EraseInitTypeDef pEraseInit ; HAL_StatusTypeDef status = HAL_OK ; /* Unlock the Flash to enable the flash control register access *************/ HAL_FLASH_Unlock (); /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); NbrOfSector = FLASH_SECTOR_7 - UserStartSector ; pEraseInit . TypeErase = FLASH_TYPEERASE_SECTORS ; pEraseInit . Sector = UserStartSector ; pEraseInit . Banks = FLASH_BANK_1 ; pEraseInit . NbSectors = NbrOfSector ; pEraseInit . VoltageRange = FLASH_VOLTAGE_RANGE_3 ; status = HAL_FLASHEx_Erase ( & pEraseInit , & SectorError ); /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); if ( status != HAL_OK ) { /* Error occurred while Sector erase */ return FLASHIF_ERASEKO ; } return FLASHIF_OK ; } /* Public functions -----------------------------------------------------*/ /** * @brief This function writes a data buffer in flash (data are 32-bit aligned). * @note After writing data buffer, the flash content is checked. * @param destination: start address for target location * @param p_source: pointer on buffer with data to write * @param length: length of data buffer (unit is 32-bit word) * @retval uint32_t 0: Data successfully written to Flash memory * 1: Error occurred while writing data in Flash memory * 2: Written Data in flash memory is different from expected one */ uint32_t FLASH_If_Write ( uint32_t destination , uint32_t * p_source , uint32_t length ) { uint32_t i = 0 ; /* Unlock the Flash to enable the flash control register access *************/ HAL_FLASH_Unlock (); for ( i = 0 ; ( i < length ) && ( destination <= ( USER_FLASH_END_ADDRESS - 4 )); i ++ ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( HAL_FLASH_Program ( FLASH_TYPEPROGRAM_WORD , destination , * ( uint32_t * )( p_source + i )) == HAL_OK ) { /* Check the written value */ if ( * ( uint32_t * ) destination != * ( uint32_t * )( p_source + i )) { /* Flash content doesn't match SRAM content */ return ( FLASHIF_WRITINGCTRL_ERROR ); } /* Increment FLASH destination address */ destination += 4 ; } else { /* Error occurred while writing data in Flash memory */ return ( FLASHIF_WRITING_ERROR ); } } /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); return ( FLASHIF_OK ); } /** * @brief Returns the write protection status of application flash area. * @param None * @retval If a sector in application area is write-protected returned value is a combinaison of the possible values : FLASHIF_PROTECTION_WRPENABLED, FLASHIF_PROTECTION_PCROPENABLED, ... * If no sector is write-protected FLASHIF_PROTECTION_NONE is returned. */ uint32_t FLASH_If_GetWriteProtectionStatus ( void ) { uint32_t ProtectedSector = FLASHIF_PROTECTION_NONE ; FLASH_OBProgramInitTypeDef OptionsBytesStruct ; /* Unlock the Flash to enable the flash control register access ********/ HAL_FLASH_Unlock (); /*Check if there are write protected sectors inside the user flash area*/ HAL_FLASHEx_OBGetConfig ( & OptionsBytesStruct ); /* Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation) *********/ HAL_FLASH_Lock (); /* Get Sectors already write protected *********************************/ //后面的保护区域，没有看懂，所以直接屏蔽掉了 ProtectedSector = ~ OptionsBytesStruct . WRPSector ; /* Check if desired Sectors are already write protected ****************/ if ( ProtectedSector != 0 ) { /* Some sectors inside the user flash area are write protected */ return FLASHIF_PROTECTION_WRPENABLED ; } else { /* No write protected sectors inside the user flash area */ return FLASHIF_PROTECTION_NONE ; } } /** * @brief Configure the write protection status of user flash area. * @param protectionstate : FLASHIF_WRP_DISABLE or FLASHIF_WRP_ENABLE the protection * @retval uint32_t FLASHIF_OK if change is applied. */ uint32_t FLASH_If_WriteProtectionConfig ( uint32_t protectionstate ) { uint32_t ProtectedSector = 0x0 ; FLASH_OBProgramInitTypeDef config_new , config_old ; HAL_StatusTypeDef result = HAL_OK ; /* Get Sectors write protection status *********************************/ HAL_FLASHEx_OBGetConfig ( & config_old ); /* The parameter says whether we turn the protection on or off */ config_new . WRPState = ( protectionstate == FLASHIF_WRP_ENABLE ? OB_WRPSTATE_ENABLE : OB_WRPSTATE_DISABLE ); /* We want to modify only the Write protection */ config_new . OptionType = OPTIONBYTE_WRP ; /* No read protection, keep BOR and reset settings */ config_new . RDPLevel = OB_RDP_LEVEL_0 ; config_new . USERConfig = config_old . USERConfig ; /* Get Sectors already write protected *********************************/ //后面的保护区域，没有看懂，所以直接屏蔽掉了 ProtectedSector = config_old . WRPSector ; /* Unlock the Flash to enable the flash control register access *******/ HAL_FLASH_Unlock (); /* Unlock the Options Bytes ********************************************/ HAL_FLASH_OB_Unlock (); /* Erase all the option Bytes ******************************************/ //在HAL_F4的库中没有找到擦除命令位的函数，故在此注释掉 //result = HAL_FLASHEx_OBErase(); //if (result == HAL_OK) //{ config_new . WRPSector = ProtectedSector ; result = HAL_FLASHEx_OBProgram ( & config_new ); //} return ( result == HAL_OK ? FLASHIF_OK : FLASHIF_PROTECTION_ERRROR ); } /** * @brief 根据送入地址获取其所在扇区位置 * @param 需要知道所在扇区位置的地址 * @retval 扇区位置（FLASH_SECTOR_0——FLASH_SECTOR_7） */ //增加扇区编号的获取函数 static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_SECTOR_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_SECTOR_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_SECTOR_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_SECTOR_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_SECTOR_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_SECTOR_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_SECTOR_6 ; } else { sector = FLASH_SECTOR_7 ; } return sector ; } /** * @} */ /******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 四、Keil需要修改的位置 1、需要根据设置的APP程序起始的位置，设置KEIL的起始编译位置与程序空间大小 2、需要在User选项卡中增加自定义处理字符串， C:\\Program Files\\Keil\\ARM\\ARMCC\\bin\\fromelf.exe --bin -o .\\存放bin的路径\\bin文件的名称.bin .\\Keil编译后生成的axf的路径\\axf文件的名称.axf 五、结语 关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。","tags":"STM32F411VET6","loc":"http://dhlx.wang/Porting_AN4657_STM32Cube_IAP_using_UART_to_STM32F411VET6.html","title":"移植AN4657（STM32Cube IAP using UART）到STM32F411VET6"},{"text":"首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我们在移植IAP的过程中主要用到以下三个东西，一个是STM32F411VET6的开发板，一个是待移植的官方的STM32F4-IAP-USART程序，最后一个就是上位机（支持ymodem），这里最好选用官方建议使用的超级终端（Hypertrm）进行测试。 32F411EDISCOVERY STM32F4 IAP using the USART (AN3965) Hypertrm 二、修改串口通讯接口 由于STM32F411VET6中没有USART3，我需要将USART3的配置修改为USART2。这个里面我个人建议修改为与USART3在同一总线上的USART，否则需要进行大量的代码修改。由于我只是进行工程远程调试，暂时不考虑大费周章进行移植和修改，如果后续需要使用，可能会做基于HAL的移植，并对读取Flash的权限做出详细的限制。 下面我们就开始正式的移植过程，我们需要修改工程中的 stm324xg_eval.h 文件中关于USART的宏定义部分。 原始宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART3 */ #define EVAL_COM1 USART3 #define EVAL_COM1_CLK RCC_APB1Periph_USART3 #define EVAL_COM1_TX_PIN GPIO_Pin_10 #define EVAL_COM1_TX_GPIO_PORT GPIOC #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_TX_SOURCE GPIO_PinSource10 #define EVAL_COM1_TX_AF GPIO_AF_USART3 #define EVAL_COM1_RX_PIN GPIO_Pin_11 #define EVAL_COM1_RX_GPIO_PORT GPIOC #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_RX_SOURCE GPIO_PinSource11 #define EVAL_COM1_RX_AF GPIO_AF_USART3 #define EVAL_COM1_IRQn USART3_IRQn 修改后宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART2 */ #define EVAL_COM1 USART2 #define EVAL_COM1_CLK RCC_APB1Periph_USART2 #define EVAL_COM1_TX_PIN GPIO_Pin_2 #define EVAL_COM1_TX_GPIO_PORT GPIOA #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_TX_SOURCE GPIO_PinSource2 #define EVAL_COM1_TX_AF GPIO_AF_USART2 #define EVAL_COM1_RX_PIN GPIO_Pin_3 #define EVAL_COM1_RX_GPIO_PORT GPIOA #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_RX_SOURCE GPIO_PinSource3 #define EVAL_COM1_RX_AF GPIO_AF_USART2 #define EVAL_COM1_IRQn USART2_IRQn P.S.注意您选择USART2的管脚分配，我这里分配的GPIOA2（TX）和GPIOA3（RX）。 三、修改Flash大小定义 由于STM32F411VET6和STM32F407系列的Flash大小不一致，故需要简单修改下Flash的相关函数和定义。 首先，我们需要修改 flash_if.c 中 uint32_t FLASH_If_Erase 的函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_11 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 需要将 FLASH_Sector_11 修改为 FLASH_Sector_7 ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_7 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 其次我们需要修改 flash_if.c 中的 static uint32_t GetSector 函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else if (( Address < ADDR_FLASH_SECTOR_8 ) && ( Address >= ADDR_FLASH_SECTOR_7 )) { sector = FLASH_Sector_7 ; } else if (( Address < ADDR_FLASH_SECTOR_9 ) && ( Address >= ADDR_FLASH_SECTOR_8 )) { sector = FLASH_Sector_8 ; } else if (( Address < ADDR_FLASH_SECTOR_10 ) && ( Address >= ADDR_FLASH_SECTOR_9 )) { sector = FLASH_Sector_9 ; } else if (( Address < ADDR_FLASH_SECTOR_11 ) && ( Address >= ADDR_FLASH_SECTOR_10 )) { sector = FLASH_Sector_10 ; } else /*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_11))*/ { sector = FLASH_Sector_11 ; } return sector ; } 根据实际情况适当增删 FLASH_Sector ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else { sector = FLASH_Sector_7 ; } return sector ; } 四、修改Main函数 在移植过程中根据您的需要，修改Main函数，下面放上原Main函数和我个人根据 32F411EDISCOVERY 修改后的Main函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is pressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } /* Keep the user application running */ else { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } while ( 1 ) {} } 根据 32F411EDISCOVERY 修改后的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is unpressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } /* Keep the user application running */ else { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } while ( 1 ) { ; } } 五、修改IAP_Init函数 根据您的实际情况修改 IAP_Init 函数中的参数。 原函数代码如下： /** * @brief Initialize the IAP: Configure USART. * @param None * @retval None */ void IAP_Init ( void ) { USART_InitTypeDef USART_InitStructure ; /* USART resources configuration (Clock, GPIO pins and USART registers) ----*/ /* USART configured as follow: - BaudRate = 115200 baud - Word Length = 8 Bits - One Stop Bit - No parity - Hardware flow control disabled (RTS and CTS signals) - Receive and transmit enabled */ USART_InitStructure . USART_BaudRate = 115200 ; // 串口波特率 USART_InitStructure . USART_WordLength = USART_WordLength_8b ; USART_InitStructure . USART_StopBits = USART_StopBits_1 ; USART_InitStructure . USART_Parity = USART_Parity_No ; USART_InitStructure . USART_HardwareFlowControl = USART_HardwareFlowControl_None ; USART_InitStructure . USART_Mode = USART_Mode_Rx | USART_Mode_Tx ; STM_EVAL_COMInit ( COM1 , & USART_InitStructure ) ; } 六、结语 关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。 后续，如果我在工作之余或者工作中有需要，我可能会将IAP的代码移植到HAL库上，如果您已经做了相关工作，希望您可以在不涉及保密条款和其他利益的情况下，抄送一份给我，用于后续研究与参考。谢谢！","tags":"STM32F411VET6","loc":"http://dhlx.wang/Porting_FreeModbus_to_STM32F411VET6_based_on_STM32CubeF4.html","title":"基于STM32CubeF4移植FreeModbus到STM32F411VET6"},{"text":"首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。 一、准备移植程序和工具 我们在移植IAP的过程中主要用到以下三个东西，一个是STM32F411VET6的开发板，一个是待移植的官方的STM32F4-IAP-USART程序，最后一个就是上位机（支持ymodem），这里最好选用官方建议使用的超级终端（Hypertrm）进行测试。 32F411EDISCOVERY STM32F4 IAP using the USART (AN3965) Hypertrm 二、修改串口通讯接口 由于STM32F411VET6中没有USART3，我需要将USART3的配置修改为USART2。这个里面我个人建议修改为与USART3在同一总线上的USART，否则需要进行大量的代码修改。由于我只是进行工程远程调试，暂时不考虑大费周章进行移植和修改，如果后续需要使用，可能会做基于HAL的移植，并对读取Flash的权限做出详细的限制。 下面我们就开始正式的移植过程，我们需要修改工程中的 stm324xg_eval.h 文件中关于USART的宏定义部分。 原始宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART3 */ #define EVAL_COM1 USART3 #define EVAL_COM1_CLK RCC_APB1Periph_USART3 #define EVAL_COM1_TX_PIN GPIO_Pin_10 #define EVAL_COM1_TX_GPIO_PORT GPIOC #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_TX_SOURCE GPIO_PinSource10 #define EVAL_COM1_TX_AF GPIO_AF_USART3 #define EVAL_COM1_RX_PIN GPIO_Pin_11 #define EVAL_COM1_RX_GPIO_PORT GPIOC #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOC #define EVAL_COM1_RX_SOURCE GPIO_PinSource11 #define EVAL_COM1_RX_AF GPIO_AF_USART3 #define EVAL_COM1_IRQn USART3_IRQn 修改后宏定义如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * @brief Definition for COM port1, connected to USART2 */ #define EVAL_COM1 USART2 #define EVAL_COM1_CLK RCC_APB1Periph_USART2 #define EVAL_COM1_TX_PIN GPIO_Pin_2 #define EVAL_COM1_TX_GPIO_PORT GPIOA #define EVAL_COM1_TX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_TX_SOURCE GPIO_PinSource2 #define EVAL_COM1_TX_AF GPIO_AF_USART2 #define EVAL_COM1_RX_PIN GPIO_Pin_3 #define EVAL_COM1_RX_GPIO_PORT GPIOA #define EVAL_COM1_RX_GPIO_CLK RCC_AHB1Periph_GPIOA #define EVAL_COM1_RX_SOURCE GPIO_PinSource3 #define EVAL_COM1_RX_AF GPIO_AF_USART2 #define EVAL_COM1_IRQn USART2_IRQn P.S.注意您选择USART2的管脚分配，我这里分配的GPIOA2（TX）和GPIOA3（RX）。 三、修改Flash大小定义 由于STM32F411VET6和STM32F407系列的Flash大小不一致，故需要简单修改下Flash的相关函数和定义。 首先，我们需要修改 flash_if.c 中 uint32_t FLASH_If_Erase 的函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_11 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 需要将 FLASH_Sector_11 修改为 FLASH_Sector_7 ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * @brief This function does an erase of all user flash area * @param StartSector: start of user flash area * @retval 0: user flash area successfully erased * 1: error occurred */ uint32_t FLASH_If_Erase ( uint32_t StartSector ) { uint32_t UserStartSector = FLASH_Sector_1 , i = 0 ; /* Get the sector where start the user flash area */ UserStartSector = GetSector ( APPLICATION_ADDRESS ); for ( i = UserStartSector ; i <= FLASH_Sector_7 ; i += 8 ) { /* Device voltage range supposed to be [2.7V to 3.6V], the operation will be done by word */ if ( FLASH_EraseSector ( i , VoltageRange_3 ) != FLASH_COMPLETE ) { /* Error occurred while page erase */ return ( 1 ); } } return ( 0 ); } 其次我们需要修改 flash_if.c 中的 static uint32_t GetSector 函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else if (( Address < ADDR_FLASH_SECTOR_8 ) && ( Address >= ADDR_FLASH_SECTOR_7 )) { sector = FLASH_Sector_7 ; } else if (( Address < ADDR_FLASH_SECTOR_9 ) && ( Address >= ADDR_FLASH_SECTOR_8 )) { sector = FLASH_Sector_8 ; } else if (( Address < ADDR_FLASH_SECTOR_10 ) && ( Address >= ADDR_FLASH_SECTOR_9 )) { sector = FLASH_Sector_9 ; } else if (( Address < ADDR_FLASH_SECTOR_11 ) && ( Address >= ADDR_FLASH_SECTOR_10 )) { sector = FLASH_Sector_10 ; } else /*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_11))*/ { sector = FLASH_Sector_11 ; } return sector ; } 根据实际情况适当增删 FLASH_Sector ，修改后函数代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * @brief Gets the sector of a given address * @param Address: Flash address * @retval The sector of a given address */ static uint32_t GetSector ( uint32_t Address ) { uint32_t sector = 0 ; if (( Address < ADDR_FLASH_SECTOR_1 ) && ( Address >= ADDR_FLASH_SECTOR_0 )) { sector = FLASH_Sector_0 ; } else if (( Address < ADDR_FLASH_SECTOR_2 ) && ( Address >= ADDR_FLASH_SECTOR_1 )) { sector = FLASH_Sector_1 ; } else if (( Address < ADDR_FLASH_SECTOR_3 ) && ( Address >= ADDR_FLASH_SECTOR_2 )) { sector = FLASH_Sector_2 ; } else if (( Address < ADDR_FLASH_SECTOR_4 ) && ( Address >= ADDR_FLASH_SECTOR_3 )) { sector = FLASH_Sector_3 ; } else if (( Address < ADDR_FLASH_SECTOR_5 ) && ( Address >= ADDR_FLASH_SECTOR_4 )) { sector = FLASH_Sector_4 ; } else if (( Address < ADDR_FLASH_SECTOR_6 ) && ( Address >= ADDR_FLASH_SECTOR_5 )) { sector = FLASH_Sector_5 ; } else if (( Address < ADDR_FLASH_SECTOR_7 ) && ( Address >= ADDR_FLASH_SECTOR_6 )) { sector = FLASH_Sector_6 ; } else { sector = FLASH_Sector_7 ; } return sector ; } 四、修改Main函数 在移植过程中根据您的需要，修改Main函数，下面放上原Main函数和我个人根据 32F411EDISCOVERY 修改后的Main函数。 原先函数的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is pressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } /* Keep the user application running */ else { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } while ( 1 ) {} } 根据 32F411EDISCOVERY 修改后的代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * @brief Main program. * @param None * @retval None */ int main ( void ) { /* Unlock the Flash Program Erase controller */ FLASH_If_Init (); /* Initialize Key Button mounted on STM324xG-EVAL board */ STM_EVAL_PBInit ( BUTTON_KEY , BUTTON_MODE_GPIO ); /* Test if Key push-button on STM324xG-EVAL Board is unpressed */ if ( STM_EVAL_PBGetState ( BUTTON_KEY ) == 0x00 ) { /* Test if user code is programmed starting from address \"APPLICATION_ADDRESS\" */ if ((( * ( __IO uint32_t * ) APPLICATION_ADDRESS ) & 0x2FFE0000 ) == 0x20000000 ) { /* Jump to user application */ JumpAddress = * ( __IO uint32_t * ) ( APPLICATION_ADDRESS + 4 ); Jump_To_Application = ( pFunction ) JumpAddress ; /* Initialize user application's Stack Pointer */ __set_MSP ( * ( __IO uint32_t * ) APPLICATION_ADDRESS ); Jump_To_Application (); } } /* Keep the user application running */ else { /* Execute the IAP driver in order to reprogram the Flash */ IAP_Init (); /* Display main menu */ Main_Menu (); } while ( 1 ) { ; } } 五、修改IAP_Init函数 根据您的实际情况修改 IAP_Init 函数中的参数。 原函数代码如下： /** * @brief Initialize the IAP: Configure USART. * @param None * @retval None */ void IAP_Init ( void ) { USART_InitTypeDef USART_InitStructure ; /* USART resources configuration (Clock, GPIO pins and USART registers) ----*/ /* USART configured as follow: - BaudRate = 115200 baud - Word Length = 8 Bits - One Stop Bit - No parity - Hardware flow control disabled (RTS and CTS signals) - Receive and transmit enabled */ USART_InitStructure . USART_BaudRate = 115200 ; // 串口波特率 USART_InitStructure . USART_WordLength = USART_WordLength_8b ; USART_InitStructure . USART_StopBits = USART_StopBits_1 ; USART_InitStructure . USART_Parity = USART_Parity_No ; USART_InitStructure . USART_HardwareFlowControl = USART_HardwareFlowControl_None ; USART_InitStructure . USART_Mode = USART_Mode_Rx | USART_Mode_Tx ; STM_EVAL_COMInit ( COM1 , & USART_InitStructure ) ; } 六、结语 关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。 后续，如果我在工作之余或者工作中有需要，我可能会将IAP的代码移植到HAL库上，如果您已经做了相关工作，希望您可以在不涉及保密条款和其他利益的情况下，抄送一份给我，用于后续研究与参考。谢谢！","tags":"STM32F411VET6","loc":"http://dhlx.wang/Simple_transplant_IAP_STSW-STM32067_to_STM32F411VET6.html","title":"简单移植IAP（STSW-STM32067）到STM32F411VET6"},{"text":"上周的周末，新买的SSD硬盘到了，需要把旧系统盘的数据迁移至新的SSD上，最开始考虑了Winodws系统映像的方法进行迁移，但通过恢复U盘进入到恢复步骤时，总是提示我无法格式化硬盘，所以放弃了这个方案。 在查询无数资料后，考虑到Win 8.1 Update的组成，突然灵光一现，尝试用Win 8.1的系统盘格式化新的SSD，从而使新的磁盘系统分区和原来的保持一致，通过备份分区数据，还原分区数据的方式，完成系统迁移。 本文就是就是记录下这个操作流程，以备后人参考，如果您有更好的方法，请您不吝赐教，谢谢！ 废话也说完了，我们下面进入到正题。 一、准备工具 天意u盘维护系统技术员版3.0 UltraISO cn_windows_8.1_with_update_x64_dvd_6051473.iso cn_windows_8.1_with_update_x86_dvd_6051523.iso Windows 8 USB Installer Maker DiskGenius v4.7.1 免费版 16G U盘 可量产 如果遇到上述链接无法访问，请您自行想办法。 友情提示：中国拥有世界八大奇迹——长城。 二、制作Winodws 8.1 Upadate U盘安装盘 这个大家应该已经很熟悉了吧！用我提供的Windows 8 USB Installer Maker工具，基本制作过程是傻瓜式安装。 三、安装Winodws 8.1 Upadate到新系统盘 这步我也就简单说下，基本上都会做，说一下几个需要注意的地方。 1、重启进入Bios把安全启动关闭，以免后续从PE、U盘安装盘启动不了。 2、一定保证新盘的分区方式和旧盘一样，我一般采用的系统盘自动分区。 3、进入不进入系统都可以，等会儿都要覆盖的。 四、安装天意U盘PE 这步在天意大大贴子中已经写的很清楚了，我就不重复给出制作U盘PE的教程了。这里仅给出一个UltraISO可用的用户名和注册码。 用户名：王涛 注册码：7C81-1689-4046-626F 五、备份旧系统盘数据 1、如下图所示，进入到天意PE中，打开DiskGenius。 2、选中原系统分区，单机鼠标右键，可以看到备份分区到镜像文件，点击它。 在这里您需要注意查看下旧系统分区的数据量是否远小于新系统盘的分区大小。 3、选择文件路径，并点击开始，就可以开始备份了。 六、还原旧系统盘数据到新系统盘 1、选中新系统分区，单机鼠标右键，可以看到从镜像文件还原分区，点击它。 2、选择刚刚备份的文件，并点击开始，进行系统迁移。 七、重新设置引导参数 1、在天意PE中默认没有给引导分区指派盘符，所以我们需要找到系统的引导分区，单机鼠标右键，可以指派新的驱动器号，点击它。 2、选择您想要赋予的盘符，选择它，记住它，并单击确定。 3、打开开始菜单，找到BIOS+UEFI引导修复工具，打开它。 4、按照提示填写Windows系统分区盘符，引导分区盘符，并按下回车，确认信息后，再次按下回车。 5、出现上图最后一行的提示，您可以关闭程序，并重启电脑。 八、结语 以上就是我此次系统迁移的基本过程，如果您有没看懂的地方，您可以留言，我看到后会及时回复。 P.S. 天意大大说我提供这个版本PE中DiskGenius有一些问题，但是在操作过程中我没有遇到，如果您遇到了，可以用DiskGenius的原版（在第一章节中有提供下载地址）尝试下。","tags":"Windows","loc":"http://dhlx.wang/Win8-1-Update-System-Migration.html","title":"Windows 8.1 Update 系统迁移"}]}