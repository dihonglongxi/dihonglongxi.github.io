<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>帝鴻龍曦</title><link href="http://dhlx.wang/" rel="alternate"></link><link href="http://dhlx.wang/feeds/all.atom.xml" rel="self"></link><id>http://dhlx.wang/</id><updated>2016-04-17T16:50:00+08:00</updated><entry><title>BQ24610 详细调试过程和心得</title><link href="http://dhlx.wang/Electron_Technology%5CBQ24610_Debugging_Process.html" rel="alternate"></link><updated>2016-04-17T16:50:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2016-04-10:Electron_Technology\BQ24610_Debugging_Process.html</id><summary type="html">
&lt;p&gt;  年前接手了一项我从来没有搞过的项目——DCDC电源Demo板的制作，本文中将会详细记录从无到有的调试过程，以及一些心得。&lt;/p&gt;
&lt;p&gt;  文中会有部分的材料来源于网络和各个公司的应用手册，我只挑了一些我用的到片段进行汇总，大部分会给出出处，少部分无法查证，可能就不给出来，如果侵犯了您的版权，请您发邮件和我说明。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、开关电源简述&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  开关电源（Switching Mode Power Supply，常常简化为SMPS），是一种高频电能转换装置。其功能是将电压透过不同形式的架构转换为用户端所需求的电压或电流。&lt;/p&gt;
&lt;p&gt;  开关电源的拓扑指开关电源电路的构成形式。一般是根据输出地线与输入地线有无电气隔离，分为隔离及非隔离变换器。非隔离即输入端与输出端相通，没有隔离措施，常见的DC/DC变换器大多是这种类型。所谓隔离是指输入端与输出端在电路上不是直接联通的，使用隔离变压器通过电磁变换方式进行能量传递，输入端和输出端之间是完全电气隔离的。
  对于开关变换器来说，只有三种基本拓扑形式，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buck（降压）&lt;/li&gt;
&lt;li&gt;Boost（升压）&lt;/li&gt;
&lt;li&gt;Buck-Boost（升降压）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  三种基本拓扑形式，是电感的连接方式决定。若电感放置于输出端，则为Buck拓扑；电感放置于输入端，则是Boost拓扑。当电感连接到地时，就是Buck-Boost拓扑。&lt;/p&gt;
&lt;h1 id="bq24610"&gt;二、BQ24610典型应用&lt;a class="headerlink" href="#bq24610" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  BQ24610的典型应用如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="BQ24610典型应用" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/4/BQ24610_Debugging_Process/0001.PNG"/&gt;&lt;/p&gt;
&lt;p&gt;  一个典型Buck拓扑的同步开关电源，Q4和Q5分别构成高低边开关，电流和电压经过L1和C12、C13趋于平滑，给外部电池组充电。由于BQ24610带电源路径管理，所以它有两个检流电阻，一个是RAC，检查ADAPTER的输入电流；一个是RSR，检查BUCK拓扑给电池包的充电电流，当系统侧电流和电池包的充电电流达到ADAPTER的最大输入电流时，会优先供给系统，减少电池包的充电功率，以保证后续系统在充电时可以正常工作。其次比较重要的就是一些参数的设置，由于BQ24610是一个低成本的大功率充电的解决方案，所以参数设置采用模拟设置方式，也就是根据输入电压设置，所以这里的一些关键电阻需要采用高精度电阻（1%，0.5%），如R1、R2、R3、R4、R5、R6、R7、R8、R9、R10等，这里特别建议R1和R2采用0.5%的精度，这样可以保证电池不过充，同时电池电压刚刚好。其次就是RSR和RAC一定要选用大品牌大厂家（国巨，Vishay）的检流电阻，否则的话有可能会造成不必要的麻烦。其余部分电路应该很好理解了，D1，C5，C6利用电容两端电压不能突变，构成了一个小型电荷泵，用来驱动NMOS工作；D2，D3，D4用来指示芯片的工作状态；R20、C16构成一个简易的滤波器，滤除ADAPTER的交流分量，也减少充电系统对前级系统的影响；Q1和Q2构成了ADAPTER的控制开关，Q3是电池包供电的开关；C8，C9用来进行储能，减少后续系统对前级系统的干扰。特意说明下，有些电容也存在一定可能性会对系统产生不必要的干扰，建议选用大厂（三星）X7R的5%精度的电容，如CCTC的定时电容。&lt;/p&gt;
&lt;h1 id="_2"&gt;三、调试过程中遇到的问题&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  由于在接手这个设计任务之前，对于开关电源的了解，仅限于会使用LM2576、LM2577、LM2596等常用电路，了解开关电源的常用的三种模型。所以可以说我是电源界的小白吧！经历了这个任务遇到了许多问题，伴随着问题不断的解决，我也逐渐的更加深入的了解了开关电源的特性。下面我就说说我碰到的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STAT1和STAT2状态指示灯均熄灭，PG指示灯正常&lt;/li&gt;
&lt;li&gt;芯片检测不到电池&lt;/li&gt;
&lt;li&gt;电池包充电电压不对&lt;/li&gt;
&lt;li&gt;低边MOS（Q5）、升压二极管（D1）、芯片（U1）烧毁&lt;/li&gt;
&lt;li&gt;BQ24610充电系统对ADAPTER的干扰大&lt;/li&gt;
&lt;li&gt;定频的BQ24610的L1前端开关频率和波形不对&lt;/li&gt;
&lt;li&gt;定时保护被误触发（TTC）&lt;/li&gt;
&lt;li&gt;制作高端检流电阻（RSR）两端的共模放大器，放大数据不对&lt;/li&gt;
&lt;li&gt;在电池包前级加入低端检流电阻，烧毁电压检测电阻（VFB的分压电阻R1、R2）&lt;/li&gt;
&lt;li&gt;电感L1啸叫&lt;/li&gt;
&lt;li&gt;电感L1前端波形存在振铃&lt;/li&gt;
&lt;li&gt;电感L1前端存在尖峰脉冲&lt;/li&gt;
&lt;li&gt;高低边的驱动波形存在问题&lt;/li&gt;
&lt;li&gt;低边MOS（Q5）的DS两端加入RC减震器，导致RC过热&lt;/li&gt;
&lt;li&gt;高边MOS（Q6）的GDS全部短路、芯片烧毁&lt;/li&gt;
&lt;li&gt;电池包产生过流过压保护异常&lt;/li&gt;
&lt;li&gt;系统侧带载充电曲线异常&lt;/li&gt;
&lt;li&gt;系统侧不带载充电电流不够设定值&lt;/li&gt;
&lt;li&gt;人际关系（FAE，Manager）处理问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_3"&gt;四、一步一步解决碰到的坑&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  这个部分中我可能会抱怨一些事情，也会陈述一些事实，更会详实的记录我的调试过程，如果您看我的文章只是为了寻找BQ24610的应用解决办法，我建议您不要看这节了，直接跳过去看第五节，正如TI原厂FAE所说，我们的芯片没有问题，有问题的是客户，客户的硬件技能不过关，PCB Layout做的不好，才可能出现各种各样的问题。&lt;/p&gt;
&lt;p&gt;电路板的Layout即是一门工程学术问题，也是一个哲学问题，艺术的表达。&lt;/p&gt;
&lt;p&gt;首先我想说的人际关系的处理问题，在此次的问题解决过程中，主要涉及四个人:供应商FAE、TI原厂FAE、小组组长、项目经理。&lt;/p&gt;
&lt;p&gt;以下的描述基于个人感受，或许有积极的一面，或许也有消极的一面。&lt;/p&gt;
&lt;p&gt;供应商FAE：之前和我接触的一直是另外一家的FAE，但新来的项目经理换了供货商，无奈供应商的FAE也换掉了，新换的FAE对这款芯片不了解，所以过去一个月基本上是我们同时从无到有的去了解这款芯片，一起讨论这款芯片的各种性能和波形，可以说是我们相处比较愉快，尽心尽责的好FAE，当然这中间也被他坑过，这个后面我会讲给大家听。&lt;/p&gt;
&lt;p&gt;TI原厂FAE：对待我们这些小厂，十分霸气的说了一句话——我们的芯片没有问题，有问题的是客户，客户的Layout不过关。之后，就没有在提供任何有用的信息了，但最后解决问题的途径，确实是PCB Layout。&lt;/p&gt;
&lt;p&gt;小组组长：这个可能是一个巨坑，希望你们不要和我一样遇到这种巨坑，求助问题说：你的工资又不给我一半，帮你是人情，不帮你，你也没啥可说的，这个确实让我无话可说，但是你给我的帮助都是顺嘴胡说，这个我忍不了，你不看芯片手册，上来就和我说这块你的电阻选大了，电流过小，导致什么什么的问题，不详细看原理图和手册，就和我说，这个下拉电阻是必须的，因为芯片会上电检测一个低电平，不看看我的Layout就和我说，你的layout太次了，这样吧，你按照EVM的原理图你给我画一个，我给你Layout一下吧，最后说我画的EVM电路又是各种不对，看起来差太多，要我画个一模一样的，你不画，你就接着自己研究吧，我不能说什么了，只能祝愿你们有一个好的小组组长。&lt;/p&gt;
&lt;p&gt;项目经理：这个职位在我们公司的定义有些混乱，既要监督项目的进度，又要协调各种资源，采买器件，管理器件等，但是在研发阶段过渡的压缩硬件成本是不是有些不靠谱，这回有些坑就是由于器件问题造成的。这个问题确实可能大家都没有想到，无可厚非。&lt;/p&gt;
&lt;p&gt;以上，我简单的抱怨了一下，设计验证过程中，碰到各种人际关系处理的坑，下面让我们进入到正题，后续可能很无聊，应该是一个平淡无奇的记叙文（P.S. 我的语文不是很好）。&lt;/p&gt;
&lt;p&gt;2016年2月24日&lt;/p&gt;
&lt;p&gt;  焊接完毕，开始调试，插入电池和温度电阻，STAT1和STAT2状态指示灯均熄灭，PG指示灯正常。&lt;/p&gt;
&lt;p&gt;2016年2月25日&lt;/p&gt;
&lt;p&gt;  对照手册，开始测量芯片的VCC，VREF，RRGN，TTC,TS和EN等关键节点电压均正常，但用示波器测量L前端的波形，发现波形频率不对，并伴有周期性的下降脉冲，在L后端测量仍出现下降脉冲，和兴业的FAE联系，共同解决问题，由于他已经下班，并且没有使用过这款芯片，未能及时给出解决办法。&lt;/p&gt;
&lt;p&gt;2016年2月26日&lt;/p&gt;
&lt;p&gt;  FAE猜测在电荷泵附近的电容（C6）驱动能力不够，导致波形异常，将0.1uF的电容换成1uF，未果，未能解决波形问题，后来相互探讨，怀疑所选的MOS的带载能力不够，采用电阻做阻性负载，试验ACFET和BATFET的功能和芯片的电源链路管理是否正常，电源和电池可以正常带载，链路管理正常，但是电池带载时，电感会有异响。重新阅读芯片手册，发现芯片的内置程序上电会先检测是否存在电池PACK，但电池组的插上与拔下，电感的前端和后端波形无变化。&lt;/p&gt;
&lt;p&gt;2016年2月28日&lt;/p&gt;
&lt;p&gt;  变更VFB的反馈电压，换用不同的电池组，发现用磷酸铁锂的PACK，芯片可以检测到，当出现了一个新的问题，芯片的STAT1指示灯会有规律闪烁。&lt;/p&gt;
&lt;p&gt;2016年2月29日&lt;/p&gt;
&lt;p&gt;  焊接三块新的充电板子，并查询高边电流放大电路以及运放的选型的信息。&lt;/p&gt;
&lt;p&gt;2016年3月1日&lt;/p&gt;
&lt;p&gt;  磷酸铁锂PACK做了放电后，充电，发现芯片给PACK充电时时断时续，监测STAT1，发现存在4S的周期，50%的占空比的方波。电感有吱吱的响声，FAE猜测电感量过小，可能产生饱和。串联电感测试，问题没有解决，波形不对，声音有所减小，充电仍是时断时续。&lt;/p&gt;
&lt;p&gt;2016年3月3日&lt;/p&gt;
&lt;p&gt;  和FAE进行现场调试，看到板子后说电源的地平面不够完整，需要通过粗导线完善地平面的，但调试过程中四块板子均因为不明原因损坏，关键节点(REGN等)电压不正常。没有良好的结果。&lt;/p&gt;
&lt;p&gt;2016年3月4日&lt;/p&gt;
&lt;p&gt;  查找板子损坏的原因，经测量三块板子中的低边MOS（Q5）、升压二极管（D1）、芯片（U1）烧毁，一块板子芯片没有焊接好，因为有两块板子刚刚上电就烧毁，所以翻译可能是电源稳压器刚刚上电产生过大的尖峰，或者夹子之间不稳，产生一种尖峰电压烧毁板子，修复板子之后，加大电感量从6.8uH到15uH，发现可以正常充电，电感伴有啸叫，而且还出现充电定时器不定时被触发，停止充电，因为电容用的是X5R的20%电容，所以怀疑可能是电容的质量问题造成的。后经查看手册计划，将TTC接到高电平进行测试，看看可否正常充电。&lt;/p&gt;
&lt;p&gt;2016年3月6日&lt;/p&gt;
&lt;p&gt;  将TTC电平接到Vref上，未出现充电中断的问题，初步判定是电容引起的，由于测试过程中总会烧低边MOS（Q5）、升压二极管（D1）、芯片（U1）和电池PACK不靠谱等原因，将6S参数换成2S进行测试，充电未中断，电感有啸叫。&lt;/p&gt;
&lt;p&gt;2016年3月7日&lt;/p&gt;
&lt;p&gt;  新的电池Pack到了，三组国产5200mAH，一组进口6400mAH进行测试，仍存在充电板损坏的问题。项目经理重新采买X7R 5%的电容的，进行测试，发现中断时间好转，但仍存在充电过程中，充电定时器会被误触发的问题，同时发现L1前端的波形尖峰，振铃严重。&lt;/p&gt;
&lt;p&gt;2016年3月8日&lt;/p&gt;
&lt;p&gt;  尝试加入RC减震器，L1前端波形没有好转，有可能是加入RC参数不对，下午的时候寻找TTC误触发的问题时候，发现模拟地上有很大的正弦波干扰，和FAE讨论，觉得这些问题最大可能性是由于地平面不够完整造成的。&lt;/p&gt;
&lt;p&gt;2016年3月10-16日&lt;/p&gt;
&lt;p&gt;  找相关的资料，关于地平面，尖峰，振铃干扰方面，发现说地平面的间距问题可能会造成问题，敷铜的直角可能会造成一定问题，FAE说高频回路太长，驱动线太长，尝试减小高频回路的距离，减小驱动线的距离，增加驱动线上的阻抗等解决办法，由于TI给出的PDF上布线不清晰，没有给到我明确的参考，只参考了布局和布线。&lt;/p&gt;
&lt;p&gt;2016年3月17-20日&lt;/p&gt;
&lt;p&gt;打样（B版和C版），并做高端电流采样的电路等。&lt;/p&gt;
&lt;p&gt;2016年3月21日&lt;/p&gt;
&lt;p&gt;  焊接调试（B版），L的前端波形好了很多，可见尖峰消失，但仍有振铃，芯片仍在某种情况下会损坏，REGN无输出，MOS管DS、二极管击穿。电感换用15uH，有振铃，波形不对，电感有噪音，但可以充电，TTC定时仍会不定时失效。FAE认为有噪声正常，但是我觉得噪声不正常。&lt;/p&gt;
&lt;p&gt;2016年3月22日&lt;/p&gt;
&lt;p&gt;  没有找到良好的解决办法，将购买EVM重新提上日程进行购买。&lt;/p&gt;
&lt;p&gt;2016年3月24日&lt;/p&gt;
&lt;p&gt;  尝试一些方式，没有找到良好的解决办法，芯片就剩最后一枚。&lt;/p&gt;
&lt;p&gt;2016年3月25日&lt;/p&gt;
&lt;p&gt;  和兴业FAE调试一天，没有解决，和TI原厂FAE简单谈了下，给了我一个结论就是芯片应该没问题，就是PCB Layout的问题。&lt;/p&gt;
&lt;p&gt;2016年3月27-31日&lt;/p&gt;
&lt;p&gt;  重新布板，参考官方的EVM板，注意地平面完整性，继续减少地平面与其他信号的间距到0.2mm，增加RC减震器的解决验证方案，将驱动线的过孔之间的间距加大，将VFB引脚的引线从就近，改为从输电容后级引出，注意地平面就近形成回路等解决办法。&lt;/p&gt;
&lt;p&gt;2016年4月5-7日&lt;/p&gt;
&lt;p&gt;  焊接调试，波形没有问题了，但上管在某些情况下GDS会全部击穿，经查询资料，可能是由于MOS的G极阻抗过大引起的，去掉G极外加的电阻，解决此问题，加入RC减震后，1S2P充电正常，波形正常，但6S可以充电，但波形不正常，所以去掉RC解决此问题，波形正常，无尖峰，无振铃，基本可以证明电路现在稳定好用了。&lt;/p&gt;
&lt;p&gt;2016年4月8日&lt;/p&gt;
&lt;p&gt;  测试并描绘实际电池的充电曲线发现电池曲线的恒流段有问题，最大电流只有2.8A，远超出应有的误差，带载测试，发现恒流段电流从充电开始不断减少，直到2.4A左右。恒压段还算稳定。但测试ISET1、ISET2、ACSET的电压与EVM、计算值无异。&lt;/p&gt;
&lt;p&gt;2016年4月10日&lt;/p&gt;
&lt;p&gt;  测试并描绘EVM的充电曲线，发现带载充电曲线很正常，只有最后ADAPTER输出到4A以后，才会逐渐减少充电电流，但ADAPTER始终输出到4A左右电流，与FAE进行讨论，FAE认为已经满足我们的是要求，当我觉得是Demo，各方面应该尽量调节到足够好，我们之后讨论相关问题，总结出可能是由于布线仍不是很理想，器件可能有问题，尝试换用国巨的电流采样电阻，进行初步测试，还算理想，电流可以控制在2.95A以上，满足手册上的误差（3%-4%）。&lt;/p&gt;
&lt;p&gt;2016年4月11日&lt;/p&gt;
&lt;p&gt;  进行电池比对曲线测试，放电测试等，并进行多次充放电试验，验证Demo板足够稳定。&lt;/p&gt;
&lt;p&gt;2016年4月15日&lt;/p&gt;
&lt;p&gt;  焊接新的两块充电板（D版），并测试其参数，充电曲线。&lt;/p&gt;
&lt;p&gt;2016年4月17日&lt;/p&gt;
&lt;p&gt;  补充项目调试中的记录，并完成项目总结。&lt;/p&gt;
&lt;h1 id="bq24610-pcb-layout"&gt;五、BQ24610 PCB Layout的注意事项&lt;a class="headerlink" href="#bq24610-pcb-layout" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  在这里我写的一些注意事项，可能都是电源新手Layout碰到的一些问题，如果有描述不正确，或者不明白的地方，应该是我才疏学浅，能力不到家所致，还请您不吝赐教。&lt;/p&gt;
&lt;p&gt;BQ24610主要的等下电路如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Buck原理示意图" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/4/BQ24610_Debugging_Process/0002.PNG"/&gt;&lt;/p&gt;
&lt;p&gt;  布板布局时应遵从高频回路最短的原则进行布局布线，使开关接点处的开启和关断时间降至最低，减少开关过程中的损耗，同时注意减少高频环路电流，基于这个基本原则，我给出以下的布局布线的意见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;输入电容应尽可能接近开关MOSFET电源和地，最好是紧贴着高边MOS的输入和低边MOS的输出，并用最短的铜箔进行连接。同时输入电容和高低边MOS应在同一层，走线应无过孔链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BQ24610应靠近开关MOSFET栅极端子放置，并有意加粗栅极的PCB走线（最好是20mil以上，周围包裹着电源地平面，在爬墙间距下，保证地线和信号线的间距为PCB厂商可以加工的最小间距即可），从而保持栅极驱动信号走线足够短，驱动信号足够干净。BQ24610到MOSFET的驱动走线可以走底层PCB。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将电感尽可能靠近开关MOSFET放置。尽量减少此处电场和磁场辐射，保证最小的敷铜面积（足够通过足量电流即可），不能使用多层链接，尽量不打过孔。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检流电阻应就近放置在输入输出位置上。布线上一定要单独引出测量线，如上图所示，在测量线上主要尽量走差分线，不打过孔。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如有需要，在可能产生高频影响的位置，增加旁路或者去耦电容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地线一定要模拟地和数值地分开，并通过芯片的PAD进行单点接地，不要形成回路，同时需要注意两个地平面的完整性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开关MOS、电感、芯片，要注意散热的布局，如芯片的PAD一定要可靠的和地平面链接，最好和整块铜层链接，增加散热面积。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有线路的宽度和过孔数量、大小，应保证可以正常走流，无温升。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VFB的接线一定要从PACK的输出电容后级单独引线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地平面和其他走线的间距一定要最小，减少寄生电容和寄生电感。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模拟器件一定要远离LX节点放置，适当增加旁路电容，减少干扰。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_4"&gt;五、总结&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;切忌浮躁&lt;/li&gt;
&lt;li&gt;执着，顽强,自信&lt;/li&gt;
&lt;li&gt;举一反三&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  以上三点就是这回调试过程中，我总结出来最重要的东西。在开发过程中，做的比较深的时候，出现的问题已经太依赖你现在的环境，如果要找人来帮我，我还要花很长时间给他解释问题产生的原因，他也不会肯花大量时间从头跟进去。像这种问题在网上也找不到类似的答案。此时，虽然没人能帮我，但是我还是可以通过跟别人的讨论来得到一些有用的信息；虽然在网上找不到类似的答案，但我还是在网上一些类似应用的相关信息（比如找到了一个讲Boost的布线原则的，但还是可以应用Buck中的）；结合别人的指导，网络的信息，自己的分析，以前的经验，各种实验的排除，我这次才能完美的几角这个问题。&lt;/p&gt;</summary><category term="BQ24610"></category><category term="DCDC"></category><category term="PCB"></category></entry><entry><title>2016，启程</title><link href="http://dhlx.wang/Travels/2016_Start.html" rel="alternate"></link><updated>2016-01-02T10:16:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2016-01-02:Travels/2016_Start.html</id><summary type="html">
&lt;p&gt;  在去年的圣诞的时候接到了接到一个不知道是什么滋味的电话，心情不知道怎么了有些不开心，想要出去散散心，也想祭奠下我已经逝去的青春，更想给自己的2016年一个不一样的开始。&lt;/p&gt;
&lt;p&gt;  有人说，十年中国看深圳，百年中国看上海，千年中国看北京，三千年中国看西安，五千年中国看山西。上回从新疆回来路过西安咸阳机场，就有想去西安看看的想法，忽然有了个想法：去一个陌生的城市——西安跨年，也看看秦一统六国的内史，大唐盛世中的京兆，八水绕长安的胜景。&lt;/p&gt;
&lt;h3 id="20151229"&gt;2015年12月29日&lt;a class="headerlink" href="#20151229" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  晚上一下班就奔赴北京西站，乘坐晚上8点的Z43到西安去。一夜中，除了卧铺是上铺，空调开的比较冷，其他的都还好。顺道说下，如果有时间，千万要吃完饭再去火车站，火车站的东西真是又贵又难吃。&lt;/p&gt;
&lt;p&gt;  在等火车的过程中，接到一条通知短信，原定1号晚上ZH9404的航班被取消，被保护至3号晚上的ZH9404的航班，虽然这样有理由多玩两天，但是还要飞公司干活，时间紧，任务重，只好致电深航改签，一定要和客服说明，你要当天回来，第二天有事，要不深航客服，才不会帮你想办法。当然了结局都是不完美的，改签到了23点多的海航，真正的红眼航班，今年第一次哟！&lt;/p&gt;
&lt;h3 id="20151230"&gt;2015年12月30日&lt;a class="headerlink" href="#20151230" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  今天一早起来就到达西安站，很可惜我没有出西安站看看，这回时间上的安排有些不是很好，时间太紧了，8:30左右下了Z43次火车，不出站换乘，出发去华山站，我已经记不清有多久没有在火车上听到单口相声了，都快遗忘了这种腔调，好像是上了大学以后，坐车的时候就是喜欢做晚上的车，第二天早上下了车，就去玩或者办事。当听到火车上的单口相声，童年的记忆瞬时如潮涌般涌现，小时候我最喜欢的就是从姥姥家做火车，第一个是回家快，第二个不用在公交车上冻上2个小时。&lt;/p&gt;
&lt;p&gt;  下了火车，看到华山站，一股熟悉感铺面而来，感觉又回到了小时候，在姥姥家寒暑假过完，要乘火车回家的场景，但是，子欲养而亲不待，今年应该是姥姥走的第四个年头了！&lt;/p&gt;
&lt;p&gt;&lt;img alt="逐渐远去的铁道" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0001.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  华山站看起来小小的，比华山北小多了。如果真想要一天往返华山，最好的建议是做早班的动车到华山北，做晚班的动车回西安，回西安的动车一直到晚上十点多，但是晚上要从华山景区到华山北站只能打车了，价格还算能接受吧，大概10分钟的路程，20元，基本上都是这个价。&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山站" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0002.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  不知道为什么华山游客中心的大门和售票处要设置这么远，大概从大门处下了出租车，往里走，要走8分钟左右吧！&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山游客中心小路" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0003.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  由于时间的问题，这回爬华山选择的是西峰索道上山，北峰索道下山，这也是我第一次坐索道上山，之前我都是在时间充足的前提下一步一步的征服大山。&lt;/p&gt;
&lt;p&gt;  从景区的游客中心，不管你是想步行上山，还是索道上山，都得坐景区的区间车。而且到西峰索道的时间比较长，大概得坐40多分钟的区间车，才可以到达索道下的停车场，这时从停车场开始爬山，大概需要10分钟左右才能到达索道检票口。这个有些比较坑，就算索道上下，爬华山您也要准备5-6小时，才可以玩的尽兴。&lt;/p&gt;
&lt;p&gt;&lt;img alt="太华胜景" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0004.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  从早上到现在一直在路上奔波，都没有来得及吃口东西，现在到了索道下面，我得抓紧时间好好补充下体力，点了一碗拌面。华山景区的视频和水的价格不是一般的贵，时间充足，建议在华山市准备得当，再去华山游客中心，否则就只能认了，这样一碗热气腾腾的拌面要我40的软妹币，一瓶脉动要了我18。&lt;/p&gt;
&lt;p&gt;&lt;img alt="拌面" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0005.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  缆车和设备看起来很新，安全性问题，应该可以不用担心，但是有恐高症的，我强烈建议不要乘坐华山的缆车。&lt;/p&gt;
&lt;p&gt;&lt;img alt="西峰缆车" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0006.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="缆车刚刚驶出" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0007.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  华山的西峰缆车的运行轨迹有些像是大写字母“N”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="中间的山峰" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0008.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="遥望山中的换乘站" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0009.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  虽然华山的缆车上的风景很漂亮，很值一回票价，但是拍出的照片真的没有找到太好看的，始终有些不完美，因为缆车上你只能透过玻璃拍照、看景，基本上可以说是全密封吧！&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山山脉" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0010.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  这辆铲车来头不小，据“史书”记载：“公元2009年上站施工，数十名壮士肩扛背驮，运送本物到此，功垂索道建设大业！今存此以志华山精神。”&lt;/p&gt;
&lt;p&gt;  华山如此陡峭，还能运送如此庞大的工具到此，可见人的潜能是无限的，只是缺少适当的环境去发挥而已。&lt;/p&gt;
&lt;p&gt;&lt;img alt="开山铲车" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0011.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  在去往西峰山顶的路上碰到了华山上的挑山工，不能说华山的商店上宰客，确实卖给你们的东西都是由人力一步一步的挑上来的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="挑山工" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0012.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  从华山西峰远眺华山市，从这你们应该不难看出，天上是蓝天，山下是雾霾成海。真希望今后有机会再来华山时，看到的不是霾海，而是华山市。&lt;/p&gt;
&lt;p&gt;&lt;img alt="远眺华山市" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0013.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  华山西峰登顶的必经之路，真的是在绝壁中爬上爬下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="西峰登顶路" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0014.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  华山其实很有意思，五座山峰像是人的五根手指一样，北峰是大拇指，东峰是食指，南峰是中指，西峰是无名指，中锋是小拇指。&lt;/p&gt;
&lt;p&gt;&lt;img alt="西峰顶" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0015.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  这个照片中，还算勉强可以看清华山市。&lt;/p&gt;
&lt;p&gt;&lt;img alt="西峰顶远眺华山市" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0016.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  据说这个叫神龟探海，看起来还真有些像。&lt;/p&gt;
&lt;p&gt;&lt;img alt="神龟探海" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0017.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  好像每座名山中的松树或多或少都有些讲究，这颗松树好像叫拜公松。&lt;/p&gt;
&lt;p&gt;&lt;img alt="拜公松" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0018.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  华山最高峰，虽然比较俗气，但还是拍了个照片留作纪念。&lt;/p&gt;
&lt;p&gt;&lt;img alt="南峰顶" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0019.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  从南峰顶眺望远处三公山，看起来山势连绵，非常大气。&lt;/p&gt;
&lt;p&gt;&lt;img alt="远眺群山" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0020.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  在华山上，感觉最坑的就是这个华山论剑了，基本上每个山峰都有这么一块碑，都是金庸写的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山论剑" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0021.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  从华山顶远眺西峰顶，华山上的建筑真的是建在绝壁之上。&lt;/p&gt;
&lt;p&gt;&lt;img alt="远眺西峰顶" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0022.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  华山的南天门，从这过去就是华山的著名景点——长空栈道，如果大家时间不多，我不建议大家下长空栈道，不如去鹞子翻身走上一遭。&lt;/p&gt;
&lt;p&gt;&lt;img alt="南天门" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0023.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  去往长空栈道上有劝你悬崖勒马的石刻，可惜俺就是来尝试下长空栈道的景象刺激的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="悬崖勒马" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0024.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  去往长空栈道的小路，确实很窄，仅能容一人上下。但从这一眼望去，山脉连绵不绝，确实很雄伟。&lt;/p&gt;
&lt;p&gt;&lt;img alt="去往长空栈道的小路" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0025.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="俯视群山" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0026.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="远眺三公山" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0027.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  从山上小道下到长空栈道，虽然长空栈道不收门票钱，但是收租用安全绳的费用（30元）。这个建议大家都下去尝试下，我感觉还是蛮安全的。而且山下的风景比山上的风景要好很多。&lt;/p&gt;
&lt;p&gt;&lt;img alt="长空栈道下山路" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0028.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="长空栈道" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0029.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  但是长空栈道的尽头比较无聊，只有这么一颗松树，但是我也很佩服，有人能把红绳系到那么靠前去。&lt;/p&gt;
&lt;p&gt;&lt;img alt="歪脖松" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0030.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  南天门后的钟，有什么传说，这个我就不知道了，只是当时看到了，随手拍了一张。&lt;/p&gt;
&lt;p&gt;&lt;img alt="钟" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0031.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  从南天门下来去，去玩东峰的小路，这段路，我感觉应该是华山中最好走的道了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="东峰小路" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0032.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  坑爹的华山论剑石碑！&lt;/p&gt;
&lt;p&gt;&lt;img alt="东峰华山论剑" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0033.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  从东峰远眺下棋亭，可惜这回没有时间去了，听从鹞子翻身回来的朋友说，比长空栈道好，人还超少。下棋亭远眺群山的景色，也很超值了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="下棋亭" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0034.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  华山上的松树真的很多，东峰的登顶路。&lt;/p&gt;
&lt;p&gt;&lt;img alt="东峰登顶路" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0035.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  中锋基本上没有拍照片了，感觉无聊一些，从中锋去金锁关的险道。&lt;/p&gt;
&lt;p&gt;&lt;img alt="险道" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0036.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  金锁关真的有很多的“金锁”，密密麻麻的！&lt;/p&gt;
&lt;p&gt;&lt;img alt="金锁关" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0037.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  远眺北峰和北峰索道，北峰很值得登顶，据说有宝藏哟！&lt;/p&gt;
&lt;p&gt;&lt;img alt="远眺北峰" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0038.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  华山是真的需要爬的，爬的你毫无俊男美女的形象可言。&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山真的要爬的" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0039.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  自古华山一条路，如果体力不好，还是走新开辟的上山道吧！那里坡要缓一些，好走一些，当然要多走不少路。&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山自古一条路" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0040.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  华山最大的特点，感觉就是是和白桦树一样的山体颜色，还有万仞的悬崖绝壁，毫无着力点，估计攀岩的人，都不能从这上华山吧！&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山绝壁" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0041.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  这次华山的行程要结束了，有遗憾，有震撼，有可惜，遗憾是没有在东峰看到日出，没有在西峰看到日落，只在北峰的日月石看了下日落，也还蛮漂亮的；震撼的是华山的万仞绝壁，可惜的是我没有征服华山。&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山北峰日落" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0042.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  从北峰索道下来，看见了华山的冰瀑和危险的智取华山路，也算弥补了30号没有看到壶口瀑布的冰瀑的一个遗憾吧！&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山北峰索道" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0043.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山北峰冰瀑" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0044.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  华山北站，看起来真的比华山站大气很多，但是没有华山站的历史和记忆。华山，再见，希望有机会再见。&lt;/p&gt;
&lt;p&gt;&lt;img alt="华山北站" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0045.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  回到西安，第一件事就是直奔钟楼附近的同盛祥去尝一尝陕西特色——羊肉泡馍，但是累了一天了，还让我把两个馍掰成豆粒大小实在有些力不从心。除了羊肉泡馍，还买了柿子饼和炒凉粉，我个人觉得晚上吃羊肉泡馍有些太腻了，应该中午吃，但是柿子饼真不错。&lt;/p&gt;
&lt;p&gt;&lt;img alt="同盛祥1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0046.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="同盛祥2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0047.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  找回青旅的上，走到了回民街，头一回见这么巨大的望远镜，你们猜猜这是干什么的，居然是看星星，当天雾霾，我反正用肉眼一颗星星也看不见，也就没有尝试用这么高大上的东西看下星星。&lt;/p&gt;
&lt;p&gt;&lt;img alt="天文望远镜" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0048.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  晚上的钟楼真的很漂亮，就是晚上不让进，有些可惜。&lt;/p&gt;
&lt;p&gt;&lt;img alt="钟楼" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0049.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  历经千辛万苦找到了我要住的旅舍，看着外面我以为关门了，还想着今晚睡在外面，但这些都是表象，外面很清静，里面非常热闹，这两天可能因为是元旦的原因，再一个西安是唐朝的长安城，所以住的外国人特别多。这家青旅很有特色，是个四合院，建议大家可以去尝试住下，一定不虚此行。&lt;/p&gt;
&lt;p&gt;&lt;img alt="湘子门青年旅舍" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0050.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;h3 id="20151231"&gt;2015年12月31日&lt;a class="headerlink" href="#20151231" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  今天是很无聊的一天，我如同朝圣者一般，来回坐了快12个小时的大巴，只为了看一眼世界上最大的黄色瀑布、中国第二大的瀑布——黄河壶口瀑布。&lt;/p&gt;
&lt;p&gt;  早上起来，没有来得及吃早饭，就奔赴纺织城客运站准备乘坐去玩宜川、壶口的车，还好在客运站看到了魏家凉皮，值得尝试一下，味道很特别。&lt;/p&gt;
&lt;p&gt;&lt;img alt="魏家凉皮" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0050_0.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  坐上车就睡着了，睡醒了就看到了陕西窑洞。&lt;/p&gt;
&lt;p&gt;&lt;img alt="壶口路上" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0051.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  陕西以面食闻名天下，到了陕西，当然要尝试下各种面食，所以中午吃的是壶口特色臊子面，说实话，感觉没有大学中陕西人开的面馆里做的好吃。&lt;/p&gt;
&lt;p&gt;&lt;img alt="臊子面" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0052.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  重要的事情说三遍，壶口瀑布真的只有瀑布，真的只有瀑布，真的只有瀑布。&lt;/p&gt;
&lt;p&gt;&lt;img alt="黄河壶口瀑布" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0053.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  当我看到这么大流量的瀑布以及美丽的彩虹，感觉一切的努力都是值得的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="瀑布远景" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0054.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  山西和陕西以黄河为界，所以壶口瀑布也分为陕西景区和山西景区，在陕西景区基本上看不到冰挂，只有从对岸看冰挂才会有一种震撼。&lt;/p&gt;
&lt;p&gt;  到了黄河，真有一种白日依山尽，黄河入海流的真实写照。&lt;/p&gt;
&lt;p&gt;&lt;img alt="黄河流域" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0055.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  黄河瀑布的壮观美丽景象，手机真的拍摄不出来，应该弄个无人机过来，那就太赞了！&lt;/p&gt;
&lt;p&gt;&lt;img alt="瀑布近景1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0056.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="瀑布近景2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0057.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="瀑布近景3" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0058.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  以下就是号称陕西特色羊肉串，谈不上特别好吃，但是最起码是真羊肉！&lt;/p&gt;
&lt;p&gt;&lt;img alt="羊肉串" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0059.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  店家跑了，大串大家随便拿咯！&lt;/p&gt;
&lt;p&gt;&lt;img alt="烤炉" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0060.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  晚上回到西安城，已经9点多了，德发长的饺子宴关门了，只好在大厅里点了三屉蒸饺，自己吃，还有酸汤水饺，酸汤水饺推荐大家尝一下，还是很不错的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="德发长" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0061.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  重要的事情说三遍，回民街逛逛就可以了，回民街逛逛就可以了，回民街逛逛就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="回民街1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0062.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="回民街2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0063.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  一个很逗乐的老外，非要借人家三轮车来骑。&lt;/p&gt;
&lt;p&gt;&lt;img alt="老外在西安" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0064.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  在一个岔道中找到了陕西人比较推荐的老米家大雨泡馍，虽然他家还没有关门，但是刚刚在德发长吃的太多了，到这已经吃不下了，只好下次到西安的时候来尝试一下了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="老米家大雨泡馍" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0065.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;h3 id="201611"&gt;2016年1月1日&lt;a class="headerlink" href="#201611" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  今天早上时间比较宽松，定的旅行团8：30在鼓楼附近集合，所以在旅舍周边找了一家老李家肉夹馍，尝了一下羊肉汤和腊牛肉肉夹馍，真的好好吃，和我们常吃的肉夹馍根本就是两种味道，羊肉汤熬得也很好，基本上没有膻味。&lt;/p&gt;
&lt;p&gt;&lt;img alt="老李家" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0066.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  早起的西安，看起来灰蒙蒙的，到哪都是雾霾，这是我新年中比较郁闷的事了，白天的鼓楼也觉得不如晚上的鼓楼漂亮，但多了一种历史的沧桑感！&lt;/p&gt;
&lt;p&gt;&lt;img alt="早晨的鼓楼" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0067.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  今天行程的第一站，半坡遗址，了解下黄河流域的史前文化。&lt;/p&gt;
&lt;p&gt;&lt;img alt="半坡少女" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0068.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  我个人觉得拍一下墓葬或者陪葬品不是很好，所以只是拍了一些模拟的生活照。&lt;/p&gt;
&lt;p&gt;&lt;img alt="半坡部落1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0069.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="半坡部落2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0070.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="半坡部落3" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0071.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  半坡遗址中最有明的人面鱼尾纹。&lt;/p&gt;
&lt;p&gt;&lt;img alt="人面鱼尾纹" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0072.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  今天第二站就是华清宫，据说是杨贵妃洗澡的地方，这里我感觉是今天去的最无聊的地方。&lt;/p&gt;
&lt;p&gt;&lt;img alt="华清宫大门" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0073.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="华清宫屏风" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0074.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  华清宫中的腊梅，非常的漂亮，我感觉也很幸运，在他乡可以看到已经开放的腊梅。&lt;/p&gt;
&lt;p&gt;&lt;img alt="腊梅1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0075.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="腊梅2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0076.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  据说是周恩来用过的澡堂，在当时算是比较豪华的了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="周恩来浴室" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0077.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  我不会被请去喝茶吧，俺怕怕的！&lt;/p&gt;
&lt;p&gt;&lt;img alt="杨贵妃像" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0078.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  团餐看起来还不错，但是我这要说的是，千万不要报团，说是没有购物，全程无购物，但是用餐时间安排了1个半小时，在路上反复强调蓝田玉有多么多么的好，但是蓝田现在不产玉，不产玉，不产玉。所以如果时间和金钱充足，一定要自己去，直接去秦始皇兵马俑，不要去骊山和华清宫，当然了如果有长恨歌表演，倒可以看看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="团餐" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0078_0.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  铜车马出土的照片，看起来真的很惨，据说兵马俑在历史上遭过两次灾。&lt;/p&gt;
&lt;p&gt;&lt;img alt="铜车马出土" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0079.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  铜车马一号车，做工真的很考究，栩栩如生。&lt;/p&gt;
&lt;p&gt;&lt;img alt="铜车马一号车" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0080.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  铜车马二号车，也是所谓的帝驾，但是这回看到的赝品，正品据说在外巡回展览。&lt;/p&gt;
&lt;p&gt;&lt;img alt="铜车马二号车" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0081.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  秦始皇兵马俑，真的像是1:1制造的，完全找到两个一模一样的佣人，穿戴，面目表情，各式各样，但也有这个1号坑看起来很震撼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="兵马俑1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0082.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="兵马俑2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0083.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="兵马俑3" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0084.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  据说这个是三号坑中唯一一个没有经过修复的佣人，出土是就是这个模样。&lt;/p&gt;
&lt;p&gt;&lt;img alt="跪射俑" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0085.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  三号坑中的军吏俑，据说三号坑是特种部队，一号坑是正规军，二号坑是作战指挥部，说起来还真有些像是那么回事。&lt;/p&gt;
&lt;p&gt;&lt;img alt="军吏俑" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0086.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  骑兵俑&lt;/p&gt;
&lt;p&gt;&lt;img alt="骑兵俑" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0087.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  据说下面这个叫立射俑，刚刚听到的时候，我特别的想笑。&lt;/p&gt;
&lt;p&gt;&lt;img alt="立射俑" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0088.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  下面就是我们的二号坑，也是所谓作战指挥部，也是今天的最后一个景点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="二号坑1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0089.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="二号坑2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0090.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="二号坑3" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0091.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  秦始皇陵，一定要自己去，一定要自己去，一定要自己去，要不会很不爽，全程讲解员都在说蓝田玉怎么怎么的好，你一定要买，要不我就白讲解了！&lt;/p&gt;
&lt;p&gt;  虽然有不开心的地方，但是也有好的，就是当地的火晶柿子饼和甜石榴确实很好吃，这个讲解员推荐的倒还可以，确实是又大又难看又白的石榴是最甜的！&lt;/p&gt;
&lt;p&gt;  回到西安城以后，就要解决下晚饭了，尝了下陕西比较有名的biangbaing麺，在汉民街有一家面麺面里面做的还不错。&lt;/p&gt;
&lt;p&gt;&lt;img alt="biangbaing麺" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0092.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  从汉民街步行回宾馆拿包，路过德福巷，也就是宾馆附近的酒吧一条街。&lt;/p&gt;
&lt;p&gt;&lt;img alt="德福巷" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0093.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  马上就要做机场大巴前往机场乘坐本年第一次的红眼航班回北京了！&lt;/p&gt;
&lt;p&gt;&lt;img alt="机场大巴" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0094.jpg?imageMogr/v2/rotate/90"/&gt;&lt;/p&gt;
&lt;p&gt;  城内晚上感觉雾霾还算可以，或许我只是注意到了城内的繁华吧，但是上了机场高速就明显感觉到了雾霾的严重性，浓见度已经不足2公里。&lt;/p&gt;
&lt;p&gt;&lt;img alt="西安城夜路" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0095.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="西安机场高速" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0096.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;p&gt;  新的一年，第一次红眼航班，第一次乘坐空客A330-243，第一次从西安机场起飞，第一次爬山坐缆车，第一次吃腊牛肉，这次旅途有太多的第一次了，也有太多的回忆了，让我忘记了2015年的忧伤，迎接2016年。&lt;/p&gt;
&lt;p&gt;&lt;img alt="A330-243" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2016/1/Shaanxi/0097.jpg?imageMogr/v2/rotate/0"/&gt;&lt;/p&gt;
&lt;h3 id="_1"&gt;行程花费&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  行程花费预算，远远超标，我自己的预算经费，大概在2000左右，但是最后整个行程下来大概花费在2500左右，已经远远超出预算，看来下回出去玩，真的不能随性，应该好好查查攻略，做好资金预算。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align="center"&gt;项目类型&lt;/th&gt;
&lt;th align="center"&gt;费用&lt;/th&gt;
&lt;th align="center"&gt;占比&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td align="center"&gt;交通费用&lt;/td&gt;
&lt;td align="center"&gt;¥1032.64&lt;/td&gt;
&lt;td align="center"&gt;41.4%&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td align="center"&gt;住宿费用&lt;/td&gt;
&lt;td align="center"&gt;¥105.00&lt;/td&gt;
&lt;td align="center"&gt;4.2%&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td align="center"&gt;景点门票&lt;/td&gt;
&lt;td align="center"&gt;¥813.00&lt;/td&gt;
&lt;td align="center"&gt;32.5%&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td align="center"&gt;美食费用&lt;/td&gt;
&lt;td align="center"&gt;¥266.00&lt;/td&gt;
&lt;td align="center"&gt;10.7%&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td align="center"&gt;其他费用&lt;/td&gt;
&lt;td align="center"&gt;¥281.00&lt;/td&gt;
&lt;td align="center"&gt;11.2%&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_2"&gt;总结&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  不要报名参加西北国旅，不要坐缆车上华山，不要只准备三天就来西安，别的都不重要了。&lt;/p&gt;</summary></entry><entry><title>写给自己，2015年末</title><link href="http://dhlx.wang/Diary/The_end_of_2015_wrote_to_myself.html" rel="alternate"></link><updated>2015-12-26T10:16:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-12-26:Diary/The_end_of_2015_wrote_to_myself.html</id><summary type="html">
&lt;p&gt;  上了大学以后，每年都想要回顾一下这一年的经历，可是每每当我想要提笔，不知道怎么去写，一年拖一年，拖到现在。&lt;/p&gt;
&lt;p&gt;  2015年中，走过许多地方，经历很多事情。许多事情已经遗忘，化作时间长河中的一缕缕金沙。下面我就从四个方面简单的总结下2015年的自己，有好的，也有坏的。权当是给2016年的自己的激励吧！&lt;/p&gt;
&lt;h3 id="_1"&gt;一、从生活上来讲&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  2015年一共365天，只陪父母在家呆了24天，其中春节有11天，元宵节4天，其余时间可以说是基本上没有回过家。虽有古话：父母在，不远游，游必有方。虽说是为了自己的将来在打拼，但这一年中还是感觉没有尽到为人子女的责任，期待来年会有更多的时间来回家敬养父母。&lt;/p&gt;
&lt;p&gt;  在2015年中，我走过8省12市3直辖市，乘坐过22次火车、2次汽车出行和10次飞机。走过的地方多了，认识的朋友也就多了，经历的事情也就多了，对很多的东西也有新的看法。我们明天起床，都是新的一天，不管昨天怎么样，我们都应该快乐的迎接新的一天，不该为了过去的、未来的事情愁眉苦脸，做好当下。&lt;/p&gt;
&lt;p&gt;  2015年中，还看了10多本的书，但多半是些杂书，小说，只有两本有关技术精进的书籍，今年总是抱怨没有时间看书，只有在地铁上的一点时间可以用来看书，今年年初时，我还想着翻译一本外文手册，一直也没有动笔，这是我比较遗憾的事情之一。&lt;/p&gt;
&lt;p&gt;  两天前，我在大学中有些暗恋（或许这种感情是暗恋吧，我也不知道，比朋友多一些，比恋人少一些）的女孩告诉我她有男朋友了。这是我唯一不知道心里是什么感觉的事情，就在几天前，我还在为她挑选一块粉晶，希望她可以在2016年找到她的幸福，但我真正听到她告诉我她有男朋友了，我真的不知道是应该祝福，还是应该懊悔，或许我就像我朋友说的一样吧，永远想的太多了。想我们的家庭、地理上的隔离、对她的一切不了解，不知道她在现在想什么，做什么，吃什么，今天高兴与否，或许正是这些担忧，注定了我们只能做朋友，希望今后，我们不要走着走着就散了。&lt;/p&gt;
&lt;h3 id="_2"&gt;二、从工作上来说&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  2015年，是我做出改变的一年，从边陲之地——哈尔滨来到了帝都——北京，从简单的制作DIY机器人传感器模块，到设计家庭服务机器人的主控板和基本执行程序。&lt;/p&gt;
&lt;p&gt;  在这一年中，虽然学会了许多的东西，但主要是待人接物的处事方法，但我还是喜欢以诚待人，即使被人说成傻子，但我本来也不是很奸，也不是很懂得拒绝别人。还有就是产品的总体设计和扫地机的相关技术，了解了一款产品从最初的模型到成品的不容易，和基本上的几个过程。&lt;/p&gt;
&lt;p&gt;  唯一让我感觉很无奈的事情就是：不知道为什么来到北京之后，感觉自特别忙碌，不知道整日都在忙些什么，春夏秋冬过的特别快，我还以为昨天我刚刚来到北京呢！没有原来在哈尔滨搞设计的成就感，或许感觉上很空虚，实际上还很充实吧！&lt;/p&gt;
&lt;h3 id="_3"&gt;三、从财政上来看&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  2015年的个人的账务，可以说是一个很糟糕的情况，从年初的基本无负债，到现在负债15000多（大部分是JD的12期、24期的无息分期）的严重赤字。我都有些不敢想象一旦我没有了工资了，我要怎么办，我想是时候对我花销方式做出改变和规划了，要不欠账只会越来越多。&lt;/p&gt;
&lt;p&gt;  目前，我想到的方式只有，在买东西的时候，多问自己一句，有必要去花费这些钱来买这些东西吗？在打算出大笔花销的时候，问问自己这么做值得吗？&lt;/p&gt;
&lt;h3 id="_4"&gt;四、从健康上来瞧&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  今天称了下体重，感觉来到北京之后，体重好像有又涨了5公斤，可能和我整日没有运动量，在电脑前干活有关，感觉自己应该适当增加运动量了，不能一天宅在家了。&lt;/p&gt;
&lt;p&gt;  2015年中，还有一件大事，估计就是工作中不慎摔落，导致小臂骨错位，这次受伤估计是我小学毕业以后最严重的一次，估计还得需要2-3个月的休养，胳膊才能恢复正常的使用功能。&lt;/p&gt;
&lt;h3 id="_5"&gt;总结&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  2015，有过欢笑，有过痛苦，现在只剩下4个数字，和数不清的结果，有好的，也有坏的，毕竟都是自己的选择，不曾后悔，问心无愧。&lt;/p&gt;
&lt;p&gt;  2016，我来了！我带着梦想而来！&lt;/p&gt;
&lt;p&gt;  2016，学会拒绝！&lt;/p&gt;
&lt;p&gt;  2016，能做100个俯卧撑！&lt;/p&gt;
&lt;p&gt;  2016，日本，我等你！&lt;/p&gt;
&lt;p&gt;  2016，Led Art！&lt;/p&gt;
&lt;p&gt;  2016，啃下自动化！&lt;/p&gt;
&lt;p&gt;  2016，English，I Love You！&lt;/p&gt;
&lt;p&gt;  2016，110kg！&lt;/p&gt;</summary></entry><entry><title>超频变砖不用怕，自己动手不求人</title><link href="http://dhlx.wang/Computer-Hardware/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself.html" rel="alternate"></link><updated>2015-08-08T18:57:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-08-08:Computer-Hardware/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself.html</id><summary type="html">
&lt;p&gt;人非圣贤，马有失蹄。虽然说NETGEAR 8000刷机和设置过程还是相对安全的，万一遇到断电等不可抗因素和设置过程中误设置，还是有成砖头的危险。一般来说，只要硬件无损坏，不去刷死CFE，都是可以救回来的。&lt;/p&gt;
&lt;p&gt;如何刷DD固件就不在这里说了，直接升级就可以了！想刷回固件也很方便，第一种方法也是采用直接升级就好了，第二种就是下面这种应付各种意外情况的刷机。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://item.taobao.com/item.htm?spm=a1z09.2.9.11.CjhKsM&amp;amp;id=19328552567&amp;amp;_u=8j8md6c6278"&gt;Waveshare FT232 USB to TTL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/"&gt;Putty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://support.netgear.cn/Upfilepath/R8000-V1.0.2.44_1.0.96.chk"&gt;R8000-V1.0.2.44_1.0.96.chk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果遇到上述链接无法访问，请您自行想办法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;友情提示：中国拥有世界上第八大奇迹——长城。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id="tftp"&gt;二、安装TFTP客户端&lt;a class="headerlink" href="#tftp" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这步基本上很简单，按照下面图示操作就好了。&lt;/p&gt;
&lt;p&gt;基本流程就是：找到计算机中的卸载或更改程序（程序和功能），在左侧的打开或关闭Windows功能中，勾选TFTP客户，点击确定就好。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-0" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-0.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-1.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-2.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-3" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-3.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-4" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-4.png"/&gt;&lt;/p&gt;
&lt;h1 id="r8000ttl"&gt;三、拆解R8000，并连接TTL&lt;a class="headerlink" href="#r8000ttl" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;要说明的是，拆解会让你的R8000失去保修。拆掉R8000螃蟹壳上的10壳螺丝，其中有一颗螺丝在贴纸下方，需要揭掉贴纸。并拆掉天线连接，拿出主板，按照下图说明，和买来USB to TTL连接，进入准备刷机的状态。&lt;/p&gt;
&lt;p&gt;P.S. 建议拆机，手接触主板之前，用手摸摸暖气，把自己脱个精光。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-5" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-5.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="putty"&gt;四、设置Putty&lt;a class="headerlink" href="#putty" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、在计算机的设备管理器中检查COM端口，并设置为“115200”，数据位“8”，停止位“1”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-6" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-6.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-7" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-7.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、打开PuTTY，按照下图进行设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-8" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-8.png"/&gt;&lt;/p&gt;
&lt;p&gt;3、回到PuTTY的主页面，选择连接方式为Serial并填入相对的COM端口，传输速率会自动变成之前设置好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-9" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-9.png"/&gt;&lt;/p&gt;
&lt;p&gt;4、运行PuTTY，在R8000未通电开启之前，PuTTY窗口样式为下图。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-10" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-10.png"/&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;五、满血复活&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、插入R8000电源，可以看到Putty界面上会显示一堆初始化，开机信息，这个时候，点进Puttty窗口中，不断的按CTRL-C，终止初始化，进入CFE模式，此时会显示如下信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Startup Canceled
CFE&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、通过以下命令擦除现有固件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;CFE&amp;gt; nvram erase
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、重启R8000&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;CFE&amp;gt; reboot
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、重复1中的动作，再次进入CFE模式。&lt;/p&gt;
&lt;p&gt;5、进入TFTP模式，键入命令后，会出现如下界面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;CFE&amp;gt; tftpd
Start TFTP Server
Reading : :
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、到此路由器设置，完毕，下面我们将网线插入R800的LAN口中，另一端与电脑相连，并在电脑上对以太网属性，进行如下设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-11" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-11.png"/&gt;&lt;/p&gt;
&lt;p&gt;7、以管理员打开命令提示符，并确认R8000进入TFTP模式（TTL = 100）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ping 192.168.1.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8、使用CMD的CD命令定位刚刚下载的CHK文件的所在目录，并执行以下命令上传至R8000。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;tftp -i 192.168.1.1 PUT R8000-V1.0.2.44_1.0.96.chk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9、等待，大概需要3-5分钟，访问192.168.1.1会看到熟悉的界面。&lt;/p&gt;
&lt;h1 id="_3"&gt;六、结束语&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;因为误设置导致R8000变砖，但实际刷完DD-WRT，感觉性能还不如原版固件，不知道是不是因为我设置不对的问题，求大神讲解设置过程。&lt;/p&gt;</summary><category term="NETGEAR 8000"></category><category term="路由"></category><category term="超频"></category></entry><entry><title>吴军《浪潮之巅》书评</title><link href="http://dhlx.wang/Book_Review/On_Top_of_Tides.html" rel="alternate"></link><updated>2015-07-21T17:39:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-07-21:Book_Review/On_Top_of_Tides.html</id><summary type="html">
&lt;p&gt;  这本书读完有一段时间了，一直不知道怎么把它推荐给大家，其中虽没有光怪陆离的世界，但有互联网过去几十年的发展历程，或许其中带有一些作者的主观色彩，但总体来说还是以局外人纪实写些发生的事情，初起的时候，我并不是很喜欢这本书，但读着读着，我也喜欢这本书的叙事风格，平实不乏有趣，又了解了IT行业的历史和更迭。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、您在哪里可以找到它&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  1、&lt;a href="http://googlechinablog.blogspot.com/search?q=%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85"&gt;google的黑板报&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  2、&lt;a href="http://www.amazon.cn/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85-%E5%90%B4%E5%86%9B/dp/B00D73BJWK/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1437470867&amp;amp;sr=1-1&amp;amp;keywords=%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85"&gt;亚马逊&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;二、这本书写了些什么&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  计算机领域的发展在吴军看来是一波波的浪潮，幸运的公司可以借浪前行，但更多的是在大海深处长眠。互联网、计算机使得时间变短，也就意味着技术更迭加快，浪潮的时间短，三年河东三年河西，变为了现实，记得我刚上高中时，我都不知道iphone是什么品牌，只知道诺基亚和三星，三年过后，我拿着iphone进入到大学中，同学都问我这是什么手机，当时很多人真的只是喜欢iphone的简洁易用，现在iphone已经满大街都是，已经成了一款装逼利器，很少见到有人能用明白iphone，100%发挥其功能的，但不管怎么说，Apple公司在智能手持终端这个浪潮中赚的盆满钵满。&lt;/p&gt;
&lt;p&gt;  这本书也是详细讲诉了浪潮的形成原因、过程，和过往的公司的丰功伟绩、过失。详细的展现了IT领域的70-20-10的规律，就是在一个细分的市场，往往只能容下一家大的，占有7成的市场份额，还有一家老二，占有2成的份额，其它的若干公司，只能分剩下的1成份额。赢者通吃，在IT领域显现的尤为明显。所以如果做不成老大，是很难办的。就像今天的云服务、大数据、机器人、无人机等行业，百家争鸣，确实热闹，我们都能看到这是未来发展的趋势，但无限的机会中并不代表你就可以借浪前行。 
　　 
  这时你会问，传统的巨头就这么看着你们蚕食它们的市场吗？答案很明显，是已经固化的基因和思维阻挡了他们的前行的脚步，就像人的性格和思维很难改变一样，公司的基因和思维方式也是很难改变的。在吴军的书中是这么写的：一个公司在一个领域越成功，它积累的文化、做事方式、流程、决策机制等，越适合这一个领域，那么在面对新市场时，越扭转不过来思维。&lt;/p&gt;
&lt;p&gt;  书中描述了一波波浪潮的特征。但就像说人这一辈子一样，虽然生来含着金汤匙，但不是一辈子就能永远顺风顺水。公司的发展不可能只靠浪潮来推进，这样的公司也做不大。管理、创始人的个人能力、资源等等，都是影响到一个公司的未来发展的者重要因素。但了解浪潮，可以避免自己在择业、创业过程中不要做出不自量力的事。 
　　 &lt;/p&gt;
&lt;h1 id="_3"&gt;三、我了解到了什么&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;“读史使人明智”，这句话不是白说的，至少我了解了一些大公司的过往，所谓的天使投资、风投等一些经济常识。这本可以说是IT界的《史记》，从过往的公司，历史留名的人物，描述了一个IT时代历史。当然，由于作者的时间和学识有限，从中了解历史十分有限，不够详细，很多时候要查一些资料才能更了解当时的情况，但大纲讲的已经比较清晰明了。&lt;/p&gt;
&lt;p&gt;最后，值得说的是，吴军的文笔实在太好了，读起他的文字完全是一种享受，很平实，很靠谱。&lt;/p&gt;</summary><category term="浪潮之巅"></category><category term="吴军"></category><category term="纪实"></category></entry><entry><title>雷米《心理罪》系列书评</title><link href="http://dhlx.wang/Book_Review/Psychological_Crime.html" rel="alternate"></link><updated>2015-07-18T17:39:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-07-18:Book_Review/Psychological_Crime.html</id><summary type="html">
&lt;p&gt;  好像从初中毕业后，也看过不少的书籍，有专业书籍，也有小说、散文等，但好像从初中毕业以后就没有写过读后感和书评了。今天把雷米写的心理罪系列的小说看完了，忽然想要写下我自己的书评，或许这个系列小说，给我的印象太深刻了吧！即使您不是一个喜欢看犯罪类、刑侦类小说的人，我个人也建议您有时间可以看下，您会喜欢上心理罪的。&lt;/p&gt;
&lt;p&gt;  &lt;a href="http://www.amazon.cn/dp/B00VSXL066/ref=tmm_kin_swatch_0?_encoding=UTF8&amp;amp;sr=8-1&amp;amp;qid=1437210148"&gt;心理罪&lt;/a&gt;，我个人认为是值得为之付出RMB的，故在此给出正版书籍的购买链接，希望大家可以支持下作者。&lt;/p&gt;
&lt;p&gt;  如果您的资金有限，又想赏读大师之作，你可以通过&lt;a href="http://pan.baidu.com/s/1AZo6q"&gt;百度网盘链接&lt;/a&gt;和密码(qshi)进行下载阅读试看，但个人真心希望您在看完免费的以后，会和我一样，购买一套正版书籍进行收藏。&lt;/p&gt;
&lt;p&gt;  不管您是否购买了正版书籍，您都应当下载下电子版的书籍，因为电子版中有四篇番外篇不曾出版，这四篇番外篇会帮助您更好的理解心理罪。以下是我推荐给您的心理罪系列小说的阅读顺序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;1、前传 第七个读者
2、番外一 毒树之果
3、心理罪一 画像
4、番外二 斯金纳之箱
5、心理罪二 教化场
6、番外三 月光的谎言
7、心理罪三 暗河
8、心理罪四 城市之光
9、番外四 两生花
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  心理罪系列小说既是连贯的，也是独立的。说它是连贯的，是因为这部小说，您必须从第一部开始都，才能真正的体会到作者对人性的理解。说它是各部分是独立的，是因为每部小说中发生的案件，与前后会有一些关联，单都可以独立成文，案件前后并无悬念。&lt;/p&gt;
&lt;p&gt;  主人公：方木，天才犯罪心理学家，也是一个悲剧的猪脚，或许天生自带灾难光环吧。但不影响我们看出他的个性以及天赋，在大学中就连破大案，看透人性。但随着时间和案件的发展，他的信仰摇摇欲坠，作者赋予他了破案的天赋，但缺利用这种天赋塑造了一个悲剧的开始，和一个还算美好的轮回。&lt;/p&gt;
&lt;p&gt;  或许很长时间没有写书评了，都不会写内容的简介了，那我再此也不要献丑了，详细的内容，还是由大家自己去看心理罪的书籍吧！我这里只能说，光明不存在，存在的或许只是黑暗中一盏指路的明灯。或许悲观，或许有些宗教，但是我们不正是这样劝自己活着幸福就好，但幸福是什么，谁也说不清，道不明。&lt;/p&gt;
&lt;p&gt;  看完本书之后，我只想说世上多是轮回，在罪恶之深处的轮回。也许没有他方木，就不会带来这么多死亡…… &lt;/p&gt;
&lt;p&gt;  最后说下，我推荐心理罪的原因吧，原因有三，一是非常好的犯罪小说，二是它同时也是一部非常好的悬疑小说，三是来看看这个叫方木这个男人吧！&lt;/p&gt;
&lt;p&gt;  感谢雷米（lane_lau）大侠给了我这么一本书，这么一个让我可以经历不同人生的书。我最喜欢的一句话就是一段光影，一段人生，我想现在我可以将它改为一段光阴，一段人生，一部书籍，一个世界。&lt;/p&gt;</summary><category term="心理罪"></category><category term="雷米"></category><category term="方木"></category></entry><entry><title>基于STM32CubeF4移植FreeModbus到STM32F411VET6</title><link href="http://dhlx.wang/STM32F411VET6/Porting_FreeModbus_to_STM32F411VET6_based_on_STM32CubeF4.html" rel="alternate"></link><updated>2015-07-06T17:35:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-07-06:STM32F411VET6/Porting_FreeModbus_to_STM32F411VET6_based_on_STM32CubeF4.html</id><summary type="html">
&lt;p&gt;首先，本人需要声明一下，本文所移植FreeModbus的过程仅能用作参考，虽然FreeModbus的库已经用在工程很多年，但是由于移植的代码，本人经验等问题，所以本人不建议您直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备移植程序和工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我在此次移植过程中，主要用到以下几个程序与工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1848/PF260946?s_searchtype=partnumber"&gt;32F411EDISCOVERY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.freemodbus.org/"&gt;FreeModbus v1.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.modbustools.com/"&gt;Modbus Poll v6.3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1533/PF259242?sc=stm32cube"&gt;STM32CubeMX_V4.8.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/en/catalog/tools/PF259243"&gt;STM32Cube_FW_F4_V1.6.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.keil.com/download/product/"&gt;Keil_MDK_ARM_V5.15.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在移植过程中，主要用到芯片的外设有USART1（PB6、PB7）和TIMER11，请您根据实际情况进行设置。其中TIMER的设置，您需要设置时钟的信号基准为50uS，时钟产生中断的时间为1750uS（串口波特率大于19200时，在mbrtu.c中有具体的描述），也就是35个基准时间。&lt;/p&gt;
&lt;h1 id="_2"&gt;二、拷贝需要的文件到工程目录下&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、解压缩通过下载得到的freemodbus-v1.5.zip。&lt;/p&gt;
&lt;p&gt;2、按照下列的文件列表拷贝相应的文件到对应的目录（没有路径，需要自己建），并在
keil中设置好相应的头文件引用路径和源码文件的引用。&lt;/p&gt;
&lt;p&gt;拷贝文件到工程文件夹示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;工程文件夹&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;mxproject&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;工程名&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ioc&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  
&lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;Drivers&lt;/span&gt;                         &lt;span class="c1"&gt;//底层驱动文件夹&lt;/span&gt;
&lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;Inc&lt;/span&gt;                             &lt;span class="c1"&gt;//头文件存放位置&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;gpio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;stm32f4xx_hal_conf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;stm32f4xx_it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;tim&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;usart&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;Modbus&lt;/span&gt;                      &lt;span class="c1"&gt;//Modbus需要用到的头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;modbus_driver&lt;/span&gt;           &lt;span class="c1"&gt;//Modbus函数等头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;include&lt;/span&gt;              &lt;span class="c1"&gt;//Modbus通用函数头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;            
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbconfig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;      
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbframe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfunc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbport&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbproto&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbutils&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;rtu&lt;/span&gt;                  &lt;span class="c1"&gt;//Modbus RTU函数头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;          &lt;span class="nx"&gt;mbcrc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;          &lt;span class="nx"&gt;mbrtu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;          
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;modbus_user&lt;/span&gt;             &lt;span class="c1"&gt;//Modbus用户配置头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;              &lt;span class="nx"&gt;port&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;              
&lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;MDK&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;ARM&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;BPEER_USART_TEST&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;uvprojx&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      
&lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;Src&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;gpio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;stm32f4xx_hal_msp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;stm32f4xx_it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;tim&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;usart&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;      
    &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;Modbus&lt;/span&gt;                      &lt;span class="c1"&gt;//Modbus需要用到的源码文件&lt;/span&gt;
        &lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;modbus_driver&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;                &lt;span class="c1"&gt;//Modbus基本函数和设置源码文件&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;functions&lt;/span&gt;            &lt;span class="c1"&gt;//Modbus通用函数源码文件&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfunccoils&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncdiag&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncdisc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncholding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncinput&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncother&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbutils&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;rtu&lt;/span&gt;                  &lt;span class="c1"&gt;//Modbus RTU函数源码文件&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;          &lt;span class="nx"&gt;mbcrc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;          &lt;span class="nx"&gt;mbrtu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;          
        &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;modbus_user&lt;/span&gt;             &lt;span class="c1"&gt;//Modbus用户配置源码文件&lt;/span&gt;
                &lt;span class="nx"&gt;portevent&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
                &lt;span class="nx"&gt;portserial&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
                &lt;span class="nx"&gt;porttimer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="timer"&gt;三、搞定Timer&lt;a class="headerlink" href="#timer" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Timer的移植过程中，应该算是比较简单的了，需要简单的设置一下初始化的返回值，完整写出开启Timer的函数，停止Timer的函数，并对Timer回掉函数进行设置下，就OK了。&lt;/p&gt;
&lt;p&gt;porttimer.c移植后的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* ----------------------- Platform includes ----------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "port.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "tim.h"&lt;/span&gt;
&lt;span class="cm"&gt;/* ----------------------- Modbus includes ------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "mb.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "mbport.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* ----------------------- static functions -----------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* ----------------------- Private define -------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef Modbus_TimHandle&lt;/span&gt;
    &lt;span class="cp"&gt;#define Modbus_TimHandle htim11&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cm"&gt;/* ----------------------- Start implementation -------------------------*/&lt;/span&gt;
&lt;span class="n"&gt;BOOL&lt;/span&gt;
&lt;span class="nf"&gt;xMBPortTimersInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usTim1Timerout50us&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*系统初始化已经完成定时器的初始化，故在此不在进行初始化*/&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;vMBPortTimersEnable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Enable the timer with the timeout passed to xMBPortTimersInit( ) */&lt;/span&gt;
    &lt;span class="cm"&gt;/*Disable Timer and Reset Counter*/&lt;/span&gt;
    &lt;span class="n"&gt;HAL_TIM_Base_Stop_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_TimHandle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__HAL_TIM_SET_COUNTER&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_TimHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x0000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/*Enable Timer*/&lt;/span&gt;
    &lt;span class="n"&gt;HAL_TIM_Base_Start_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_TimHandle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;vMBPortTimersDisable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Disable any pending timers. */&lt;/span&gt;   
    &lt;span class="n"&gt;HAL_TIM_Base_Stop_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_TimHandle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Create an ISR which is called whenever the timer has expired. This function&lt;/span&gt;
&lt;span class="cm"&gt; * must then call pxMBPortCBTimerExpired( ) to notify the protocol stack that&lt;/span&gt;
&lt;span class="cm"&gt; * the timer has expired.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvTIMERExpiredISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;pxMBPortCBTimerExpired&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;stm32f4xx_it.c移植后的部分代码如下所示：
    #!c
    /&lt;em&gt; Includes ------------------------------------------------------------------&lt;/em&gt;/
    #include "stm32f4xx_hal.h"
    #include "stm32f4xx.h"
    #include "stm32f4xx_it.h"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* USER CODE BEGIN 0 */&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;include&lt;/span&gt; &lt;span class="s2"&gt;"mb.h"&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;include&lt;/span&gt; &lt;span class="s2"&gt;"mbport.h"&lt;/span&gt;

&lt;span class="nx"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;prvvUARTRxISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;prvvTIMERExpiredISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* USER CODE END 0 */&lt;/span&gt;
&lt;span class="err"&gt;……&lt;/span&gt; &lt;span class="err"&gt;……&lt;/span&gt; &lt;span class="err"&gt;……&lt;/span&gt;
&lt;span class="cm"&gt;/* USER CODE BEGIN 1 */&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;HAL_TIM_PeriodElapsedCallback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;TIM_HandleTypeDef&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;htim&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* NOTE : This function Should not be modified, when the callback is needed,&lt;/span&gt;
&lt;span class="cm"&gt;            the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="nx"&gt;prvvTIMERExpiredISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cm"&gt;/* USER CODE END 1 */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_3"&gt;四、搞定串口&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;串口比较难搞一些了，需要设置中断处理函数、串口初始化函数、串口输入输出函数、串口中断服务函数。&lt;/p&gt;
&lt;p&gt;portserial.c移植后的代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include "port.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_it.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* ----------------------- Modbus includes ------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "mb.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "mbport.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* ----------------------- static functions -----------------------------*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvUARTRxISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* ----------------------- Private define -------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef Modbus_UartHandle&lt;/span&gt;
    &lt;span class="cp"&gt;#define Modbus_UartHandle huart1&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cm"&gt;/* ----------------------- Start implementation -------------------------*/&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;vMBPortSerialEnable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;xRxEnable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;xTxEnable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* If xRXEnable enable serial receive interrupts. If xTxENable enable&lt;/span&gt;
&lt;span class="cm"&gt;     * transmitter empty interrupts.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;xRxEnable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Enable the UART Data Register not empty Interrupt */&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_UART_ENABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_RXNE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Disable the UART Data Register not empty Interrupt */&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_UART_DISABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_RXNE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;xTxEnable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Enable the UART Transmit data register empty Interrupt */&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_UART_ENABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_TXE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Disable the UART Transmit data register empty Interrupt */&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_UART_DISABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_TXE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="cm"&gt;/* Enable the UART Transmit Complete Interrupt */&lt;/span&gt;    
        &lt;span class="n"&gt;__HAL_UART_ENABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_TC&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt;
&lt;span class="nf"&gt;xMBPortSerialInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucPORT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ULONG&lt;/span&gt; &lt;span class="n"&gt;ulBaudRate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucDataBits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;eMBParity&lt;/span&gt; &lt;span class="n"&gt;eParity&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*由于已经在系统初始化中已经完成串口初始化，故在此不需要再一次进行初始化*/&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt;
&lt;span class="nf"&gt;xMBPortSerialPutByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;CHAR&lt;/span&gt; &lt;span class="n"&gt;ucByte&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Put a byte in the UARTs transmit buffer. This function is called&lt;/span&gt;
&lt;span class="cm"&gt;     * by the protocol stack if pxMBFrameCBTransmitterEmpty( ) has been&lt;/span&gt;
&lt;span class="cm"&gt;     * called. */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAL_UART_Transmit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt; &lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ucByte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt;
&lt;span class="nf"&gt;xMBPortSerialGetByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;CHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucByte&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Return the byte in the UARTs receive buffer. This function is called&lt;/span&gt;
&lt;span class="cm"&gt;     * by the protocol stack after pxMBFrameCBByteReceived( ) has been called.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAL_UART_Receive&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt; &lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;pucByte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Create an interrupt handler for the transmit buffer empty interrupt&lt;/span&gt;
&lt;span class="cm"&gt; * (or an equivalent) for your target processor. This function should then&lt;/span&gt;
&lt;span class="cm"&gt; * call pxMBFrameCBTransmitterEmpty( ) which tells the protocol stack that&lt;/span&gt;
&lt;span class="cm"&gt; * a new character can be sent. The protocol stack will then call &lt;/span&gt;
&lt;span class="cm"&gt; * xMBPortSerialPutByte( ) to send the character.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pxMBFrameCBTransmitterEmpty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Create an interrupt handler for the receive interrupt for your target&lt;/span&gt;
&lt;span class="cm"&gt; * processor. This function should then call pxMBFrameCBByteReceived( ). The&lt;/span&gt;
&lt;span class="cm"&gt; * protocol stack will then call xMBPortSerialGetByte( ) to retrieve the&lt;/span&gt;
&lt;span class="cm"&gt; * character.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvUARTRxISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pxMBFrameCBByteReceived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;stm32f4xx_it.c移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief This function handles USART1 global interrupt.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;USART1_IRQHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE BEGIN USART1_IRQn 0 */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__HAL_UART_GET_IT_SOURCE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;huart1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_RXNE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;RESET&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;prvvUARTRxISR&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//接收中断处理函数&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__HAL_UART_GET_IT_SOURCE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;huart1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_TXE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;RESET&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//发送完成终端处理函数&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;HAL_NVIC_ClearPendingIRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USART1_IRQn&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE END USART1_IRQn 0 */&lt;/span&gt;
  &lt;span class="n"&gt;HAL_UART_IRQHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;huart1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE BEGIN USART1_IRQn 1 */&lt;/span&gt;

  &lt;span class="cm"&gt;/* USER CODE END USART1_IRQn 1 */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="_4"&gt;五、搞定其他配置&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、搞定开关中断操作&lt;/p&gt;
&lt;p&gt;port.h移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*禁用全部中断*/&lt;/span&gt;
&lt;span class="cp"&gt;#define ENTER_CRITICAL_SECTION( )   __disable_irq()&lt;/span&gt;
&lt;span class="cm"&gt;/*开启全部中断*/&lt;/span&gt;
&lt;span class="cp"&gt;#define EXIT_CRITICAL_SECTION( )    __enable_irq()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;2、搞定系统配置&lt;/p&gt;
&lt;p&gt;mb.c移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*设置启用Modbus RTU 模式，减少编译后的代码量*/&lt;/span&gt;
&lt;span class="cp"&gt;#if MB_RTU_ENABLED == 1&lt;/span&gt;
    &lt;span class="cp"&gt;#include "mbrtu.h"&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cm"&gt;/*减少编译后代码错误以及修改，将判定值由1改为0，并修改MB_ASCII_ENABLED的定义为0，&lt;/span&gt;
&lt;span class="cm"&gt;想要了解原因，请自行修改编译查看*/&lt;/span&gt;
&lt;span class="cp"&gt;#if MB_ASCII_ENABLED == 1&lt;/span&gt;
    &lt;span class="cp"&gt;#include "mbascii.h"&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cm"&gt;/*减少编译后代码大小，将判定值由0改为1，并修改MB_TCP_ENABLED的定义为0，想要了解&lt;/span&gt;
&lt;span class="cm"&gt;原因，请自行修改编译查看*/&lt;/span&gt;
&lt;span class="cp"&gt;#if MB_TCP_ENABLED == 1&lt;/span&gt;
    &lt;span class="cp"&gt;#include "mbtcp.h"&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;3、搞定寄存器地址差一的问题&lt;/p&gt;
&lt;p&gt;需要在源码中注释掉所有的&lt;code&gt;usRegAddress++;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;4、搞定keil编译过程中出现的各种警告&lt;/p&gt;
&lt;p&gt;mb.h移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;xMBUtilSetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ucByteBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucNBits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
                &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucValue&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt;
&lt;span class="nf"&gt;xMBUtilGetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ucByteBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucNBits&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;mbrtu.c移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRTUReceive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRcvAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;pucFrame&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pusLength&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*处女座心理，必须要求无错误、无警告、可过PC-Lint，目前也没有发现这个定义的用处*/&lt;/span&gt;
    &lt;span class="c1"&gt;//    BOOL            xFrameReceived = FALSE;&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;    &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;ENTER_CRITICAL_SECTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usRcvBufferPos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;MB_SER_PDU_SIZE_MAX&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Length and CRC check */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usRcvBufferPos&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_SER_PDU_SIZE_MIN&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usMBCRC16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usRcvBufferPos&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Save the address field. All frames are passed to the upper layed&lt;/span&gt;
&lt;span class="cm"&gt;         * and the decision if a frame is used is done there.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRcvAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MB_SER_PDU_ADDR_OFF&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

        &lt;span class="cm"&gt;/* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus&lt;/span&gt;
&lt;span class="cm"&gt;         * size of address field and CRC checksum.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pusLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRcvBufferPos&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;MB_SER_PDU_PDU_OFF&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;MB_SER_PDU_SIZE_CRC&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* Return the start of the Modbus PDU to the caller. */&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucFrame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MB_SER_PDU_PDU_OFF&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;//        xFrameReceived = TRUE;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_EIO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;EXIT_CRITICAL_SECTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;5、未知原因的添加代码&lt;/p&gt;
&lt;p&gt;这部分代码没有明白，为什么需要添加，有些没有研究透，希望有大神可以指点。&lt;/p&gt;
&lt;p&gt;mbrtu.c移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRTUSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucSlaveAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucFrame&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usLength&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;    &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;USHORT&lt;/span&gt;          &lt;span class="n"&gt;usCRC16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;ENTER_CRITICAL_SECTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Check if the receiver is still in idle state. If not we where to&lt;/span&gt;
&lt;span class="cm"&gt;     * slow with processing the received frame and the master sent another&lt;/span&gt;
&lt;span class="cm"&gt;     * frame on the network. We have to abort sending the frame.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;eRcvState&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;STATE_RX_IDLE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* First byte before the Modbus-PDU is the slave address. */&lt;/span&gt;
        &lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pucFrame&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;usSndBufferCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */&lt;/span&gt;
        &lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MB_SER_PDU_ADDR_OFF&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ucSlaveAddress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;usSndBufferCount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;usLength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */&lt;/span&gt;
        &lt;span class="n"&gt;usCRC16&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;usMBCRC16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usSndBufferCount&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;usSndBufferCount&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usCRC16&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;usSndBufferCount&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usCRC16&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* Activate the transmitter. */&lt;/span&gt;
        &lt;span class="n"&gt;eSndState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STATE_TX_XMIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/*插入代码 启动第一次发送，这样才可以进入发送完成中断*/&lt;/span&gt;
        &lt;span class="n"&gt;xMBPortSerialPutByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;CHAR&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
        &lt;span class="n"&gt;usSndBufferCount&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;vMBPortSerialEnable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_EIO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;EXIT_CRITICAL_SECTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="_5"&gt;六、搞定主函数&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;主函数需要设置数组和处理函数，无其他设置，我放上我移植的代码以供参考。&lt;/p&gt;
&lt;p&gt;main.c移植后的代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "adc.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "tim.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "gpio.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN Includes */&lt;/span&gt;

&lt;span class="cp"&gt;#include "mb.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "mbport.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END Includes */&lt;/span&gt;

&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN PV */&lt;/span&gt;

&lt;span class="cm"&gt;/*线圈状态寄存器*/&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_COILS_START 0x0000&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_COILS_SIZE 8&lt;/span&gt;

&lt;span class="cm"&gt;/*线圈状态输入寄存器*/&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_DISCRETE_START 0x0000&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_DISCRETE_SIZE 8&lt;/span&gt;

&lt;span class="cm"&gt;/*保持寄存器*/&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_HOLDING_START 0x0000&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_HOLDING_NREGS 10&lt;/span&gt;

&lt;span class="cm"&gt;/*输入寄存器*/&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_INPUT_START 0x0000&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_INPUT_NREGS 1&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END PV */&lt;/span&gt;

&lt;span class="cm"&gt;/* Private function prototypes ------------------------------------------*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SystemClock_Config&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN PFP */&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END PFP */&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN 0 */&lt;/span&gt;

&lt;span class="cm"&gt;/*定义线圈状态寄存器的地址起始值和存储数组*/&lt;/span&gt;
&lt;span class="kt"&gt;uint8_t&lt;/span&gt;   &lt;span class="n"&gt;ucRegCoilsStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;uint8_t&lt;/span&gt;   &lt;span class="n"&gt;ucRegCoilsBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;REG_COILS_SIZE&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/*定义线圈输入状态寄存器的地址起始值和存储数组*/&lt;/span&gt;
&lt;span class="kt"&gt;uint8_t&lt;/span&gt;   &lt;span class="n"&gt;ucRegDiscreteStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;uint8_t&lt;/span&gt;   &lt;span class="n"&gt;ucRegDiscreteBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;REG_DISCRETE_SIZE&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/*定义保持寄存器的地址起始值和存储数组*/&lt;/span&gt;
&lt;span class="kt"&gt;uint16_t&lt;/span&gt;   &lt;span class="n"&gt;usRegHoldingStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;uint16_t&lt;/span&gt;   &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;REG_HOLDING_NREGS&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/*定义输入寄存器的地址起始值和存储数组*/&lt;/span&gt;
&lt;span class="kt"&gt;uint16_t&lt;/span&gt;   &lt;span class="n"&gt;usRegInputStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_INPUT_START&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;uint16_t&lt;/span&gt;   &lt;span class="n"&gt;usRegInputBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;REG_INPUT_NREGS&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END 0 */&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE BEGIN 1 */&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE END 1 */&lt;/span&gt;

    &lt;span class="cm"&gt;/* MCU Configuration-------------------------------------------------*/&lt;/span&gt;

    &lt;span class="cm"&gt;/* Reset of all peripherals, Initializes the Flash interface and the Systick. */&lt;/span&gt;
    &lt;span class="n"&gt;HAL_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* Configure the system clock */&lt;/span&gt;
    &lt;span class="n"&gt;SystemClock_Config&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* Initialize all configured peripherals */&lt;/span&gt;
    &lt;span class="n"&gt;MX_GPIO_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_ADC1_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_TIM1_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_TIM4_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_TIM11_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_USART1_UART_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE BEGIN 2 */&lt;/span&gt;

    &lt;span class="cm"&gt;/*设置Modnbus以RTU模式运行，从机ID为0x01，串口为默认串口，串口波特率为115200，无奇偶校验*/&lt;/span&gt;
    &lt;span class="n"&gt;eMBInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MB_RTU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;115200&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MB_PAR_NONE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Enable the Modbus Protocol Stack. */&lt;/span&gt;
    &lt;span class="n"&gt;eMBEnable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="cm"&gt;/* USER CODE END 2 */&lt;/span&gt;

    &lt;span class="cm"&gt;/* Infinite loop */&lt;/span&gt;
    &lt;span class="cm"&gt;/* USER CODE BEGIN WHILE */&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;eMBPoll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_TIM_SetCompare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TIM_CHANNEL_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_TIM_SetCompare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TIM_CHANNEL_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_TIM_SetCompare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TIM_CHANNEL_3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_TIM_SetCompare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TIM_CHANNEL_4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;HAL_TIM_PWM_Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIM_CHANNEL_1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;HAL_TIM_PWM_Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIM_CHANNEL_2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;HAL_TIM_PWM_Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIM_CHANNEL_3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;HAL_TIM_PWM_Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIM_CHANNEL_4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE END WHILE */&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE BEGIN 3 */&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cm"&gt;/* USER CODE END 3 */&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/** System Clock Configuration&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SystemClock_Config&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="n"&gt;RCC_OscInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;__PWR_CLK_ENABLE&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="n"&gt;__HAL_PWR_VOLTAGESCALING_CONFIG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PWR_REGULATOR_VOLTAGE_SCALE2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OscillatorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_OSCILLATORTYPE_HSI&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HSIState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_HSI_ON&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HSICalibrationValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_PLL_ON&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_PLLSOURCE_HSI&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_PLLP_DIV4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLQ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;HAL_RCC_OscConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClockType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_CLOCKTYPE_SYSCLK&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;RCC_CLOCKTYPE_PCLK1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SYSCLKSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_SYSCLKSOURCE_PLLCLK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AHBCLKDivider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_SYSCLK_DIV1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;APB1CLKDivider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_HCLK_DIV2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;APB2CLKDivider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_HCLK_DIV1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;HAL_RCC_ClockConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FLASH_LATENCY_3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;HAL_SYSTICK_Config&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAL_RCC_GetHCLKFreq&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;HAL_SYSTICK_CLKSourceConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SYSTICK_CLKSOURCE_HCLK&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN 4 */&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief 输入寄存器处理函数，输入寄存器可读，但不可写。&lt;/span&gt;
&lt;span class="cm"&gt;* @param pucRegBuffer 返回数据指针&lt;/span&gt;
&lt;span class="cm"&gt;* usAddress 寄存器起始地址&lt;/span&gt;
&lt;span class="cm"&gt;* usNRegs 寄存器长度&lt;/span&gt;
&lt;span class="cm"&gt;* @retval eStatus 寄存器状态&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRegInputCB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;    &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt;             &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;//  用作例子&lt;/span&gt;
    &lt;span class="n"&gt;usRegInputBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//  例子结束&lt;/span&gt;

    &lt;span class="c1"&gt;//查询是否在寄存器范围内&lt;/span&gt;
    &lt;span class="c1"&gt;//为了避免警告，修改为有符号整数&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_INPUT_START&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; \
        &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;REG_INPUT_START&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;REG_INPUT_NREGS&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//获得操作偏移量，本次操作起始地址-输入寄存器的初始地址&lt;/span&gt;
        &lt;span class="n"&gt;iRegIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;usRegInputStart&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;//逐个赋值&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//赋值高字节&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRegInputBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="c1"&gt;//赋值低字节&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRegInputBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="c1"&gt;//偏移量增加&lt;/span&gt;
            &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;//被操作寄存器数量递减&lt;/span&gt;
            &lt;span class="n"&gt;usNRegs&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//返回错误状态，寄存器数量不对&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOREG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief 保持寄存器处理函数，保持寄存器可读，可读可写&lt;/span&gt;
&lt;span class="cm"&gt;* @param pucRegBuffer 读操作时--返回数据指针，写操作时--输入数据指针&lt;/span&gt;
&lt;span class="cm"&gt;* usAddress 寄存器起始地址&lt;/span&gt;
&lt;span class="cm"&gt;* usNRegs 寄存器长度&lt;/span&gt;
&lt;span class="cm"&gt;* eMode 操作方式，读或者写&lt;/span&gt;
&lt;span class="cm"&gt;* @retval eStatus 寄存器状态&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt; 
&lt;span class="nf"&gt;eMBRegHoldingCB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;eMBRegisterMode&lt;/span&gt; &lt;span class="n"&gt;eMode&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//错误状态&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//偏移量&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//判断寄存器是不是在范围内&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; \
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_NREGS&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//计算偏移量&lt;/span&gt;
        &lt;span class="n"&gt;iRegIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;eMode&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//读处理函数 &lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;MB_REG_READ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;usNRegs&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="c1"&gt;//写处理函数 &lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;MB_REG_WRITE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;usNRegs&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//返回错误状态&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOREG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief 线圈寄存器处理函数，线圈寄存器可读，可读可写&lt;/span&gt;
&lt;span class="cm"&gt;* @param pucRegBuffer 读操作---返回数据指针，写操作--返回数据指针&lt;/span&gt;
&lt;span class="cm"&gt;* usAddress 寄存器起始地址&lt;/span&gt;
&lt;span class="cm"&gt;* usNRegs 寄存器长度&lt;/span&gt;
&lt;span class="cm"&gt;* eMode 操作方式，读或者写&lt;/span&gt;
&lt;span class="cm"&gt;* @retval eStatus 寄存器状态&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRegCoilsCB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usNCoils&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;eMBRegisterMode&lt;/span&gt; &lt;span class="n"&gt;eMode&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//错误状态&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//寄存器个数&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usNCoils&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//寄存器偏移量&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//检查寄存器是否在指定范围内&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_COILS_START&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;REG_COILS_START&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;REG_COILS_SIZE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//计算寄存器偏移量&lt;/span&gt;
        &lt;span class="n"&gt;usBitOffset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REG_COILS_START&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;eMode&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//读操作&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;MB_REG_READ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xMBUtilGetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;ucRegCoilsBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;usBitOffset&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="c1"&gt;//写操作&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;MB_REG_WRITE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;xMBUtilSetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;ucRegCoilsBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="p"&gt;),&lt;/span&gt;
                    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOREG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief 开关输入寄存器处理函数，开关输入寄存器，可读&lt;/span&gt;
&lt;span class="cm"&gt;* @param pucRegBuffer 读操作---返回数据指针，写操作--返回数据指针&lt;/span&gt;
&lt;span class="cm"&gt;* usAddress 寄存器起始地址&lt;/span&gt;
&lt;span class="cm"&gt;* usNRegs 寄存器长度&lt;/span&gt;
&lt;span class="cm"&gt;* eMode 操作方式，读或者写&lt;/span&gt;
&lt;span class="cm"&gt;* @retval eStatus 寄存器状态&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRegDiscreteCB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usNDiscrete&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//错误状态&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//操作寄存器个数&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usNDiscrete&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//偏移量&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//判断寄存器时候再制定范围内&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_DISCRETE_START&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usNDiscrete&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;REG_DISCRETE_START&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;REG_DISCRETE_SIZE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//获得偏移量&lt;/span&gt;
        &lt;span class="n"&gt;usBitOffset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REG_DISCRETE_START&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xMBUtilGetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;ucRegDiscreteBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;usBitOffset&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOREG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END 4 */&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef USE_FULL_ASSERT&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * @brief Reports the name of the source file and the source line number&lt;/span&gt;
&lt;span class="cm"&gt;   * where the assert_param error has occurred.&lt;/span&gt;
&lt;span class="cm"&gt;   * @param file: pointer to the source file name&lt;/span&gt;
&lt;span class="cm"&gt;   * @param line: assert_param error line source number&lt;/span&gt;
&lt;span class="cm"&gt;   * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;assert_failed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE BEGIN 6 */&lt;/span&gt;
  &lt;span class="cm"&gt;/* User can add his own implementation to report the file name and line number,&lt;/span&gt;
&lt;span class="cm"&gt;    ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE END 6 */&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @}&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @}&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cm"&gt;/*************** (C) COPYRIGHT STMicroelectronics *****END OF FILE********/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="_6"&gt;七、结语&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。&lt;/p&gt;</summary><category term="FreeModbus"></category><category term="STM32F411VET6"></category><category term="STM32CubeF4"></category></entry><entry><title>移植AN4657到STM32F411VET6</title><link href="http://dhlx.wang/STM32F411VET6/Porting_AN4657_STM32Cube_IAP_using_UART_to_STM32F411VET6.html" rel="alternate"></link><updated>2015-07-24T12:12:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-07-03:STM32F411VET6/Porting_AN4657_STM32Cube_IAP_using_UART_to_STM32F411VET6.html</id><summary type="html">
&lt;p&gt;首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备移植程序和工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们在移植AN4657到STM32F411VET6的过程中主要用到以下程序和工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1848/PF260946?s_searchtype=partnumber"&gt;32F411EDISCOVERY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/en/catalog/tools/FM147/CL1794/SC961/SS1743/LN1920/PF262163?s_searchtype=keyword"&gt;X-CUBE-IAP-USART(AN4657)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hilgraeve.com/hyperterminal/"&gt;Hypertrm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1533/PF259242?sc=stm32cube"&gt;STM32CubeMX_V4.8.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/en/catalog/tools/PF259243"&gt;STM32Cube_FW_F4_V1.6.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.keil.com/download/product/"&gt;Keil_MDK_ARM_V5.15.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AN4657-STM32Cube_IAP_using_UART\Projects\STM3210C_EVAL\IAP_Main\Inc
AN4657-STM32Cube_IAP_using_UART\Projects\STM3210C_EVAL\IAP_Main\Src&lt;/p&gt;
&lt;h1 id="_2"&gt;二、拷贝需要的文件到工程目录下&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、解压缩通过下载得到的AN4657压缩包。&lt;/p&gt;
&lt;p&gt;2、拷贝路径（AN4657-STM32Cube_IAP_using_UART\Projects\STM3210C_EVAL\IAP_Main\Inc）中的&lt;code&gt;common.h&lt;/code&gt;、&lt;code&gt;flash_if.h&lt;/code&gt;、&lt;code&gt;menu.h&lt;/code&gt;、&lt;code&gt;ymodem.h&lt;/code&gt;到我们自己的工程路径下的Inc文件夹中。&lt;/p&gt;
&lt;p&gt;3、拷贝路径（AN4657-STM32Cube_IAP_using_UART\Projects\STM3210C_EVAL\IAP_Main\Src）中的&lt;code&gt;common.c&lt;/code&gt;、&lt;code&gt;flash_if.c&lt;/code&gt;、&lt;code&gt;menu.c&lt;/code&gt;、&lt;code&gt;ymodem.c&lt;/code&gt;到我们自己的工程路径下的Src文件夹中，并在keil中添加相应的文件。&lt;/p&gt;
&lt;h1 id="_3"&gt;三、修改串口的基本设置&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;串口的基本设置在STM32Cube可以进行设置，并生成相应的设置代码，但在我们的移植文件中需要用到串口设置，故我们需要在&lt;code&gt;common.c&lt;/code&gt;、&lt;code&gt;menu.c&lt;/code&gt;、&lt;code&gt;ymodem.c&lt;/code&gt;三个文件中进行修改，我的示例代码是用USART1作为演示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;common.c&lt;/code&gt;修改部分如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** @addtogroup STM32F4xx_IAP_Main&lt;/span&gt;
&lt;span class="cm"&gt;* @{&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和&lt;/span&gt;
&lt;span class="c1"&gt;//usart.h的引用。&lt;/span&gt;
&lt;span class="cp"&gt;#include "common.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Private typedef ------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private define -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置&lt;/span&gt;
&lt;span class="c1"&gt;//文件&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef UartHandle&lt;/span&gt;
    &lt;span class="cp"&gt;#define UartHandle huart1&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cm"&gt;/* Private macro --------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private function prototypes ------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private functions ----------------------------------------------------*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;menu.c&lt;/code&gt;修改部分如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** @addtogroup STM32F4xx_IAP&lt;/span&gt;
&lt;span class="cm"&gt;* @{&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和&lt;/span&gt;
&lt;span class="c1"&gt;//usart.h的引用。&lt;/span&gt;
&lt;span class="cp"&gt;#include "common.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "flash_if.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "menu.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "ymodem.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Private typedef ------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private define -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置&lt;/span&gt;
&lt;span class="c1"&gt;//文件&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef UartHandle&lt;/span&gt;
  &lt;span class="cp"&gt;#define UartHandle huart1&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cm"&gt;/* Private macro --------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;ymodem.c&lt;/code&gt;修改部分如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** @addtogroup STM32F4xx_IAP&lt;/span&gt;
&lt;span class="cm"&gt;* @{&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和&lt;/span&gt;
&lt;span class="c1"&gt;//usart.h的引用。&lt;/span&gt;
&lt;span class="cp"&gt;#include "flash_if.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "common.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "ymodem.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "string.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "menu.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Private typedef ------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private define -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置&lt;/span&gt;
&lt;span class="c1"&gt;//文件&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef UartHandle&lt;/span&gt;
  &lt;span class="cp"&gt;#define UartHandle huart1&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cp"&gt;#define CRC16_F       &lt;/span&gt;&lt;span class="cm"&gt;/* activate the CRC16 integrity */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Private macro --------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;P.S. &lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;common.h&lt;/code&gt;、&lt;code&gt;menu.h&lt;/code&gt;、&lt;code&gt;ymodem.h&lt;/code&gt;基本不需要任何修改，直接就可以用。&lt;/p&gt;
&lt;p&gt;2、如果使用&lt;code&gt;32F411EDISCOVERY&lt;/code&gt;，请您注意不要使用默认的USART1的IO设置，需要更改为
PB6、PB7，才可以正常使用，默认的TX引脚上接了一个uF级的电容，我因为这个事情调试了很长时间。&lt;/p&gt;
&lt;h1 id="flash"&gt;三、修改FLASH操作函数及其定义&lt;a class="headerlink" href="#flash" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在整个移植过程中，重头戏就是对&lt;code&gt;flash_if.h&lt;/code&gt;和&lt;code&gt;flash_if.c&lt;/code&gt;的移植，里面涉及到很多
处修改，大部分修改是因为M4系列的MCU对FLASH的操作，没有页（Page）的概念，只有扇区（Sector）的操作函数造成的。&lt;/p&gt;
&lt;p&gt;所以，综上所述需要先将各种Page（PAGE、page）换成Sector，这样基本上可以解决掉一批错误。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flash_if.h&lt;/code&gt;修改后如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Define to prevent recursive inclusion --------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef __FLASH_IF_H&lt;/span&gt;
&lt;span class="cp"&gt;#define __FLASH_IF_H&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//修改引用的头文件为F4的&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Exported types -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Exported constants ---------------------------------------------------*/&lt;/span&gt;

&lt;span class="cm"&gt;/* Base address of the Flash sectors */&lt;/span&gt;
&lt;span class="c1"&gt;//定义扇区名和地址之间的关系，方便根据地址获取扇区的编号&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_0     ((uint32_t)0x08000000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 0, 16 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_1     ((uint32_t)0x08004000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 1, 16 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_2     ((uint32_t)0x08008000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 2, 16 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_3     ((uint32_t)0x0800C000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 3, 16 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_4     ((uint32_t)0x08010000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 4, 64 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_5     ((uint32_t)0x08020000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 5, 128 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_6     ((uint32_t)0x08040000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 6, 128 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_7     ((uint32_t)0x08060000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 7, 128 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Error code */&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_OK&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_ERASEKO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_WRITINGCTRL_ERROR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_WRITING_ERROR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_ERRROR&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/* protection type */&lt;/span&gt;  
&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_NONE&lt;/span&gt;         &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_PCROPENABLED&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_WRPENABLED&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_RDPENABLED&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/* protection update */&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;FLASHIF_WRP_ENABLE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;FLASHIF_WRP_DISABLE&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/* Define the address from where user application will be loaded.&lt;/span&gt;
&lt;span class="cm"&gt;   Note: the 1st sector 0x08000000-0x08003FFF is reserved for the IAP code */&lt;/span&gt;         
&lt;span class="c1"&gt;//根据实际的片内Flash大小修改结束地址，并删除不用的宏定义&lt;/span&gt;
&lt;span class="cp"&gt;#define APPLICATION_ADDRESS           (uint32_t)0x08004000      &lt;/span&gt;&lt;span class="cm"&gt;/* Start user code address */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Notable Flash addresses */&lt;/span&gt;
&lt;span class="cp"&gt;#define USER_FLASH_END_ADDRESS        (uint32_t)0x0807FFFF&lt;/span&gt;

&lt;span class="cm"&gt;/* Define the user application size */&lt;/span&gt;
&lt;span class="cp"&gt;#define USER_FLASH_SIZE               (USER_FLASH_END_ADDRESS - APPLICATION_ADDRESS + 1) &lt;/span&gt;&lt;span class="cm"&gt;/* Small default template application */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;


&lt;span class="cm"&gt;/* Exported macro -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* ABSoulute value */&lt;/span&gt;
&lt;span class="cp"&gt;#define ABS_RETURN(x,y)               ((x) &amp;lt; (y)) ? ((y)-(x)) : ((x)-(y))&lt;/span&gt;

&lt;span class="cm"&gt;/* Get the number of sectors from where the user program will be loaded */&lt;/span&gt;
&lt;span class="cp"&gt;#define FLASH_SECTOR_NUMBER           ((uint32_t)(ABS_RETURN(APPLICATION_ADDRESS,FLASH_START_BANK1))&amp;gt;&amp;gt;12)&lt;/span&gt;

&lt;span class="cm"&gt;/* Compute the mask to test if the Flash memory, where the user program will be&lt;/span&gt;
&lt;span class="cm"&gt;  loaded, is write protected */&lt;/span&gt;
&lt;span class="cp"&gt;#define FLASH_PROTECTED_SECTORS       (~(uint32_t)((1 &amp;lt;&amp;lt; FLASH_SECTOR_NUMBER) - 1))&lt;/span&gt;
&lt;span class="cm"&gt;/* Exported functions --------------------------------------------------*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;StartSector&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_GetWriteProtectionStatus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p_source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_WriteProtectionConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;modifier&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#endif  &lt;/span&gt;&lt;span class="cm"&gt;/* __FLASH_IF_H */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;flash_if.c&lt;/code&gt;修改后如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** @addtogroup STM32F4xx_IAP&lt;/span&gt;
&lt;span class="cm"&gt;  * @{&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "flash_if.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Private typedef ------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private define -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private macro --------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private function prototypes ------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//增加获取扇区的函数，方便获取扇区编号&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* Private functions ----------------------------------------------------*/&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Unlocks Flash for write access&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* Unlock the Program memory */&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Clear all FLASH flags */&lt;/span&gt;
  &lt;span class="c1"&gt;//根据实际的MCU清除FLASH标志位&lt;/span&gt;
  &lt;span class="n"&gt;__HAL_FLASH_CLEAR_FLAG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASH_FLAG_EOP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;FLASH_FLAG_OPERR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;FLASH_FLAG_WRPERR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; 
                  &lt;span class="n"&gt;FLASH_FLAG_PGAERR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;FLASH_FLAG_PGPERR&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;FLASH_FLAG_PGSERR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="cm"&gt;/* Unlock the Program memory */&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  This function does an erase of all user flash area&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  start: start of user flash area&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval FLASHIF_OK : user flash area successfully erased&lt;/span&gt;
&lt;span class="cm"&gt;  *         FLASHIF_ERASEKO : error occurred&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//将相关的Page参数均修改为M4的Sector 参数&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;NbrOfSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;SectorError&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;FLASH_EraseInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;HAL_StatusTypeDef&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Unlock the Flash to enable the flash control register access *************/&lt;/span&gt; 
    &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* Get the sector where start the user flash area */&lt;/span&gt;
    &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;NbrOfSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_7&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TypeErase&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_TYPEERASE_SECTORS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Banks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_BANK_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NbSectors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NbrOfSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;VoltageRange&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_VOLTAGE_RANGE_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HAL_FLASHEx_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;SectorError&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="cm"&gt;/* Lock the Flash to disable the flash control register access (recommended&lt;/span&gt;
&lt;span class="cm"&gt;     to protect the FLASH memory against possible unwanted operation) *********/&lt;/span&gt;
    &lt;span class="n"&gt;HAL_FLASH_Lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Error occurred while Sector erase */&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_ERASEKO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Public functions -----------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  This function writes a data buffer in flash (data are 32-bit aligned).&lt;/span&gt;
&lt;span class="cm"&gt;  * @note   After writing data buffer, the flash content is checked.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  destination: start address for target location&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  p_source: pointer on buffer with data to write&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  length: length of data buffer (unit is 32-bit word)&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval uint32_t 0: Data successfully written to Flash memory&lt;/span&gt;
&lt;span class="cm"&gt;  *         1: Error occurred while writing data in Flash memory&lt;/span&gt;
&lt;span class="cm"&gt;  *         2: Written Data in flash memory is different from expected one&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p_source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Unlock the Flash to enable the flash control register access *************/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;destination&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USER_FLASH_END_ADDRESS&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Device voltage range supposed to be [2.7V to 3.6V], the operation will&lt;/span&gt;
&lt;span class="cm"&gt;       be done by word */&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAL_FLASH_Program&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASH_TYPEPROGRAM_WORD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;p_source&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      
    &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="cm"&gt;/* Check the written value */&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;destination&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;p_source&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Flash content doesn't match SRAM content */&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASHIF_WRITINGCTRL_ERROR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="cm"&gt;/* Increment FLASH destination address */&lt;/span&gt;
      &lt;span class="n"&gt;destination&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="cm"&gt;/* Error occurred while writing data in Flash memory */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASHIF_WRITING_ERROR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="cm"&gt;/* Lock the Flash to disable the flash control register access (recommended&lt;/span&gt;
&lt;span class="cm"&gt;     to protect the FLASH memory against possible unwanted operation) *********/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASHIF_OK&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Returns the write protection status of application flash area.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval If a sector in application area is write-protected returned value is a combinaison&lt;/span&gt;
&lt;span class="cm"&gt;            of the possible values : FLASHIF_PROTECTION_WRPENABLED, FLASHIF_PROTECTION_PCROPENABLED, ...&lt;/span&gt;
&lt;span class="cm"&gt;  *         If no sector is write-protected FLASHIF_PROTECTION_NONE is returned.&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_GetWriteProtectionStatus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_PROTECTION_NONE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;FLASH_OBProgramInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;OptionsBytesStruct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Unlock the Flash to enable the flash control register access ********/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/*Check if there are write protected sectors inside the user flash area*/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASHEx_OBGetConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;OptionsBytesStruct&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* Lock the Flash to disable the flash control register access (recommended&lt;/span&gt;
&lt;span class="cm"&gt;     to protect the FLASH memory against possible unwanted operation) *********/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Get Sectors already write protected *********************************/&lt;/span&gt;
  &lt;span class="c1"&gt;//后面的保护区域，没有看懂，所以直接屏蔽掉了&lt;/span&gt;
  &lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;OptionsBytesStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WRPSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Check if desired Sectors are already write protected ****************/&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Some sectors inside the user flash area are write protected */&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_PROTECTION_WRPENABLED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="cm"&gt;/* No write protected sectors inside the user flash area */&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_PROTECTION_NONE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Configure the write protection status of user flash area.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  protectionstate : FLASHIF_WRP_DISABLE or FLASHIF_WRP_ENABLE the protection&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval uint32_t FLASHIF_OK if change is applied.&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_WriteProtectionConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;protectionstate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;FLASH_OBProgramInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;config_old&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;HAL_StatusTypeDef&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


  &lt;span class="cm"&gt;/* Get Sectors write protection status *********************************/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASHEx_OBGetConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;config_old&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* The parameter says whether we turn the protection on or off */&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WRPState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;protectionstate&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_WRP_ENABLE&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;OB_WRPSTATE_ENABLE&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;OB_WRPSTATE_DISABLE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* We want to modify only the Write protection */&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OptionType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;OPTIONBYTE_WRP&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* No read protection, keep BOR and reset settings */&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RDPLevel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;OB_RDP_LEVEL_0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;USERConfig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;config_old&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;USERConfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="cm"&gt;/* Get Sectors already write protected *********************************/&lt;/span&gt;
  &lt;span class="c1"&gt;//后面的保护区域，没有看懂，所以直接屏蔽掉了&lt;/span&gt;
  &lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;config_old&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WRPSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Unlock the Flash to enable the flash control register access *******/&lt;/span&gt; 
  &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Unlock the Options Bytes ********************************************/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_OB_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Erase all the option Bytes ******************************************/&lt;/span&gt;
  &lt;span class="c1"&gt;//在HAL_F4的库中没有找到擦除命令位的函数，故在此注释掉&lt;/span&gt;
  &lt;span class="c1"&gt;//result = HAL_FLASHEx_OBErase();&lt;/span&gt;

  &lt;span class="c1"&gt;//if (result == HAL_OK)&lt;/span&gt;
  &lt;span class="c1"&gt;//{&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WRPSector&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ProtectedSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HAL_FLASHEx_OBProgram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;FLASHIF_OK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_PROTECTION_ERRROR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  根据送入地址获取其所在扇区位置&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  需要知道所在扇区位置的地址&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval 扇区位置（FLASH_SECTOR_0——FLASH_SECTOR_7）&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="c1"&gt;//增加扇区编号的获取函数&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; 
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @}&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;

&lt;span class="cm"&gt;/******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="keil"&gt;四、Keil需要修改的位置&lt;a class="headerlink" href="#keil" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、需要根据设置的APP程序起始的位置，设置KEIL中APP程序起始位置与程序空间大小&lt;/p&gt;
&lt;p&gt;&lt;img alt="Porting-AN4657-STM32Cube-IAP-using-UART-to-STM32F411VET6-image-0" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/7/Porting-AN4657-STM32Cube-IAP-using-UART-to-STM32F411VET6-image-0.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、需要在User选项卡中增加自定义处理字符串，&lt;code&gt;C:\Program Files\Keil\ARM\ARMCC\bin\fromelf.exe --bin -o .\存放bin的路径\bin文件的名称.bin .\Keil编译后生成的axf的路径\axf文件的名称.axf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Porting-AN4657-STM32Cube-IAP-using-UART-to-STM32F411VET6-image-1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/7/Porting-AN4657-STM32Cube-IAP-using-UART-to-STM32F411VET6-image-1.png"/&gt;&lt;/p&gt;
&lt;h1 id="_4"&gt;五、设置中断向量表偏移&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;需要在&lt;code&gt;main.c&lt;/code&gt;文件中的&lt;code&gt;/* USER CODE BEGIN 1 */&lt;/code&gt;和&lt;code&gt;/* USER CODE END 1 */&lt;/code&gt;之间增加一条设置中断向量表的语句&lt;code&gt;SCB-&amp;gt;VTOR = FLASH_BASE | 0x4000;&lt;/code&gt;，如下所示。&lt;/p&gt;
&lt;p&gt;main.c增加的代码示意如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* USER CODE BEGIN 1 */&lt;/span&gt;   
&lt;span class="n"&gt;SCB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;VTOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_BASE&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mh"&gt;0x4000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cm"&gt;/* USER CODE END 1 */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="_5"&gt;六、结语&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。&lt;/p&gt;</summary><category term="IAP"></category><category term="STM32F411VET6"></category><category term="STM32CubeF4"></category></entry><entry><title>简单移植IAP（STSW-STM32067）到STM32F411VET6</title><link href="http://dhlx.wang/STM32F411VET6/Simple_transplant_IAP_STSW-STM32067_to_STM32F411VET6.html" rel="alternate"></link><updated>2015-06-12T12:15:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-06-12:STM32F411VET6/Simple_transplant_IAP_STSW-STM32067_to_STM32F411VET6.html</id><summary type="html">
&lt;p&gt;首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备移植程序和工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们在移植IAP的过程中主要用到以下三个东西，一个是STM32F411VET6的开发板，一个是待移植的官方的STM32F4-IAP-USART程序，最后一个就是上位机（支持ymodem），这里最好选用官方建议使用的超级终端（Hypertrm）进行测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1848/PF260946?s_searchtype=partnumber"&gt;32F411EDISCOVERY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1743/LN1734/PF257903?s_searchtype=partnumber"&gt;STM32F4 IAP using the USART (AN3965)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hilgraeve.com/hyperterminal/"&gt;Hypertrm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt;二、修改串口通讯接口&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;由于STM32F411VET6中没有USART3，我需要将USART3的配置修改为USART2。这个里面我个人建议修改为与USART3在同一总线上的USART，否则需要进行大量的代码修改。由于我只是进行工程远程调试，暂时不考虑大费周章进行移植和修改，如果后续需要使用，可能会做基于HAL的移植，并对读取Flash的权限做出详细的限制。&lt;/p&gt;
&lt;p&gt;下面我们就开始正式的移植过程，我们需要修改工程中的&lt;code&gt;stm324xg_eval.h&lt;/code&gt;文件中关于USART的宏定义部分。&lt;/p&gt;
&lt;p&gt;原始宏定义如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief Definition for COM port1, connected to USART3&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt; 
&lt;span class="cp"&gt;#define EVAL_COM1                        USART3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_CLK                    RCC_APB1Periph_USART3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_PIN                 GPIO_Pin_10&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_GPIO_PORT           GPIOC&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_GPIO_CLK            RCC_AHB1Periph_GPIOC&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_SOURCE              GPIO_PinSource10&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_AF                  GPIO_AF_USART3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_PIN                 GPIO_Pin_11&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_GPIO_PORT           GPIOC&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_GPIO_CLK            RCC_AHB1Periph_GPIOC&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_SOURCE              GPIO_PinSource11&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_AF                  GPIO_AF_USART3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_IRQn                   USART3_IRQn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;修改后宏定义如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief Definition for COM port1, connected to USART2&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt; 
&lt;span class="cp"&gt;#define EVAL_COM1                        USART2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_CLK                    RCC_APB1Periph_USART2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_PIN                 GPIO_Pin_2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_GPIO_PORT           GPIOA&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_GPIO_CLK            RCC_AHB1Periph_GPIOA&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_SOURCE              GPIO_PinSource2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_AF                  GPIO_AF_USART2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_PIN                 GPIO_Pin_3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_GPIO_PORT           GPIOA&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_GPIO_CLK            RCC_AHB1Periph_GPIOA&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_SOURCE              GPIO_PinSource3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_AF                  GPIO_AF_USART2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_IRQn                   USART2_IRQn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;P.S.注意您选择USART2的管脚分配，我这里分配的GPIOA2（TX）和GPIOA3（RX）。&lt;/p&gt;
&lt;h1 id="flash"&gt;三、修改Flash大小定义&lt;a class="headerlink" href="#flash" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;由于STM32F411VET6和STM32F407系列的Flash大小不一致，故需要简单修改下Flash的相关函数和定义。&lt;/p&gt;
&lt;p&gt;首先，我们需要修改&lt;code&gt;flash_if.c&lt;/code&gt;中&lt;code&gt;uint32_t FLASH_If_Erase&lt;/code&gt;的函数。&lt;/p&gt;
&lt;p&gt;原先函数的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief  This function does an erase of all user flash area&lt;/span&gt;
&lt;span class="cm"&gt;* @param  StartSector: start of user flash area&lt;/span&gt;
&lt;span class="cm"&gt;* @retval 0: user flash area successfully erased&lt;/span&gt;
&lt;span class="cm"&gt;*         1: error occurred&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;StartSector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Get the sector where start the user flash area */&lt;/span&gt;
  &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Device voltage range supposed to be [2.7V to 3.6V], the operation will&lt;/span&gt;
&lt;span class="cm"&gt;       be done by word */&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASH_EraseSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VoltageRange_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;FLASH_COMPLETE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="cm"&gt;/* Error occurred while page erase */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;需要将&lt;code&gt;FLASH_Sector_11&lt;/code&gt;修改为&lt;code&gt;FLASH_Sector_7&lt;/code&gt;，修改后函数代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  This function does an erase of all user flash area&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  StartSector: start of user flash area&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval 0: user flash area successfully erased&lt;/span&gt;
&lt;span class="cm"&gt;  *         1: error occurred&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;StartSector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Get the sector where start the user flash area */&lt;/span&gt;
  &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Device voltage range supposed to be [2.7V to 3.6V], the operation will&lt;/span&gt;
&lt;span class="cm"&gt;       be done by word */&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASH_EraseSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VoltageRange_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;FLASH_COMPLETE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="cm"&gt;/* Error occurred while page erase */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;其次我们需要修改&lt;code&gt;flash_if.c&lt;/code&gt;中的&lt;code&gt;static uint32_t GetSector&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;原先函数的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Gets the sector of a given address&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  Address: Flash address&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval The sector of a given address&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_9&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_11&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="cm"&gt;/*(Address &amp;lt; FLASH_END_ADDR) &amp;amp;&amp;amp; (Address &amp;gt;= ADDR_FLASH_SECTOR_11))*/&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;根据实际情况适当增删&lt;code&gt;FLASH_Sector&lt;/code&gt;，修改后函数代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Gets the sector of a given address&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  Address: Flash address&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval The sector of a given address&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; 
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="main"&gt;四、修改Main函数&lt;a class="headerlink" href="#main" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在移植过程中根据您的需要，修改Main函数，下面放上原Main函数和我个人根据&lt;code&gt;32F411EDISCOVERY&lt;/code&gt;修改后的Main函数。&lt;/p&gt;
&lt;p&gt;原先函数的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Main program.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* Unlock the Flash Program Erase controller */&lt;/span&gt;
  &lt;span class="n"&gt;FLASH_If_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Initialize Key Button mounted on STM324xG-EVAL board */&lt;/span&gt;
  &lt;span class="n"&gt;STM_EVAL_PBInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BUTTON_KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUTTON_MODE_GPIO&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* Test if Key push-button on STM324xG-EVAL Board is pressed */&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STM_EVAL_PBGetState&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BUTTON_KEY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="cm"&gt;/* Execute the IAP driver in order to reprogram the Flash */&lt;/span&gt;
    &lt;span class="n"&gt;IAP_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="cm"&gt;/* Display main menu */&lt;/span&gt;
    &lt;span class="n"&gt;Main_Menu&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="cm"&gt;/* Keep the user application running */&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Test if user code is programmed starting from address "APPLICATION_ADDRESS" */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x2FFE0000&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x20000000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; 
      &lt;span class="cm"&gt;/* Jump to user application */&lt;/span&gt;
      &lt;span class="n"&gt;JumpAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;Jump_To_Application&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pFunction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;JumpAddress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="cm"&gt;/* Initialize user application's Stack Pointer */&lt;/span&gt;
      &lt;span class="n"&gt;__set_MSP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;Jump_To_Application&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;根据&lt;code&gt;32F411EDISCOVERY&lt;/code&gt;修改后的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Main program.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* Unlock the Flash Program Erase controller */&lt;/span&gt;
  &lt;span class="n"&gt;FLASH_If_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Initialize Key Button mounted on STM324xG-EVAL board */&lt;/span&gt;
  &lt;span class="n"&gt;STM_EVAL_PBInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BUTTON_KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUTTON_MODE_GPIO&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* Test if Key push-button on STM324xG-EVAL Board is unpressed */&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STM_EVAL_PBGetState&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BUTTON_KEY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="cm"&gt;/* Test if user code is programmed starting from address "APPLICATION_ADDRESS" */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x2FFE0000&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x20000000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; 
          &lt;span class="cm"&gt;/* Jump to user application */&lt;/span&gt;
          &lt;span class="n"&gt;JumpAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;Jump_To_Application&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pFunction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;JumpAddress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="cm"&gt;/* Initialize user application's Stack Pointer */&lt;/span&gt;
          &lt;span class="n"&gt;__set_MSP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;Jump_To_Application&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="cm"&gt;/* Keep the user application running */&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Execute the IAP driver in order to reprogram the Flash */&lt;/span&gt;
        &lt;span class="n"&gt;IAP_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="cm"&gt;/* Display main menu */&lt;/span&gt;
        &lt;span class="n"&gt;Main_Menu&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="iap_init"&gt;五、修改IAP_Init函数&lt;a class="headerlink" href="#iap_init" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;根据您的实际情况修改&lt;code&gt;IAP_Init&lt;/code&gt;函数中的参数。&lt;/p&gt;
&lt;p&gt;原函数代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Initialize the IAP: Configure USART.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
void&lt;span class="w"&gt; &lt;/span&gt;IAP_Init&lt;span class="o"&gt;(&lt;/span&gt;void&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;USART_InitTypeDef&lt;span class="w"&gt; &lt;/span&gt;USART_InitStructure&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* USART resources configuration (Clock, GPIO pins and USART registers) ----*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* USART configured as follow:&lt;/span&gt;
&lt;span class="cm"&gt;        - BaudRate = 115200 baud  &lt;/span&gt;
&lt;span class="cm"&gt;        - Word Length = 8 Bits&lt;/span&gt;
&lt;span class="cm"&gt;        - One Stop Bit&lt;/span&gt;
&lt;span class="cm"&gt;        - No parity&lt;/span&gt;
&lt;span class="cm"&gt;        - Hardware flow control disabled (RTS and CTS signals)&lt;/span&gt;
&lt;span class="cm"&gt;        - Receive and transmit enabled&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_BaudRate&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;115200&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;串口波特率&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_WordLength&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_WordLength_8b&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_StopBits&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_StopBits_1&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_Parity&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_Parity_No&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_HardwareFlowControl&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_HardwareFlowControl_None&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_Mode&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_Mode_Rx&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_Mode_Tx&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;STM_EVAL_COMInit&lt;span class="o"&gt;(&lt;/span&gt;COM1&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_3"&gt;六、结语&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。&lt;/p&gt;
&lt;p&gt;后续，如果我在工作之余或者工作中有需要，我可能会将IAP的代码移植到HAL库上，如果您已经做了相关工作，希望您可以在不涉及保密条款和其他利益的情况下，抄送一份给我，用于后续研究与参考。谢谢！&lt;/p&gt;</summary><category term="IAP"></category><category term="STM32F411VET6"></category><category term="STSW-STM32067"></category></entry><entry><title>Windows 8.1 Update 系统迁移</title><link href="http://dhlx.wang/Windows/Win8-1-Update-System-Migration.html" rel="alternate"></link><updated>2015-08-09T17:18:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-05-11:Windows/Win8-1-Update-System-Migration.html</id><summary type="html">
&lt;p&gt;上周的周末，新买的SSD硬盘到了，需要把旧系统盘的数据迁移至新的SSD上，最开始考虑了Winodws系统映像的方法进行迁移，但通过恢复U盘进入到恢复步骤时，总是提示我无法格式化硬盘，所以放弃了这个方案。&lt;/p&gt;
&lt;p&gt;在查询无数资料后，考虑到Win 8.1 Update的组成，突然灵光一现，尝试用Win 8.1的系统盘格式化新的SSD，从而使新的磁盘系统分区和原来的保持一致，通过备份分区数据，还原分区数据的方式，完成系统迁移。&lt;/p&gt;
&lt;p&gt;本文就是就是记录下这个操作流程，以备后人参考，如果您有更好的方法，请您不吝赐教，谢谢！&lt;/p&gt;
&lt;p&gt;废话也说完了，我们下面进入到正题。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://bbs.winpe.cc/thread-85876-1-1.html"&gt;天意u盘维护系统技术员版3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cn.ezbsystems.com/ultraiso/index.html"&gt;UltraISO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="ed2k://|file|cn_windows_8.1_with_update_x64_dvd_6051473.iso|4504475648|D66BEF759548656EDA981D902A957545|/"&gt;cn_windows_8.1_with_update_x64_dvd_6051473.iso&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="ed2k://|file|cn_windows_8.1_with_update_x86_dvd_6051523.iso|3349960704|C1B8A61BD8F1300825BF03C4D31B35A0|/"&gt;cn_windows_8.1_with_update_x86_dvd_6051523.iso&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://down.tech.sina.com.cn/content/54189.html"&gt;Windows 8 USB Installer Maker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.diskgenius.cn/download.php"&gt;DiskGenius v4.7.1 免费版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;16G U盘 可量产&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果遇到上述链接无法访问，请您自行想办法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;友情提示：中国拥有世界上第八大奇迹——长城。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id="winodws-81-upadate-u"&gt;二、制作Winodws 8.1 Upadate U盘安装盘&lt;a class="headerlink" href="#winodws-81-upadate-u" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这个大家应该已经很熟悉了吧！用我提供的Windows 8 USB Installer Maker工具，基本制作过程是傻瓜式安装。&lt;/p&gt;
&lt;h1 id="winodws-81-upadate"&gt;三、安装Winodws 8.1 Upadate到新系统盘&lt;a class="headerlink" href="#winodws-81-upadate" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这步我也就简单说下，基本上都会做，说一下几个需要注意的地方。&lt;/p&gt;
&lt;p&gt;1、重启进入Bios把安全启动关闭，以免后续从PE、U盘安装盘启动不了。
2、一定保证新盘的分区方式和旧盘一样，我一般采用的系统盘自动分区。
3、进入不进入系统都可以，等会儿都要覆盖的。&lt;/p&gt;
&lt;h1 id="upe"&gt;四、安装天意U盘PE&lt;a class="headerlink" href="#upe" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这步在天意大大贴子中已经写的很清楚了，我就不重复给出制作U盘PE的教程了。这里仅给出一个UltraISO可用的用户名和注册码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;用户名：王涛 注册码：7C81-1689-4046-626F
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_2"&gt;五、备份旧系统盘数据&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、如下图所示，进入到天意PE中，打开DiskGenius。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-0" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-0.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、选中原系统分区，单机鼠标右键，可以看到备份分区到镜像文件，点击它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-1.png"/&gt;&lt;/p&gt;
&lt;p&gt;在这里您需要注意查看下旧系统分区的数据量是否远小于新系统盘的分区大小。&lt;/p&gt;
&lt;p&gt;3、选择文件路径，并点击开始，就可以开始备份了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-2.png"/&gt;&lt;/p&gt;
&lt;h1 id="_3"&gt;六、还原旧系统盘数据到新系统盘&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、选中新系统分区，单机鼠标右键，可以看到从镜像文件还原分区，点击它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-3" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-3.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、选择刚刚备份的文件，并点击开始，进行系统迁移。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-4" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-4.png"/&gt;&lt;/p&gt;
&lt;h1 id="_4"&gt;七、重新设置引导参数&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、在天意PE中默认没有给引导分区指派盘符，所以我们需要找到系统的引导分区，单机鼠标右键，可以指派新的驱动器号，点击它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-5" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-5.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、选择您想要赋予的盘符，选择它，记住它，并单击确定。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-6" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-6.png"/&gt;&lt;/p&gt;
&lt;p&gt;3、打开开始菜单，找到BIOS+UEFI引导修复工具，打开它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-7" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-7.png"/&gt;&lt;/p&gt;
&lt;p&gt;4、按照提示填写Windows系统分区盘符，引导分区盘符，并按下回车，确认信息后，再次按下回车。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-8" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-8.png"/&gt;&lt;/p&gt;
&lt;p&gt;5、出现上图最后一行的提示，您可以关闭程序，并重启电脑。&lt;/p&gt;
&lt;h1 id="_5"&gt;八、结语&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;以上就是我此次系统迁移的基本过程，如果您有没看懂的地方，您可以留言，我看到后会及时回复。&lt;/p&gt;
&lt;p&gt;P.S. 天意大大说我提供这个版本PE中DiskGenius有一些问题，但是在操作过程中我没有遇到，如果您遇到了，可以用DiskGenius的原版（在第一章节中有提供下载地址）尝试下。&lt;/p&gt;</summary><category term="Windows 8.1 Update"></category><category term="SSD"></category><category term="HDD"></category></entry></feed>