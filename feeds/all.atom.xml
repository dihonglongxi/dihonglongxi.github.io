<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>帝鴻龍曦</title><link href="http://dhlx.wang/" rel="alternate"></link><link href="http://dhlx.wang/feeds/all.atom.xml" rel="self"></link><id>http://dhlx.wang/</id><updated>2015-12-26T10:16:00+08:00</updated><entry><title>写给自己，2015年末</title><link href="http://dhlx.wang/Diary/The_end_of_2015_wrote_to_myself.html" rel="alternate"></link><updated>2015-12-26T10:16:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-12-26:Diary/The_end_of_2015_wrote_to_myself.html</id><summary type="html">
&lt;p&gt;  上了大学以后，每年都想要回顾一下这一年的经历，可是每每当我想要提笔，不知道怎么去写，一年拖一年，拖到现在。&lt;/p&gt;
&lt;p&gt;  2015年中，走过许多地方，经历很多事情。许多事情已经遗忘，化作时间长河中的一缕缕金沙。下面我就从四个方面简单的总结下2015年的自己，有好的，也有坏的。权当是给2016年的自己的激励吧！&lt;/p&gt;
&lt;h3 id="_1"&gt;一、从生活上来讲&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  2015年一共365天，只陪父母在家呆了24天，其中春节有11天，元宵节4天，其余时间可以说是基本上没有回过家。虽有古话：父母在，不远游，游必有方。虽说是为了自己的将来在打拼，但这一年中还是感觉没有尽到为人子女的责任，期待来年会有更多的时间来回家敬养父母。&lt;/p&gt;
&lt;p&gt;  在2015年中，我走过8省12市3直辖市，乘坐过22次火车、2次汽车出行和10次飞机。走过的地方多了，认识的朋友也就多了，经历的事情也就多了，对很多的东西也有新的看法。我们明天起床，都是新的一天，不管昨天怎么样，我们都应该快乐的迎接新的一天，不该为了过去的、未来的事情愁眉苦脸，做好当下。&lt;/p&gt;
&lt;p&gt;  2015年中，还看了10多本的书，但多半是些杂书，小说，只有两本有关技术精进的书籍，今年总是抱怨没有时间看书，只有在地铁上的一点时间可以用来看书，今年年初时，我还想着翻译一本外文手册，一直也没有动笔，这是我比较遗憾的事情之一。&lt;/p&gt;
&lt;p&gt;  两天前，我在大学中有些暗恋（或许这种感情是暗恋吧，我也不知道，比朋友多一些，比恋人少一些）的女孩告诉我她有男朋友了。这是我唯一不知道心里是什么感觉的事情，就在几天前，我还在为她挑选一块粉晶，希望她可以在2016年找到她的幸福，但我真正听到她告诉我她有男朋友了，我真的不知道是应该祝福，还是应该懊悔，或许我就像我朋友说的一样吧，永远想的太多了。想我们的家庭、地理上的隔离、对她的一切不了解，不知道她在现在想什么，做什么，吃什么，今天高兴与否，或许正是这些担忧，注定了我们只能做朋友，希望今后，我们不要走着走着就散了。&lt;/p&gt;
&lt;h3 id="_2"&gt;二、从工作上来说&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  2015年，是我做出改变的一年，从边陲之地——哈尔滨来到了帝都——北京，从简单的制作DIY机器人传感器模块，到设计家庭服务机器人的主控板和基本执行程序。&lt;/p&gt;
&lt;p&gt;  在这一年中，虽然学会了许多的东西，但主要是待人接物的处事方法，但我还是喜欢以诚待人，即使被人说成傻子，但我本来也不是很奸，也不是很懂得拒绝别人。还有就是产品的总体设计和扫地机的相关技术，了解了一款产品从最初的模型到成品的不容易，和基本上的几个过程。&lt;/p&gt;
&lt;p&gt;  唯一让我感觉很无奈的事情就是：不知道为什么来到北京之后，感觉自特别忙碌，不知道整日都在忙些什么，春夏秋冬过的特别快，我还以为昨天我刚刚来到北京呢！没有原来在哈尔滨搞设计的成就感，或许感觉上很空虚，实际上还很充实吧！&lt;/p&gt;
&lt;h3 id="_3"&gt;三、从财政上来看&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  2015年的个人的账务，可以说是一个很糟糕的情况，从年初的基本无负债，到现在负债15000多（大部分是JD的12期、24期的无息分期）的严重赤字。我都有些不敢想象一旦我没有了工资了，我要怎么办，我想是时候对我花销方式做出改变和规划了，要不欠账只会越来越多。&lt;/p&gt;
&lt;p&gt;  目前，我想到的方式只有，在买东西的时候，多问自己一句，有必要去花费这些钱来买这些东西吗？在打算出大笔花销的时候，问问自己这么做值得吗？&lt;/p&gt;
&lt;h3 id="_4"&gt;四、从健康上来瞧&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  今天称了下体重，感觉来到北京之后，体重好像有又涨了5公斤，可能和我整日没有运动量，在电脑前干活有关，感觉自己应该适当增加运动量了，不能一天宅在家了。&lt;/p&gt;
&lt;p&gt;  2015年中，还有一件大事，估计就是工作中不慎摔落，导致小臂骨错位，这次受伤估计是我小学毕业以后最严重的一次，估计还得需要2-3个月的休养，胳膊才能恢复正常的使用功能。&lt;/p&gt;
&lt;h3 id="_5"&gt;总结&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;  2015，有过欢笑，有过痛苦，现在只剩下4个数字，和数不清的结果，有好的，也有坏的，毕竟都是自己的选择，不曾后悔，问心无愧。&lt;/p&gt;
&lt;p&gt;  2016，我来了！我带着梦想而来！&lt;/p&gt;
&lt;p&gt;  2016，学会拒绝！&lt;/p&gt;
&lt;p&gt;  2016，能做100个俯卧撑！&lt;/p&gt;
&lt;p&gt;  2016，日本，我等你！&lt;/p&gt;
&lt;p&gt;  2016，Led Art！&lt;/p&gt;
&lt;p&gt;  2016，啃下自动化！&lt;/p&gt;
&lt;p&gt;  2016，English，I Love You！&lt;/p&gt;
&lt;p&gt;  2016，110kg！&lt;/p&gt;</summary></entry><entry><title>超频变砖不用怕，自己动手不求人</title><link href="http://dhlx.wang/Computer-Hardware/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself.html" rel="alternate"></link><updated>2015-08-08T18:57:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-08-08:Computer-Hardware/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself.html</id><summary type="html">
&lt;p&gt;人非圣贤，马有失蹄。虽然说NETGEAR 8000刷机和设置过程还是相对安全的，万一遇到断电等不可抗因素和设置过程中误设置，还是有成砖头的危险。一般来说，只要硬件无损坏，不去刷死CFE，都是可以救回来的。&lt;/p&gt;
&lt;p&gt;如何刷DD固件就不在这里说了，直接升级就可以了！想刷回固件也很方便，第一种方法也是采用直接升级就好了，第二种就是下面这种应付各种意外情况的刷机。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://item.taobao.com/item.htm?spm=a1z09.2.9.11.CjhKsM&amp;amp;id=19328552567&amp;amp;_u=8j8md6c6278"&gt;Waveshare FT232 USB to TTL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/"&gt;Putty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://support.netgear.cn/Upfilepath/R8000-V1.0.2.44_1.0.96.chk"&gt;R8000-V1.0.2.44_1.0.96.chk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果遇到上述链接无法访问，请您自行想办法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;友情提示：中国拥有世界上第八大奇迹——长城。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id="tftp"&gt;二、安装TFTP客户端&lt;a class="headerlink" href="#tftp" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这步基本上很简单，按照下面图示操作就好了。&lt;/p&gt;
&lt;p&gt;基本流程就是：找到计算机中的卸载或更改程序（程序和功能），在左侧的打开或关闭Windows功能中，勾选TFTP客户，点击确定就好。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-0" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-0.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-1.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-2.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-3" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-3.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-4" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-4.png"/&gt;&lt;/p&gt;
&lt;h1 id="r8000ttl"&gt;三、拆解R8000，并连接TTL&lt;a class="headerlink" href="#r8000ttl" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;要说明的是，拆解会让你的R8000失去保修。拆掉R8000螃蟹壳上的10壳螺丝，其中有一颗螺丝在贴纸下方，需要揭掉贴纸。并拆掉天线连接，拿出主板，按照下图说明，和买来USB to TTL连接，进入准备刷机的状态。&lt;/p&gt;
&lt;p&gt;P.S. 建议拆机，手接触主板之前，用手摸摸暖气，把自己脱个精光。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-5" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-5.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="putty"&gt;四、设置Putty&lt;a class="headerlink" href="#putty" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、在计算机的设备管理器中检查COM端口，并设置为“115200”，数据位“8”，停止位“1”。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-6" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-6.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-7" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-7.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、打开PuTTY，按照下图进行设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-8" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-8.png"/&gt;&lt;/p&gt;
&lt;p&gt;3、回到PuTTY的主页面，选择连接方式为Serial并填入相对的COM端口，传输速率会自动变成之前设置好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-9" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-9.png"/&gt;&lt;/p&gt;
&lt;p&gt;4、运行PuTTY，在R8000未通电开启之前，PuTTY窗口样式为下图。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-10" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-10.png"/&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;五、满血复活&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、插入R8000电源，可以看到Putty界面上会显示一堆初始化，开机信息，这个时候，点进Puttty窗口中，不断的按CTRL-C，终止初始化，进入CFE模式，此时会显示如下信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Startup Canceled
CFE&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、通过以下命令擦除现有固件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;CFE&amp;gt; nvram erase
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、重启R8000&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;CFE&amp;gt; reboot
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、重复1中的动作，再次进入CFE模式。&lt;/p&gt;
&lt;p&gt;5、进入TFTP模式，键入命令后，会出现如下界面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;CFE&amp;gt; tftpd
Start TFTP Server
Reading : :
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、到此路由器设置，完毕，下面我们将网线插入R800的LAN口中，另一端与电脑相连，并在电脑上对以太网属性，进行如下设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-11" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/8/Overclocking-brick-do-not-be-afraid-do-it-yourself-yourself-image-11.png"/&gt;&lt;/p&gt;
&lt;p&gt;7、以管理员打开命令提示符，并确认R8000进入TFTP模式（TTL = 100）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ping 192.168.1.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8、使用CMD的CD命令定位刚刚下载的CHK文件的所在目录，并执行以下命令上传至R8000。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;tftp -i 192.168.1.1 PUT R8000-V1.0.2.44_1.0.96.chk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9、等待，大概需要3-5分钟，访问192.168.1.1会看到熟悉的界面。&lt;/p&gt;
&lt;h1 id="_3"&gt;六、结束语&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;因为误设置导致R8000变砖，但实际刷完DD-WRT，感觉性能还不如原版固件，不知道是不是因为我设置不对的问题，求大神讲解设置过程。&lt;/p&gt;</summary><category term="NETGEAR 8000"></category><category term="路由"></category><category term="超频"></category></entry><entry><title>吴军《浪潮之巅》书评</title><link href="http://dhlx.wang/Book_Review/On_Top_of_Tides.html" rel="alternate"></link><updated>2015-07-21T17:39:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-07-21:Book_Review/On_Top_of_Tides.html</id><summary type="html">
&lt;p&gt;  这本书读完有一段时间了，一直不知道怎么把它推荐给大家，其中虽没有光怪陆离的世界，但有互联网过去几十年的发展历程，或许其中带有一些作者的主观色彩，但总体来说还是以局外人纪实写些发生的事情，初起的时候，我并不是很喜欢这本书，但读着读着，我也喜欢这本书的叙事风格，平实不乏有趣，又了解了IT行业的历史和更迭。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、您在哪里可以找到它&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  1、&lt;a href="http://googlechinablog.blogspot.com/search?q=%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85"&gt;google的黑板报&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  2、&lt;a href="http://www.amazon.cn/%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85-%E5%90%B4%E5%86%9B/dp/B00D73BJWK/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1437470867&amp;amp;sr=1-1&amp;amp;keywords=%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85"&gt;亚马逊&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;二、这本书写了些什么&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;  计算机领域的发展在吴军看来是一波波的浪潮，幸运的公司可以借浪前行，但更多的是在大海深处长眠。互联网、计算机使得时间变短，也就意味着技术更迭加快，浪潮的时间短，三年河东三年河西，变为了现实，记得我刚上高中时，我都不知道iphone是什么品牌，只知道诺基亚和三星，三年过后，我拿着iphone进入到大学中，同学都问我这是什么手机，当时很多人真的只是喜欢iphone的简洁易用，现在iphone已经满大街都是，已经成了一款装逼利器，很少见到有人能用明白iphone，100%发挥其功能的，但不管怎么说，Apple公司在智能手持终端这个浪潮中赚的盆满钵满。&lt;/p&gt;
&lt;p&gt;  这本书也是详细讲诉了浪潮的形成原因、过程，和过往的公司的丰功伟绩、过失。详细的展现了IT领域的70-20-10的规律，就是在一个细分的市场，往往只能容下一家大的，占有7成的市场份额，还有一家老二，占有2成的份额，其它的若干公司，只能分剩下的1成份额。赢者通吃，在IT领域显现的尤为明显。所以如果做不成老大，是很难办的。就像今天的云服务、大数据、机器人、无人机等行业，百家争鸣，确实热闹，我们都能看到这是未来发展的趋势，但无限的机会中并不代表你就可以借浪前行。 
　　 
  这时你会问，传统的巨头就这么看着你们蚕食它们的市场吗？答案很明显，是已经固化的基因和思维阻挡了他们的前行的脚步，就像人的性格和思维很难改变一样，公司的基因和思维方式也是很难改变的。在吴军的书中是这么写的：一个公司在一个领域越成功，它积累的文化、做事方式、流程、决策机制等，越适合这一个领域，那么在面对新市场时，越扭转不过来思维。&lt;/p&gt;
&lt;p&gt;  书中描述了一波波浪潮的特征。但就像说人这一辈子一样，虽然生来含着金汤匙，但不是一辈子就能永远顺风顺水。公司的发展不可能只靠浪潮来推进，这样的公司也做不大。管理、创始人的个人能力、资源等等，都是影响到一个公司的未来发展的者重要因素。但了解浪潮，可以避免自己在择业、创业过程中不要做出不自量力的事。 
　　 &lt;/p&gt;
&lt;h1 id="_3"&gt;三、我了解到了什么&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;“读史使人明智”，这句话不是白说的，至少我了解了一些大公司的过往，所谓的天使投资、风投等一些经济常识。这本可以说是IT界的《史记》，从过往的公司，历史留名的人物，描述了一个IT时代历史。当然，由于作者的时间和学识有限，从中了解历史十分有限，不够详细，很多时候要查一些资料才能更了解当时的情况，但大纲讲的已经比较清晰明了。&lt;/p&gt;
&lt;p&gt;最后，值得说的是，吴军的文笔实在太好了，读起他的文字完全是一种享受，很平实，很靠谱。&lt;/p&gt;</summary><category term="浪潮之巅"></category><category term="吴军"></category><category term="纪实"></category></entry><entry><title>雷米《心理罪》系列书评</title><link href="http://dhlx.wang/Book_Review/Psychological_Crime.html" rel="alternate"></link><updated>2015-07-18T17:39:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-07-18:Book_Review/Psychological_Crime.html</id><summary type="html">
&lt;p&gt;  好像从初中毕业后，也看过不少的书籍，有专业书籍，也有小说、散文等，但好像从初中毕业以后就没有写过读后感和书评了。今天把雷米写的心理罪系列的小说看完了，忽然想要写下我自己的书评，或许这个系列小说，给我的印象太深刻了吧！即使您不是一个喜欢看犯罪类、刑侦类小说的人，我个人也建议您有时间可以看下，您会喜欢上心理罪的。&lt;/p&gt;
&lt;p&gt;  &lt;a href="http://www.amazon.cn/dp/B00VSXL066/ref=tmm_kin_swatch_0?_encoding=UTF8&amp;amp;sr=8-1&amp;amp;qid=1437210148"&gt;心理罪&lt;/a&gt;，我个人认为是值得为之付出RMB的，故在此给出正版书籍的购买链接，希望大家可以支持下作者。&lt;/p&gt;
&lt;p&gt;  如果您的资金有限，又想赏读大师之作，你可以通过&lt;a href="http://pan.baidu.com/s/1AZo6q"&gt;百度网盘链接&lt;/a&gt;和密码(qshi)进行下载阅读试看，但个人真心希望您在看完免费的以后，会和我一样，购买一套正版书籍进行收藏。&lt;/p&gt;
&lt;p&gt;  不管您是否购买了正版书籍，您都应当下载下电子版的书籍，因为电子版中有四篇番外篇不曾出版，这四篇番外篇会帮助您更好的理解心理罪。以下是我推荐给您的心理罪系列小说的阅读顺序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;1、前传 第七个读者
2、番外一 毒树之果
3、心理罪一 画像
4、番外二 斯金纳之箱
5、心理罪二 教化场
6、番外三 月光的谎言
7、心理罪三 暗河
8、心理罪四 城市之光
9、番外四 两生花
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  心理罪系列小说既是连贯的，也是独立的。说它是连贯的，是因为这部小说，您必须从第一部开始都，才能真正的体会到作者对人性的理解。说它是各部分是独立的，是因为每部小说中发生的案件，与前后会有一些关联，单都可以独立成文，案件前后并无悬念。&lt;/p&gt;
&lt;p&gt;  主人公：方木，天才犯罪心理学家，也是一个悲剧的猪脚，或许天生自带灾难光环吧。但不影响我们看出他的个性以及天赋，在大学中就连破大案，看透人性。但随着时间和案件的发展，他的信仰摇摇欲坠，作者赋予他了破案的天赋，但缺利用这种天赋塑造了一个悲剧的开始，和一个还算美好的轮回。&lt;/p&gt;
&lt;p&gt;  或许很长时间没有写书评了，都不会写内容的简介了，那我再此也不要献丑了，详细的内容，还是由大家自己去看心理罪的书籍吧！我这里只能说，光明不存在，存在的或许只是黑暗中一盏指路的明灯。或许悲观，或许有些宗教，但是我们不正是这样劝自己活着幸福就好，但幸福是什么，谁也说不清，道不明。&lt;/p&gt;
&lt;p&gt;  看完本书之后，我只想说世上多是轮回，在罪恶之深处的轮回。也许没有他方木，就不会带来这么多死亡…… &lt;/p&gt;
&lt;p&gt;  最后说下，我推荐心理罪的原因吧，原因有三，一是非常好的犯罪小说，二是它同时也是一部非常好的悬疑小说，三是来看看这个叫方木这个男人吧！&lt;/p&gt;
&lt;p&gt;  感谢雷米（lane_lau）大侠给了我这么一本书，这么一个让我可以经历不同人生的书。我最喜欢的一句话就是一段光影，一段人生，我想现在我可以将它改为一段光阴，一段人生，一部书籍，一个世界。&lt;/p&gt;</summary><category term="心理罪"></category><category term="雷米"></category><category term="方木"></category></entry><entry><title>基于STM32CubeF4移植FreeModbus到STM32F411VET6</title><link href="http://dhlx.wang/STM32F411VET6/Porting_FreeModbus_to_STM32F411VET6_based_on_STM32CubeF4.html" rel="alternate"></link><updated>2015-07-06T17:35:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-07-06:STM32F411VET6/Porting_FreeModbus_to_STM32F411VET6_based_on_STM32CubeF4.html</id><summary type="html">
&lt;p&gt;首先，本人需要声明一下，本文所移植FreeModbus的过程仅能用作参考，虽然FreeModbus的库已经用在工程很多年，但是由于移植的代码，本人经验等问题，所以本人不建议您直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备移植程序和工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我在此次移植过程中，主要用到以下几个程序与工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1848/PF260946?s_searchtype=partnumber"&gt;32F411EDISCOVERY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.freemodbus.org/"&gt;FreeModbus v1.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.modbustools.com/"&gt;Modbus Poll v6.3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1533/PF259242?sc=stm32cube"&gt;STM32CubeMX_V4.8.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/en/catalog/tools/PF259243"&gt;STM32Cube_FW_F4_V1.6.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.keil.com/download/product/"&gt;Keil_MDK_ARM_V5.15.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在移植过程中，主要用到芯片的外设有USART1（PB6、PB7）和TIMER11，请您根据实际情况进行设置。其中TIMER的设置，您需要设置时钟的信号基准为50uS，时钟产生中断的时间为1750uS（串口波特率大于19200时，在mbrtu.c中有具体的描述），也就是35个基准时间。&lt;/p&gt;
&lt;h1 id="_2"&gt;二、拷贝需要的文件到工程目录下&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、解压缩通过下载得到的freemodbus-v1.5.zip。&lt;/p&gt;
&lt;p&gt;2、按照下列的文件列表拷贝相应的文件到对应的目录（没有路径，需要自己建），并在
keil中设置好相应的头文件引用路径和源码文件的引用。&lt;/p&gt;
&lt;p&gt;拷贝文件到工程文件夹示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;工程文件夹&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;mxproject&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;工程名&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ioc&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  
&lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;Drivers&lt;/span&gt;                         &lt;span class="c1"&gt;//底层驱动文件夹&lt;/span&gt;
&lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;Inc&lt;/span&gt;                             &lt;span class="c1"&gt;//头文件存放位置&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;gpio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;stm32f4xx_hal_conf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;stm32f4xx_it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;tim&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;usart&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      
&lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;Modbus&lt;/span&gt;                      &lt;span class="c1"&gt;//Modbus需要用到的头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;modbus_driver&lt;/span&gt;           &lt;span class="c1"&gt;//Modbus函数等头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;include&lt;/span&gt;              &lt;span class="c1"&gt;//Modbus通用函数头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;            
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbconfig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;      
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbframe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfunc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbport&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbproto&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbutils&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;rtu&lt;/span&gt;                  &lt;span class="c1"&gt;//Modbus RTU函数头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;          &lt;span class="nx"&gt;mbcrc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;          &lt;span class="nx"&gt;mbrtu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;│&lt;/span&gt;          
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;modbus_user&lt;/span&gt;             &lt;span class="c1"&gt;//Modbus用户配置头文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;              &lt;span class="nx"&gt;port&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;              
&lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;MDK&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;ARM&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;BPEER_USART_TEST&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;uvprojx&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;      
&lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;Src&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;gpio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;stm32f4xx_hal_msp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;stm32f4xx_it&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;tim&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;usart&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
    &lt;span class="err"&gt;│&lt;/span&gt;      
    &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;Modbus&lt;/span&gt;                      &lt;span class="c1"&gt;//Modbus需要用到的源码文件&lt;/span&gt;
        &lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;modbus_driver&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="nx"&gt;mb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;                &lt;span class="c1"&gt;//Modbus基本函数和设置源码文件&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;  
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;├─&lt;/span&gt;&lt;span class="nx"&gt;functions&lt;/span&gt;            &lt;span class="c1"&gt;//Modbus通用函数源码文件&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfunccoils&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncdiag&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncdisc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncholding&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncinput&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbfuncother&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      &lt;span class="nx"&gt;mbutils&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;│&lt;/span&gt;      
        &lt;span class="err"&gt;│&lt;/span&gt;  &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;rtu&lt;/span&gt;                  &lt;span class="c1"&gt;//Modbus RTU函数源码文件&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;          &lt;span class="nx"&gt;mbcrc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;          &lt;span class="nx"&gt;mbrtu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
        &lt;span class="err"&gt;│&lt;/span&gt;          
        &lt;span class="err"&gt;└─&lt;/span&gt;&lt;span class="nx"&gt;modbus_user&lt;/span&gt;             &lt;span class="c1"&gt;//Modbus用户配置源码文件&lt;/span&gt;
                &lt;span class="nx"&gt;portevent&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
                &lt;span class="nx"&gt;portserial&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
                &lt;span class="nx"&gt;porttimer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="timer"&gt;三、搞定Timer&lt;a class="headerlink" href="#timer" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Timer的移植过程中，应该算是比较简单的了，需要简单的设置一下初始化的返回值，完整写出开启Timer的函数，停止Timer的函数，并对Timer回掉函数进行设置下，就OK了。&lt;/p&gt;
&lt;p&gt;porttimer.c移植后的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* ----------------------- Platform includes ----------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "port.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "tim.h"&lt;/span&gt;
&lt;span class="cm"&gt;/* ----------------------- Modbus includes ------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "mb.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "mbport.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* ----------------------- static functions -----------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* ----------------------- Private define -------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef Modbus_TimHandle&lt;/span&gt;
    &lt;span class="cp"&gt;#define Modbus_TimHandle htim11&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cm"&gt;/* ----------------------- Start implementation -------------------------*/&lt;/span&gt;
&lt;span class="n"&gt;BOOL&lt;/span&gt;
&lt;span class="nf"&gt;xMBPortTimersInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usTim1Timerout50us&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*系统初始化已经完成定时器的初始化，故在此不在进行初始化*/&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;vMBPortTimersEnable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Enable the timer with the timeout passed to xMBPortTimersInit( ) */&lt;/span&gt;
    &lt;span class="cm"&gt;/*Disable Timer and Reset Counter*/&lt;/span&gt;
    &lt;span class="n"&gt;HAL_TIM_Base_Stop_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_TimHandle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;__HAL_TIM_SET_COUNTER&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_TimHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x0000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/*Enable Timer*/&lt;/span&gt;
    &lt;span class="n"&gt;HAL_TIM_Base_Start_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_TimHandle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;vMBPortTimersDisable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Disable any pending timers. */&lt;/span&gt;   
    &lt;span class="n"&gt;HAL_TIM_Base_Stop_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_TimHandle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Create an ISR which is called whenever the timer has expired. This function&lt;/span&gt;
&lt;span class="cm"&gt; * must then call pxMBPortCBTimerExpired( ) to notify the protocol stack that&lt;/span&gt;
&lt;span class="cm"&gt; * the timer has expired.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvTIMERExpiredISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;pxMBPortCBTimerExpired&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;stm32f4xx_it.c移植后的部分代码如下所示：
    #!c
    /&lt;em&gt; Includes ------------------------------------------------------------------&lt;/em&gt;/
    #include "stm32f4xx_hal.h"
    #include "stm32f4xx.h"
    #include "stm32f4xx_it.h"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* USER CODE BEGIN 0 */&lt;/span&gt;

&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;include&lt;/span&gt; &lt;span class="s2"&gt;"mb.h"&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nx"&gt;include&lt;/span&gt; &lt;span class="s2"&gt;"mbport.h"&lt;/span&gt;

&lt;span class="nx"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;prvvUARTRxISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;prvvTIMERExpiredISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* USER CODE END 0 */&lt;/span&gt;
&lt;span class="err"&gt;……&lt;/span&gt; &lt;span class="err"&gt;……&lt;/span&gt; &lt;span class="err"&gt;……&lt;/span&gt;
&lt;span class="cm"&gt;/* USER CODE BEGIN 1 */&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;HAL_TIM_PeriodElapsedCallback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;TIM_HandleTypeDef&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;htim&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* NOTE : This function Should not be modified, when the callback is needed,&lt;/span&gt;
&lt;span class="cm"&gt;            the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
    &lt;span class="nx"&gt;prvvTIMERExpiredISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cm"&gt;/* USER CODE END 1 */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_3"&gt;四、搞定串口&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;串口比较难搞一些了，需要设置中断处理函数、串口初始化函数、串口输入输出函数、串口中断服务函数。&lt;/p&gt;
&lt;p&gt;portserial.c移植后的代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include "port.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_it.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* ----------------------- Modbus includes ------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "mb.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "mbport.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* ----------------------- static functions -----------------------------*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvUARTRxISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* ----------------------- Private define -------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef Modbus_UartHandle&lt;/span&gt;
    &lt;span class="cp"&gt;#define Modbus_UartHandle huart1&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cm"&gt;/* ----------------------- Start implementation -------------------------*/&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;vMBPortSerialEnable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;xRxEnable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;xTxEnable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* If xRXEnable enable serial receive interrupts. If xTxENable enable&lt;/span&gt;
&lt;span class="cm"&gt;     * transmitter empty interrupts.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;xRxEnable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Enable the UART Data Register not empty Interrupt */&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_UART_ENABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_RXNE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Disable the UART Data Register not empty Interrupt */&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_UART_DISABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_RXNE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;xTxEnable&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Enable the UART Transmit data register empty Interrupt */&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_UART_ENABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_TXE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Disable the UART Transmit data register empty Interrupt */&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_UART_DISABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_TXE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="cm"&gt;/* Enable the UART Transmit Complete Interrupt */&lt;/span&gt;    
        &lt;span class="n"&gt;__HAL_UART_ENABLE_IT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_TC&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt;
&lt;span class="nf"&gt;xMBPortSerialInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucPORT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ULONG&lt;/span&gt; &lt;span class="n"&gt;ulBaudRate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucDataBits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;eMBParity&lt;/span&gt; &lt;span class="n"&gt;eParity&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*由于已经在系统初始化中已经完成串口初始化，故在此不需要再一次进行初始化*/&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt;
&lt;span class="nf"&gt;xMBPortSerialPutByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;CHAR&lt;/span&gt; &lt;span class="n"&gt;ucByte&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Put a byte in the UARTs transmit buffer. This function is called&lt;/span&gt;
&lt;span class="cm"&gt;     * by the protocol stack if pxMBFrameCBTransmitterEmpty( ) has been&lt;/span&gt;
&lt;span class="cm"&gt;     * called. */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAL_UART_Transmit&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt; &lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ucByte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;BOOL&lt;/span&gt;
&lt;span class="nf"&gt;xMBPortSerialGetByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;CHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucByte&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Return the byte in the UARTs receive buffer. This function is called&lt;/span&gt;
&lt;span class="cm"&gt;     * by the protocol stack after pxMBFrameCBByteReceived( ) has been called.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAL_UART_Receive&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;Modbus_UartHandle&lt;/span&gt; &lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;pucByte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Create an interrupt handler for the transmit buffer empty interrupt&lt;/span&gt;
&lt;span class="cm"&gt; * (or an equivalent) for your target processor. This function should then&lt;/span&gt;
&lt;span class="cm"&gt; * call pxMBFrameCBTransmitterEmpty( ) which tells the protocol stack that&lt;/span&gt;
&lt;span class="cm"&gt; * a new character can be sent. The protocol stack will then call &lt;/span&gt;
&lt;span class="cm"&gt; * xMBPortSerialPutByte( ) to send the character.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pxMBFrameCBTransmitterEmpty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Create an interrupt handler for the receive interrupt for your target&lt;/span&gt;
&lt;span class="cm"&gt; * processor. This function should then call pxMBFrameCBByteReceived( ). The&lt;/span&gt;
&lt;span class="cm"&gt; * protocol stack will then call xMBPortSerialGetByte( ) to retrieve the&lt;/span&gt;
&lt;span class="cm"&gt; * character.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;prvvUARTRxISR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pxMBFrameCBByteReceived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;stm32f4xx_it.c移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief This function handles USART1 global interrupt.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;USART1_IRQHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE BEGIN USART1_IRQn 0 */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__HAL_UART_GET_IT_SOURCE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;huart1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_RXNE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;RESET&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;prvvUARTRxISR&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//接收中断处理函数&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__HAL_UART_GET_IT_SOURCE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;huart1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UART_IT_TXE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;RESET&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;prvvUARTTxReadyISR&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//发送完成终端处理函数&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;HAL_NVIC_ClearPendingIRQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USART1_IRQn&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE END USART1_IRQn 0 */&lt;/span&gt;
  &lt;span class="n"&gt;HAL_UART_IRQHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;huart1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE BEGIN USART1_IRQn 1 */&lt;/span&gt;

  &lt;span class="cm"&gt;/* USER CODE END USART1_IRQn 1 */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="_4"&gt;五、搞定其他配置&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、搞定开关中断操作&lt;/p&gt;
&lt;p&gt;port.h移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*禁用全部中断*/&lt;/span&gt;
&lt;span class="cp"&gt;#define ENTER_CRITICAL_SECTION( )   __disable_irq()&lt;/span&gt;
&lt;span class="cm"&gt;/*开启全部中断*/&lt;/span&gt;
&lt;span class="cp"&gt;#define EXIT_CRITICAL_SECTION( )    __enable_irq()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;2、搞定系统配置&lt;/p&gt;
&lt;p&gt;mb.c移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*设置启用Modbus RTU 模式，减少编译后的代码量*/&lt;/span&gt;
&lt;span class="cp"&gt;#if MB_RTU_ENABLED == 1&lt;/span&gt;
    &lt;span class="cp"&gt;#include "mbrtu.h"&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cm"&gt;/*减少编译后代码错误以及修改，将判定值由1改为0，并修改MB_ASCII_ENABLED的定义为0，&lt;/span&gt;
&lt;span class="cm"&gt;想要了解原因，请自行修改编译查看*/&lt;/span&gt;
&lt;span class="cp"&gt;#if MB_ASCII_ENABLED == 1&lt;/span&gt;
    &lt;span class="cp"&gt;#include "mbascii.h"&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cm"&gt;/*减少编译后代码大小，将判定值由0改为1，并修改MB_TCP_ENABLED的定义为0，想要了解&lt;/span&gt;
&lt;span class="cm"&gt;原因，请自行修改编译查看*/&lt;/span&gt;
&lt;span class="cp"&gt;#if MB_TCP_ENABLED == 1&lt;/span&gt;
    &lt;span class="cp"&gt;#include "mbtcp.h"&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;3、搞定寄存器地址差一的问题&lt;/p&gt;
&lt;p&gt;需要在源码中注释掉所有的&lt;code&gt;usRegAddress++;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;4、搞定keil编译过程中出现的各种警告&lt;/p&gt;
&lt;p&gt;mb.h移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
&lt;span class="nf"&gt;xMBUtilSetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ucByteBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucNBits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
                &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucValue&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt;
&lt;span class="nf"&gt;xMBUtilGetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ucByteBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucNBits&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;mbrtu.c移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRTUReceive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRcvAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;pucFrame&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pusLength&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*处女座心理，必须要求无错误、无警告、可过PC-Lint，目前也没有发现这个定义的用处*/&lt;/span&gt;
    &lt;span class="c1"&gt;//    BOOL            xFrameReceived = FALSE;&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;    &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;ENTER_CRITICAL_SECTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usRcvBufferPos&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;MB_SER_PDU_SIZE_MAX&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Length and CRC check */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usRcvBufferPos&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_SER_PDU_SIZE_MIN&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usMBCRC16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usRcvBufferPos&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Save the address field. All frames are passed to the upper layed&lt;/span&gt;
&lt;span class="cm"&gt;         * and the decision if a frame is used is done there.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRcvAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MB_SER_PDU_ADDR_OFF&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

        &lt;span class="cm"&gt;/* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus&lt;/span&gt;
&lt;span class="cm"&gt;         * size of address field and CRC checksum.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pusLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRcvBufferPos&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;MB_SER_PDU_PDU_OFF&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;MB_SER_PDU_SIZE_CRC&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* Return the start of the Modbus PDU to the caller. */&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucFrame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MB_SER_PDU_PDU_OFF&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;//        xFrameReceived = TRUE;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_EIO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;EXIT_CRITICAL_SECTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;5、未知原因的添加代码&lt;/p&gt;
&lt;p&gt;这部分代码没有明白，为什么需要添加，有些没有研究透，希望有大神可以指点。&lt;/p&gt;
&lt;p&gt;mbrtu.c移植后的部分代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRTUSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="n"&gt;ucSlaveAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucFrame&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usLength&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;    &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;USHORT&lt;/span&gt;          &lt;span class="n"&gt;usCRC16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;ENTER_CRITICAL_SECTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Check if the receiver is still in idle state. If not we where to&lt;/span&gt;
&lt;span class="cm"&gt;     * slow with processing the received frame and the master sent another&lt;/span&gt;
&lt;span class="cm"&gt;     * frame on the network. We have to abort sending the frame.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;eRcvState&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;STATE_RX_IDLE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* First byte before the Modbus-PDU is the slave address. */&lt;/span&gt;
        &lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pucFrame&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;usSndBufferCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */&lt;/span&gt;
        &lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MB_SER_PDU_ADDR_OFF&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ucSlaveAddress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;usSndBufferCount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;usLength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */&lt;/span&gt;
        &lt;span class="n"&gt;usCRC16&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;usMBCRC16&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usSndBufferCount&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;usSndBufferCount&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usCRC16&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;ucRTUBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;usSndBufferCount&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usCRC16&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/* Activate the transmitter. */&lt;/span&gt;
        &lt;span class="n"&gt;eSndState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STATE_TX_XMIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="cm"&gt;/*插入代码 启动第一次发送，这样才可以进入发送完成中断*/&lt;/span&gt;
        &lt;span class="n"&gt;xMBPortSerialPutByte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;CHAR&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;pucSndBufferCur&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
        &lt;span class="n"&gt;usSndBufferCount&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;vMBPortSerialEnable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_EIO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;EXIT_CRITICAL_SECTION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="_5"&gt;六、搞定主函数&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;主函数需要设置数组和处理函数，无其他设置，我放上我移植的代码以供参考。&lt;/p&gt;
&lt;p&gt;main.c移植后的代码如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "adc.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "tim.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "gpio.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN Includes */&lt;/span&gt;

&lt;span class="cp"&gt;#include "mb.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "mbport.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END Includes */&lt;/span&gt;

&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN PV */&lt;/span&gt;

&lt;span class="cm"&gt;/*线圈状态寄存器*/&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_COILS_START 0x0000&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_COILS_SIZE 8&lt;/span&gt;

&lt;span class="cm"&gt;/*线圈状态输入寄存器*/&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_DISCRETE_START 0x0000&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_DISCRETE_SIZE 8&lt;/span&gt;

&lt;span class="cm"&gt;/*保持寄存器*/&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_HOLDING_START 0x0000&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_HOLDING_NREGS 10&lt;/span&gt;

&lt;span class="cm"&gt;/*输入寄存器*/&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_INPUT_START 0x0000&lt;/span&gt;
&lt;span class="cp"&gt;#define REG_INPUT_NREGS 1&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END PV */&lt;/span&gt;

&lt;span class="cm"&gt;/* Private function prototypes ------------------------------------------*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SystemClock_Config&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN PFP */&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END PFP */&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN 0 */&lt;/span&gt;

&lt;span class="cm"&gt;/*定义线圈状态寄存器的地址起始值和存储数组*/&lt;/span&gt;
&lt;span class="kt"&gt;uint8_t&lt;/span&gt;   &lt;span class="n"&gt;ucRegCoilsStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;uint8_t&lt;/span&gt;   &lt;span class="n"&gt;ucRegCoilsBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;REG_COILS_SIZE&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/*定义线圈输入状态寄存器的地址起始值和存储数组*/&lt;/span&gt;
&lt;span class="kt"&gt;uint8_t&lt;/span&gt;   &lt;span class="n"&gt;ucRegDiscreteStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;uint8_t&lt;/span&gt;   &lt;span class="n"&gt;ucRegDiscreteBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;REG_DISCRETE_SIZE&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/*定义保持寄存器的地址起始值和存储数组*/&lt;/span&gt;
&lt;span class="kt"&gt;uint16_t&lt;/span&gt;   &lt;span class="n"&gt;usRegHoldingStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;uint16_t&lt;/span&gt;   &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;REG_HOLDING_NREGS&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/*定义输入寄存器的地址起始值和存储数组*/&lt;/span&gt;
&lt;span class="kt"&gt;uint16_t&lt;/span&gt;   &lt;span class="n"&gt;usRegInputStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_INPUT_START&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;uint16_t&lt;/span&gt;   &lt;span class="n"&gt;usRegInputBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;REG_INPUT_NREGS&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END 0 */&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE BEGIN 1 */&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE END 1 */&lt;/span&gt;

    &lt;span class="cm"&gt;/* MCU Configuration-------------------------------------------------*/&lt;/span&gt;

    &lt;span class="cm"&gt;/* Reset of all peripherals, Initializes the Flash interface and the Systick. */&lt;/span&gt;
    &lt;span class="n"&gt;HAL_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* Configure the system clock */&lt;/span&gt;
    &lt;span class="n"&gt;SystemClock_Config&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* Initialize all configured peripherals */&lt;/span&gt;
    &lt;span class="n"&gt;MX_GPIO_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_ADC1_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_TIM1_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_TIM4_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_TIM11_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;MX_USART1_UART_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE BEGIN 2 */&lt;/span&gt;

    &lt;span class="cm"&gt;/*设置Modnbus以RTU模式运行，从机ID为0x01，串口为默认串口，串口波特率为115200，无奇偶校验*/&lt;/span&gt;
    &lt;span class="n"&gt;eMBInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MB_RTU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;115200&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MB_PAR_NONE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Enable the Modbus Protocol Stack. */&lt;/span&gt;
    &lt;span class="n"&gt;eMBEnable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="cm"&gt;/* USER CODE END 2 */&lt;/span&gt;

    &lt;span class="cm"&gt;/* Infinite loop */&lt;/span&gt;
    &lt;span class="cm"&gt;/* USER CODE BEGIN WHILE */&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;eMBPoll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_TIM_SetCompare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TIM_CHANNEL_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_TIM_SetCompare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TIM_CHANNEL_2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_TIM_SetCompare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TIM_CHANNEL_3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;__HAL_TIM_SetCompare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TIM_CHANNEL_4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;HAL_TIM_PWM_Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIM_CHANNEL_1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;HAL_TIM_PWM_Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIM_CHANNEL_2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;HAL_TIM_PWM_Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIM_CHANNEL_3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;HAL_TIM_PWM_Start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;htim4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TIM_CHANNEL_4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE END WHILE */&lt;/span&gt;

    &lt;span class="cm"&gt;/* USER CODE BEGIN 3 */&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cm"&gt;/* USER CODE END 3 */&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/** System Clock Configuration&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SystemClock_Config&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="n"&gt;RCC_OscInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="n"&gt;__PWR_CLK_ENABLE&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="n"&gt;__HAL_PWR_VOLTAGESCALING_CONFIG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PWR_REGULATOR_VOLTAGE_SCALE2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OscillatorType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_OSCILLATORTYPE_HSI&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HSIState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_HSI_ON&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;HSICalibrationValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_PLL_ON&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_PLLSOURCE_HSI&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_PLLP_DIV4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLL&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PLLQ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;HAL_RCC_OscConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;RCC_OscInitStruct&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ClockType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_CLOCKTYPE_SYSCLK&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;RCC_CLOCKTYPE_PCLK1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SYSCLKSource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_SYSCLKSOURCE_PLLCLK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AHBCLKDivider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_SYSCLK_DIV1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;APB1CLKDivider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_HCLK_DIV2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;APB2CLKDivider&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RCC_HCLK_DIV1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;HAL_RCC_ClockConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;RCC_ClkInitStruct&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FLASH_LATENCY_3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;HAL_SYSTICK_Config&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAL_RCC_GetHCLKFreq&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;HAL_SYSTICK_CLKSourceConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SYSTICK_CLKSOURCE_HCLK&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE BEGIN 4 */&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief 输入寄存器处理函数，输入寄存器可读，但不可写。&lt;/span&gt;
&lt;span class="cm"&gt;* @param pucRegBuffer 返回数据指针&lt;/span&gt;
&lt;span class="cm"&gt;* usAddress 寄存器起始地址&lt;/span&gt;
&lt;span class="cm"&gt;* usNRegs 寄存器长度&lt;/span&gt;
&lt;span class="cm"&gt;* @retval eStatus 寄存器状态&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRegInputCB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;    &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt;             &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;//  用作例子&lt;/span&gt;
    &lt;span class="n"&gt;usRegInputBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//  例子结束&lt;/span&gt;

    &lt;span class="c1"&gt;//查询是否在寄存器范围内&lt;/span&gt;
    &lt;span class="c1"&gt;//为了避免警告，修改为有符号整数&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_INPUT_START&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; \
        &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;REG_INPUT_START&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;REG_INPUT_NREGS&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//获得操作偏移量，本次操作起始地址-输入寄存器的初始地址&lt;/span&gt;
        &lt;span class="n"&gt;iRegIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;usRegInputStart&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;//逐个赋值&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//赋值高字节&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRegInputBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="c1"&gt;//赋值低字节&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRegInputBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="c1"&gt;//偏移量增加&lt;/span&gt;
            &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;//被操作寄存器数量递减&lt;/span&gt;
            &lt;span class="n"&gt;usNRegs&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//返回错误状态，寄存器数量不对&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOREG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief 保持寄存器处理函数，保持寄存器可读，可读可写&lt;/span&gt;
&lt;span class="cm"&gt;* @param pucRegBuffer 读操作时--返回数据指针，写操作时--输入数据指针&lt;/span&gt;
&lt;span class="cm"&gt;* usAddress 寄存器起始地址&lt;/span&gt;
&lt;span class="cm"&gt;* usNRegs 寄存器长度&lt;/span&gt;
&lt;span class="cm"&gt;* eMode 操作方式，读或者写&lt;/span&gt;
&lt;span class="cm"&gt;* @retval eStatus 寄存器状态&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt; 
&lt;span class="nf"&gt;eMBRegHoldingCB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;eMBRegisterMode&lt;/span&gt; &lt;span class="n"&gt;eMode&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//错误状态&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//偏移量&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//判断寄存器是不是在范围内&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; \
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_NREGS&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//计算偏移量&lt;/span&gt;
        &lt;span class="n"&gt;iRegIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REG_HOLDING_START&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;eMode&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//读处理函数 &lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;MB_REG_READ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;usNRegs&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="c1"&gt;//写处理函数 &lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;MB_REG_WRITE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usNRegs&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;usRegHoldingBuf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;iRegIndex&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;usNRegs&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//返回错误状态&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOREG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief 线圈寄存器处理函数，线圈寄存器可读，可读可写&lt;/span&gt;
&lt;span class="cm"&gt;* @param pucRegBuffer 读操作---返回数据指针，写操作--返回数据指针&lt;/span&gt;
&lt;span class="cm"&gt;* usAddress 寄存器起始地址&lt;/span&gt;
&lt;span class="cm"&gt;* usNRegs 寄存器长度&lt;/span&gt;
&lt;span class="cm"&gt;* eMode 操作方式，读或者写&lt;/span&gt;
&lt;span class="cm"&gt;* @retval eStatus 寄存器状态&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRegCoilsCB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usNCoils&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;eMBRegisterMode&lt;/span&gt; &lt;span class="n"&gt;eMode&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//错误状态&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//寄存器个数&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usNCoils&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//寄存器偏移量&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//检查寄存器是否在指定范围内&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_COILS_START&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;REG_COILS_START&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;REG_COILS_SIZE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//计算寄存器偏移量&lt;/span&gt;
        &lt;span class="n"&gt;usBitOffset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REG_COILS_START&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;eMode&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//读操作&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;MB_REG_READ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xMBUtilGetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;ucRegCoilsBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;usBitOffset&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="c1"&gt;//写操作&lt;/span&gt;
            &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;MB_REG_WRITE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;xMBUtilSetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;ucRegCoilsBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="p"&gt;),&lt;/span&gt;
                    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;iNCoils&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOREG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief 开关输入寄存器处理函数，开关输入寄存器，可读&lt;/span&gt;
&lt;span class="cm"&gt;* @param pucRegBuffer 读操作---返回数据指针，写操作--返回数据指针&lt;/span&gt;
&lt;span class="cm"&gt;* usAddress 寄存器起始地址&lt;/span&gt;
&lt;span class="cm"&gt;* usNRegs 寄存器长度&lt;/span&gt;
&lt;span class="cm"&gt;* eMode 操作方式，读或者写&lt;/span&gt;
&lt;span class="cm"&gt;* @retval eStatus 寄存器状态&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="n"&gt;eMBErrorCode&lt;/span&gt;
&lt;span class="nf"&gt;eMBRegDiscreteCB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;UCHAR&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;USHORT&lt;/span&gt; &lt;span class="n"&gt;usNDiscrete&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//错误状态&lt;/span&gt;
    &lt;span class="n"&gt;eMBErrorCode&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOERR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//操作寄存器个数&lt;/span&gt;
    &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int16_t&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usNDiscrete&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//偏移量&lt;/span&gt;
    &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//判断寄存器时候再制定范围内&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int16_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;REG_DISCRETE_START&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;usNDiscrete&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;REG_DISCRETE_START&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;REG_DISCRETE_SIZE&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//获得偏移量&lt;/span&gt;
        &lt;span class="n"&gt;usBitOffset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint16_t&lt;/span&gt; &lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;usAddress&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;REG_DISCRETE_START&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pucRegBuffer&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xMBUtilGetBits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;ucRegDiscreteBuf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;usBitOffset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;iNDiscrete&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;usBitOffset&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;eStatus&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MB_ENOREG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;eStatus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* USER CODE END 4 */&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef USE_FULL_ASSERT&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * @brief Reports the name of the source file and the source line number&lt;/span&gt;
&lt;span class="cm"&gt;   * where the assert_param error has occurred.&lt;/span&gt;
&lt;span class="cm"&gt;   * @param file: pointer to the source file name&lt;/span&gt;
&lt;span class="cm"&gt;   * @param line: assert_param error line source number&lt;/span&gt;
&lt;span class="cm"&gt;   * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;assert_failed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE BEGIN 6 */&lt;/span&gt;
  &lt;span class="cm"&gt;/* User can add his own implementation to report the file name and line number,&lt;/span&gt;
&lt;span class="cm"&gt;    ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */&lt;/span&gt;
  &lt;span class="cm"&gt;/* USER CODE END 6 */&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @}&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @}&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cm"&gt;/*************** (C) COPYRIGHT STMicroelectronics *****END OF FILE********/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="_6"&gt;七、结语&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。&lt;/p&gt;</summary><category term="FreeModbus"></category><category term="STM32F411VET6"></category><category term="STM32CubeF4"></category></entry><entry><title>移植AN4657到STM32F411VET6</title><link href="http://dhlx.wang/STM32F411VET6/Porting_AN4657_STM32Cube_IAP_using_UART_to_STM32F411VET6.html" rel="alternate"></link><updated>2015-07-24T12:12:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-07-03:STM32F411VET6/Porting_AN4657_STM32Cube_IAP_using_UART_to_STM32F411VET6.html</id><summary type="html">
&lt;p&gt;首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备移植程序和工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们在移植AN4657到STM32F411VET6的过程中主要用到以下程序和工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1848/PF260946?s_searchtype=partnumber"&gt;32F411EDISCOVERY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/en/catalog/tools/FM147/CL1794/SC961/SS1743/LN1920/PF262163?s_searchtype=keyword"&gt;X-CUBE-IAP-USART(AN4657)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hilgraeve.com/hyperterminal/"&gt;Hypertrm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1533/PF259242?sc=stm32cube"&gt;STM32CubeMX_V4.8.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/en/catalog/tools/PF259243"&gt;STM32Cube_FW_F4_V1.6.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.keil.com/download/product/"&gt;Keil_MDK_ARM_V5.15.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AN4657-STM32Cube_IAP_using_UART\Projects\STM3210C_EVAL\IAP_Main\Inc
AN4657-STM32Cube_IAP_using_UART\Projects\STM3210C_EVAL\IAP_Main\Src&lt;/p&gt;
&lt;h1 id="_2"&gt;二、拷贝需要的文件到工程目录下&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、解压缩通过下载得到的AN4657压缩包。&lt;/p&gt;
&lt;p&gt;2、拷贝路径（AN4657-STM32Cube_IAP_using_UART\Projects\STM3210C_EVAL\IAP_Main\Inc）中的&lt;code&gt;common.h&lt;/code&gt;、&lt;code&gt;flash_if.h&lt;/code&gt;、&lt;code&gt;menu.h&lt;/code&gt;、&lt;code&gt;ymodem.h&lt;/code&gt;到我们自己的工程路径下的Inc文件夹中。&lt;/p&gt;
&lt;p&gt;3、拷贝路径（AN4657-STM32Cube_IAP_using_UART\Projects\STM3210C_EVAL\IAP_Main\Src）中的&lt;code&gt;common.c&lt;/code&gt;、&lt;code&gt;flash_if.c&lt;/code&gt;、&lt;code&gt;menu.c&lt;/code&gt;、&lt;code&gt;ymodem.c&lt;/code&gt;到我们自己的工程路径下的Src文件夹中，并在keil中添加相应的文件。&lt;/p&gt;
&lt;h1 id="_3"&gt;三、修改串口的基本设置&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;串口的基本设置在STM32Cube可以进行设置，并生成相应的设置代码，但在我们的移植文件中需要用到串口设置，故我们需要在&lt;code&gt;common.c&lt;/code&gt;、&lt;code&gt;menu.c&lt;/code&gt;、&lt;code&gt;ymodem.c&lt;/code&gt;三个文件中进行修改，我的示例代码是用USART1作为演示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;common.c&lt;/code&gt;修改部分如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** @addtogroup STM32F4xx_IAP_Main&lt;/span&gt;
&lt;span class="cm"&gt;* @{&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和&lt;/span&gt;
&lt;span class="c1"&gt;//usart.h的引用。&lt;/span&gt;
&lt;span class="cp"&gt;#include "common.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Private typedef ------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private define -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置&lt;/span&gt;
&lt;span class="c1"&gt;//文件&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef UartHandle&lt;/span&gt;
    &lt;span class="cp"&gt;#define UartHandle huart1&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cm"&gt;/* Private macro --------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private function prototypes ------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private functions ----------------------------------------------------*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;menu.c&lt;/code&gt;修改部分如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** @addtogroup STM32F4xx_IAP&lt;/span&gt;
&lt;span class="cm"&gt;* @{&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和&lt;/span&gt;
&lt;span class="c1"&gt;//usart.h的引用。&lt;/span&gt;
&lt;span class="cp"&gt;#include "common.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "flash_if.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "menu.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "ymodem.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Private typedef ------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private define -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置&lt;/span&gt;
&lt;span class="c1"&gt;//文件&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef UartHandle&lt;/span&gt;
  &lt;span class="cp"&gt;#define UartHandle huart1&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cm"&gt;/* Private macro --------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;ymodem.c&lt;/code&gt;修改部分如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** @addtogroup STM32F4xx_IAP&lt;/span&gt;
&lt;span class="cm"&gt;* @{&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//根据实际情况修改引用的头文件，在原先程序中删除main.h的引用，加入stm32f4xx_hal.h和&lt;/span&gt;
&lt;span class="c1"&gt;//usart.h的引用。&lt;/span&gt;
&lt;span class="cp"&gt;#include "flash_if.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "common.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "ymodem.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "string.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "menu.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;
&lt;span class="cp"&gt;#include "usart.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Private typedef ------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private define -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//为了修改方便，直接对UartHandle进行#define操作，镜像到实际使用的串口配置&lt;/span&gt;
&lt;span class="c1"&gt;//文件&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef UartHandle&lt;/span&gt;
  &lt;span class="cp"&gt;#define UartHandle huart1&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cp"&gt;#define CRC16_F       &lt;/span&gt;&lt;span class="cm"&gt;/* activate the CRC16 integrity */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Private macro --------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;P.S. &lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;common.h&lt;/code&gt;、&lt;code&gt;menu.h&lt;/code&gt;、&lt;code&gt;ymodem.h&lt;/code&gt;基本不需要任何修改，直接就可以用。&lt;/p&gt;
&lt;p&gt;2、如果使用&lt;code&gt;32F411EDISCOVERY&lt;/code&gt;，请您注意不要使用默认的USART1的IO设置，需要更改为
PB6、PB7，才可以正常使用，默认的TX引脚上接了一个uF级的电容，我因为这个事情调试了很长时间。&lt;/p&gt;
&lt;h1 id="flash"&gt;三、修改FLASH操作函数及其定义&lt;a class="headerlink" href="#flash" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在整个移植过程中，重头戏就是对&lt;code&gt;flash_if.h&lt;/code&gt;和&lt;code&gt;flash_if.c&lt;/code&gt;的移植，里面涉及到很多
处修改，大部分修改是因为M4系列的MCU对FLASH的操作，没有页（Page）的概念，只有扇区（Sector）的操作函数造成的。&lt;/p&gt;
&lt;p&gt;所以，综上所述需要先将各种Page（PAGE、page）换成Sector，这样基本上可以解决掉一批错误。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flash_if.h&lt;/code&gt;修改后如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Define to prevent recursive inclusion --------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef __FLASH_IF_H&lt;/span&gt;
&lt;span class="cp"&gt;#define __FLASH_IF_H&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//修改引用的头文件为F4的&lt;/span&gt;
&lt;span class="cp"&gt;#include "stm32f4xx_hal.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Exported types -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Exported constants ---------------------------------------------------*/&lt;/span&gt;

&lt;span class="cm"&gt;/* Base address of the Flash sectors */&lt;/span&gt;
&lt;span class="c1"&gt;//定义扇区名和地址之间的关系，方便根据地址获取扇区的编号&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_0     ((uint32_t)0x08000000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 0, 16 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_1     ((uint32_t)0x08004000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 1, 16 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_2     ((uint32_t)0x08008000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 2, 16 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_3     ((uint32_t)0x0800C000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 3, 16 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_4     ((uint32_t)0x08010000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 4, 64 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_5     ((uint32_t)0x08020000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 5, 128 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_6     ((uint32_t)0x08040000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 6, 128 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define ADDR_FLASH_SECTOR_7     ((uint32_t)0x08060000) &lt;/span&gt;&lt;span class="cm"&gt;/* Base @ of Sector 7, 128 Kbyte */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/* Error code */&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_OK&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_ERASEKO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_WRITINGCTRL_ERROR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_WRITING_ERROR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_ERRROR&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/* protection type */&lt;/span&gt;  
&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_NONE&lt;/span&gt;         &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_PCROPENABLED&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_WRPENABLED&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;FLASHIF_PROTECTION_RDPENABLED&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/* protection update */&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;FLASHIF_WRP_ENABLE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;FLASHIF_WRP_DISABLE&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/* Define the address from where user application will be loaded.&lt;/span&gt;
&lt;span class="cm"&gt;   Note: the 1st sector 0x08000000-0x08003FFF is reserved for the IAP code */&lt;/span&gt;         
&lt;span class="c1"&gt;//根据实际的片内Flash大小修改结束地址，并删除不用的宏定义&lt;/span&gt;
&lt;span class="cp"&gt;#define APPLICATION_ADDRESS           (uint32_t)0x08004000      &lt;/span&gt;&lt;span class="cm"&gt;/* Start user code address */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/* Notable Flash addresses */&lt;/span&gt;
&lt;span class="cp"&gt;#define USER_FLASH_END_ADDRESS        (uint32_t)0x0807FFFF&lt;/span&gt;

&lt;span class="cm"&gt;/* Define the user application size */&lt;/span&gt;
&lt;span class="cp"&gt;#define USER_FLASH_SIZE               (USER_FLASH_END_ADDRESS - APPLICATION_ADDRESS + 1) &lt;/span&gt;&lt;span class="cm"&gt;/* Small default template application */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;


&lt;span class="cm"&gt;/* Exported macro -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* ABSoulute value */&lt;/span&gt;
&lt;span class="cp"&gt;#define ABS_RETURN(x,y)               ((x) &amp;lt; (y)) ? ((y)-(x)) : ((x)-(y))&lt;/span&gt;

&lt;span class="cm"&gt;/* Get the number of sectors from where the user program will be loaded */&lt;/span&gt;
&lt;span class="cp"&gt;#define FLASH_SECTOR_NUMBER           ((uint32_t)(ABS_RETURN(APPLICATION_ADDRESS,FLASH_START_BANK1))&amp;gt;&amp;gt;12)&lt;/span&gt;

&lt;span class="cm"&gt;/* Compute the mask to test if the Flash memory, where the user program will be&lt;/span&gt;
&lt;span class="cm"&gt;  loaded, is write protected */&lt;/span&gt;
&lt;span class="cp"&gt;#define FLASH_PROTECTED_SECTORS       (~(uint32_t)((1 &amp;lt;&amp;lt; FLASH_SECTOR_NUMBER) - 1))&lt;/span&gt;
&lt;span class="cm"&gt;/* Exported functions --------------------------------------------------*/&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;StartSector&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_GetWriteProtectionStatus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p_source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_WriteProtectionConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;modifier&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#endif  &lt;/span&gt;&lt;span class="cm"&gt;/* __FLASH_IF_H */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="cm"&gt;/******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;code&gt;flash_if.c&lt;/code&gt;修改后如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/** @addtogroup STM32F4xx_IAP&lt;/span&gt;
&lt;span class="cm"&gt;  * @{&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;

&lt;span class="cm"&gt;/* Includes -------------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cp"&gt;#include "flash_if.h"&lt;/span&gt;

&lt;span class="cm"&gt;/* Private typedef ------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private define -------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private macro --------------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private variables ----------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/* Private function prototypes ------------------------------------------*/&lt;/span&gt;
&lt;span class="c1"&gt;//增加获取扇区的函数，方便获取扇区编号&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* Private functions ----------------------------------------------------*/&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Unlocks Flash for write access&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* Unlock the Program memory */&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Clear all FLASH flags */&lt;/span&gt;
  &lt;span class="c1"&gt;//根据实际的MCU清除FLASH标志位&lt;/span&gt;
  &lt;span class="n"&gt;__HAL_FLASH_CLEAR_FLAG&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASH_FLAG_EOP&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;FLASH_FLAG_OPERR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;FLASH_FLAG_WRPERR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; 
                  &lt;span class="n"&gt;FLASH_FLAG_PGAERR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;FLASH_FLAG_PGPERR&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;FLASH_FLAG_PGSERR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="cm"&gt;/* Unlock the Program memory */&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  This function does an erase of all user flash area&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  start: start of user flash area&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval FLASHIF_OK : user flash area successfully erased&lt;/span&gt;
&lt;span class="cm"&gt;  *         FLASHIF_ERASEKO : error occurred&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//将相关的Page参数均修改为M4的Sector 参数&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;NbrOfSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;SectorError&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;FLASH_EraseInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;HAL_StatusTypeDef&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Unlock the Flash to enable the flash control register access *************/&lt;/span&gt; 
    &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* Get the sector where start the user flash area */&lt;/span&gt;
    &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;NbrOfSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_7&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TypeErase&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_TYPEERASE_SECTORS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Banks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_BANK_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NbSectors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NbrOfSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;VoltageRange&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_VOLTAGE_RANGE_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HAL_FLASHEx_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pEraseInit&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;SectorError&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="cm"&gt;/* Lock the Flash to disable the flash control register access (recommended&lt;/span&gt;
&lt;span class="cm"&gt;     to protect the FLASH memory against possible unwanted operation) *********/&lt;/span&gt;
    &lt;span class="n"&gt;HAL_FLASH_Lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Error occurred while Sector erase */&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_ERASEKO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* Public functions -----------------------------------------------------*/&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  This function writes a data buffer in flash (data are 32-bit aligned).&lt;/span&gt;
&lt;span class="cm"&gt;  * @note   After writing data buffer, the flash content is checked.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  destination: start address for target location&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  p_source: pointer on buffer with data to write&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  length: length of data buffer (unit is 32-bit word)&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval uint32_t 0: Data successfully written to Flash memory&lt;/span&gt;
&lt;span class="cm"&gt;  *         1: Error occurred while writing data in Flash memory&lt;/span&gt;
&lt;span class="cm"&gt;  *         2: Written Data in flash memory is different from expected one&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p_source&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Unlock the Flash to enable the flash control register access *************/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;destination&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;USER_FLASH_END_ADDRESS&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Device voltage range supposed to be [2.7V to 3.6V], the operation will&lt;/span&gt;
&lt;span class="cm"&gt;       be done by word */&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HAL_FLASH_Program&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASH_TYPEPROGRAM_WORD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;p_source&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      
    &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="cm"&gt;/* Check the written value */&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;destination&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;p_source&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Flash content doesn't match SRAM content */&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASHIF_WRITINGCTRL_ERROR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="cm"&gt;/* Increment FLASH destination address */&lt;/span&gt;
      &lt;span class="n"&gt;destination&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="cm"&gt;/* Error occurred while writing data in Flash memory */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASHIF_WRITING_ERROR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="cm"&gt;/* Lock the Flash to disable the flash control register access (recommended&lt;/span&gt;
&lt;span class="cm"&gt;     to protect the FLASH memory against possible unwanted operation) *********/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASHIF_OK&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Returns the write protection status of application flash area.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval If a sector in application area is write-protected returned value is a combinaison&lt;/span&gt;
&lt;span class="cm"&gt;            of the possible values : FLASHIF_PROTECTION_WRPENABLED, FLASHIF_PROTECTION_PCROPENABLED, ...&lt;/span&gt;
&lt;span class="cm"&gt;  *         If no sector is write-protected FLASHIF_PROTECTION_NONE is returned.&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_GetWriteProtectionStatus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_PROTECTION_NONE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;FLASH_OBProgramInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;OptionsBytesStruct&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Unlock the Flash to enable the flash control register access ********/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/*Check if there are write protected sectors inside the user flash area*/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASHEx_OBGetConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;OptionsBytesStruct&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* Lock the Flash to disable the flash control register access (recommended&lt;/span&gt;
&lt;span class="cm"&gt;     to protect the FLASH memory against possible unwanted operation) *********/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_Lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Get Sectors already write protected *********************************/&lt;/span&gt;
  &lt;span class="c1"&gt;//后面的保护区域，没有看懂，所以直接屏蔽掉了&lt;/span&gt;
  &lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;OptionsBytesStruct&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WRPSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Check if desired Sectors are already write protected ****************/&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Some sectors inside the user flash area are write protected */&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_PROTECTION_WRPENABLED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="cm"&gt;/* No write protected sectors inside the user flash area */&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_PROTECTION_NONE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Configure the write protection status of user flash area.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  protectionstate : FLASHIF_WRP_DISABLE or FLASHIF_WRP_ENABLE the protection&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval uint32_t FLASHIF_OK if change is applied.&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_WriteProtectionConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;protectionstate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;FLASH_OBProgramInitTypeDef&lt;/span&gt; &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;config_old&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;HAL_StatusTypeDef&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


  &lt;span class="cm"&gt;/* Get Sectors write protection status *********************************/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASHEx_OBGetConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;config_old&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* The parameter says whether we turn the protection on or off */&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WRPState&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;protectionstate&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_WRP_ENABLE&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;OB_WRPSTATE_ENABLE&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;OB_WRPSTATE_DISABLE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* We want to modify only the Write protection */&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OptionType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;OPTIONBYTE_WRP&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* No read protection, keep BOR and reset settings */&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RDPLevel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;OB_RDP_LEVEL_0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;USERConfig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;config_old&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;USERConfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="cm"&gt;/* Get Sectors already write protected *********************************/&lt;/span&gt;
  &lt;span class="c1"&gt;//后面的保护区域，没有看懂，所以直接屏蔽掉了&lt;/span&gt;
  &lt;span class="n"&gt;ProtectedSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;config_old&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WRPSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Unlock the Flash to enable the flash control register access *******/&lt;/span&gt; 
  &lt;span class="n"&gt;HAL_FLASH_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Unlock the Options Bytes ********************************************/&lt;/span&gt;
  &lt;span class="n"&gt;HAL_FLASH_OB_Unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Erase all the option Bytes ******************************************/&lt;/span&gt;
  &lt;span class="c1"&gt;//在HAL_F4的库中没有找到擦除命令位的函数，故在此注释掉&lt;/span&gt;
  &lt;span class="c1"&gt;//result = HAL_FLASHEx_OBErase();&lt;/span&gt;

  &lt;span class="c1"&gt;//if (result == HAL_OK)&lt;/span&gt;
  &lt;span class="c1"&gt;//{&lt;/span&gt;
  &lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WRPSector&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ProtectedSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HAL_FLASHEx_OBProgram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;config_new&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="c1"&gt;//}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;HAL_OK&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="nl"&gt;FLASHIF_OK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;FLASHIF_PROTECTION_ERRROR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  根据送入地址获取其所在扇区位置&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  需要知道所在扇区位置的地址&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval 扇区位置（FLASH_SECTOR_0——FLASH_SECTOR_7）&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="c1"&gt;//增加扇区编号的获取函数&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; 
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @}&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;

&lt;span class="cm"&gt;/******************* (C) COPYRIGHT STMicroelectronics *****END OF FILE****/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="keil"&gt;四、Keil需要修改的位置&lt;a class="headerlink" href="#keil" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、需要根据设置的APP程序起始的位置，设置KEIL中APP程序起始位置与程序空间大小&lt;/p&gt;
&lt;p&gt;&lt;img alt="Porting-AN4657-STM32Cube-IAP-using-UART-to-STM32F411VET6-image-0" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/7/Porting-AN4657-STM32Cube-IAP-using-UART-to-STM32F411VET6-image-0.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、需要在User选项卡中增加自定义处理字符串，&lt;code&gt;C:\Program Files\Keil\ARM\ARMCC\bin\fromelf.exe --bin -o .\存放bin的路径\bin文件的名称.bin .\Keil编译后生成的axf的路径\axf文件的名称.axf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Porting-AN4657-STM32Cube-IAP-using-UART-to-STM32F411VET6-image-1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/7/Porting-AN4657-STM32Cube-IAP-using-UART-to-STM32F411VET6-image-1.png"/&gt;&lt;/p&gt;
&lt;h1 id="_4"&gt;五、设置中断向量表偏移&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;需要在&lt;code&gt;main.c&lt;/code&gt;文件中的&lt;code&gt;/* USER CODE BEGIN 1 */&lt;/code&gt;和&lt;code&gt;/* USER CODE END 1 */&lt;/code&gt;之间增加一条设置中断向量表的语句&lt;code&gt;SCB-&amp;gt;VTOR = FLASH_BASE | 0x4000;&lt;/code&gt;，如下所示。&lt;/p&gt;
&lt;p&gt;main.c增加的代码示意如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* USER CODE BEGIN 1 */&lt;/span&gt;   
&lt;span class="n"&gt;SCB&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;VTOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_BASE&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mh"&gt;0x4000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cm"&gt;/* USER CODE END 1 */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="_5"&gt;六、结语&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。&lt;/p&gt;</summary><category term="IAP"></category><category term="STM32F411VET6"></category><category term="STM32CubeF4"></category></entry><entry><title>简单移植IAP（STSW-STM32067）到STM32F411VET6</title><link href="http://dhlx.wang/STM32F411VET6/Simple_transplant_IAP_STSW-STM32067_to_STM32F411VET6.html" rel="alternate"></link><updated>2015-06-12T12:15:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-06-12:STM32F411VET6/Simple_transplant_IAP_STSW-STM32067_to_STM32F411VET6.html</id><summary type="html">
&lt;p&gt;首先，我需要声明一下，本文所移植的IAP程序仅能用作参考，虽然加入了ymodem的通讯协议，提高了程序文件下载过程中的稳定性，但是由于移植的代码，本身就是示例程序，所以个人不建议直接用在工程中，但是可以作为工程测试、调试和个人DIY所用。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备移植程序和工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;我们在移植IAP的过程中主要用到以下三个东西，一个是STM32F411VET6的开发板，一个是待移植的官方的STM32F4-IAP-USART程序，最后一个就是上位机（支持ymodem），这里最好选用官方建议使用的超级终端（Hypertrm）进行测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1848/PF260946?s_searchtype=partnumber"&gt;32F411EDISCOVERY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.st.com/web/catalog/tools/FM147/CL1794/SC961/SS1743/LN1734/PF257903?s_searchtype=partnumber"&gt;STM32F4 IAP using the USART (AN3965)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hilgraeve.com/hyperterminal/"&gt;Hypertrm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt;二、修改串口通讯接口&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;由于STM32F411VET6中没有USART3，我需要将USART3的配置修改为USART2。这个里面我个人建议修改为与USART3在同一总线上的USART，否则需要进行大量的代码修改。由于我只是进行工程远程调试，暂时不考虑大费周章进行移植和修改，如果后续需要使用，可能会做基于HAL的移植，并对读取Flash的权限做出详细的限制。&lt;/p&gt;
&lt;p&gt;下面我们就开始正式的移植过程，我们需要修改工程中的&lt;code&gt;stm324xg_eval.h&lt;/code&gt;文件中关于USART的宏定义部分。&lt;/p&gt;
&lt;p&gt;原始宏定义如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief Definition for COM port1, connected to USART3&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt; 
&lt;span class="cp"&gt;#define EVAL_COM1                        USART3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_CLK                    RCC_APB1Periph_USART3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_PIN                 GPIO_Pin_10&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_GPIO_PORT           GPIOC&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_GPIO_CLK            RCC_AHB1Periph_GPIOC&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_SOURCE              GPIO_PinSource10&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_AF                  GPIO_AF_USART3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_PIN                 GPIO_Pin_11&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_GPIO_PORT           GPIOC&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_GPIO_CLK            RCC_AHB1Periph_GPIOC&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_SOURCE              GPIO_PinSource11&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_AF                  GPIO_AF_USART3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_IRQn                   USART3_IRQn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;修改后宏定义如下所示：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief Definition for COM port1, connected to USART2&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt; 
&lt;span class="cp"&gt;#define EVAL_COM1                        USART2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_CLK                    RCC_APB1Periph_USART2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_PIN                 GPIO_Pin_2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_GPIO_PORT           GPIOA&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_GPIO_CLK            RCC_AHB1Periph_GPIOA&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_SOURCE              GPIO_PinSource2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_TX_AF                  GPIO_AF_USART2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_PIN                 GPIO_Pin_3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_GPIO_PORT           GPIOA&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_GPIO_CLK            RCC_AHB1Periph_GPIOA&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_SOURCE              GPIO_PinSource3&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_RX_AF                  GPIO_AF_USART2&lt;/span&gt;
&lt;span class="cp"&gt;#define EVAL_COM1_IRQn                   USART2_IRQn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;P.S.注意您选择USART2的管脚分配，我这里分配的GPIOA2（TX）和GPIOA3（RX）。&lt;/p&gt;
&lt;h1 id="flash"&gt;三、修改Flash大小定义&lt;a class="headerlink" href="#flash" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;由于STM32F411VET6和STM32F407系列的Flash大小不一致，故需要简单修改下Flash的相关函数和定义。&lt;/p&gt;
&lt;p&gt;首先，我们需要修改&lt;code&gt;flash_if.c&lt;/code&gt;中&lt;code&gt;uint32_t FLASH_If_Erase&lt;/code&gt;的函数。&lt;/p&gt;
&lt;p&gt;原先函数的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* @brief  This function does an erase of all user flash area&lt;/span&gt;
&lt;span class="cm"&gt;* @param  StartSector: start of user flash area&lt;/span&gt;
&lt;span class="cm"&gt;* @retval 0: user flash area successfully erased&lt;/span&gt;
&lt;span class="cm"&gt;*         1: error occurred&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;StartSector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Get the sector where start the user flash area */&lt;/span&gt;
  &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Device voltage range supposed to be [2.7V to 3.6V], the operation will&lt;/span&gt;
&lt;span class="cm"&gt;       be done by word */&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASH_EraseSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VoltageRange_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;FLASH_COMPLETE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="cm"&gt;/* Error occurred while page erase */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;需要将&lt;code&gt;FLASH_Sector_11&lt;/code&gt;修改为&lt;code&gt;FLASH_Sector_7&lt;/code&gt;，修改后函数代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  This function does an erase of all user flash area&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  StartSector: start of user flash area&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval 0: user flash area successfully erased&lt;/span&gt;
&lt;span class="cm"&gt;  *         1: error occurred&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;FLASH_If_Erase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;StartSector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="cm"&gt;/* Get the sector where start the user flash area */&lt;/span&gt;
  &lt;span class="n"&gt;UserStartSector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UserStartSector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Device voltage range supposed to be [2.7V to 3.6V], the operation will&lt;/span&gt;
&lt;span class="cm"&gt;       be done by word */&lt;/span&gt; 
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FLASH_EraseSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;VoltageRange_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;FLASH_COMPLETE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="cm"&gt;/* Error occurred while page erase */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;其次我们需要修改&lt;code&gt;flash_if.c&lt;/code&gt;中的&lt;code&gt;static uint32_t GetSector&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;原先函数的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Gets the sector of a given address&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  Address: Flash address&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval The sector of a given address&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_9&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_9&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_11&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="cm"&gt;/*(Address &amp;lt; FLASH_END_ADDR) &amp;amp;&amp;amp; (Address &amp;gt;= ADDR_FLASH_SECTOR_11))*/&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;根据实际情况适当增删&lt;code&gt;FLASH_Sector&lt;/code&gt;，修改后函数代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Gets the sector of a given address&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  Address: Flash address&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval The sector of a given address&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="nf"&gt;GetSector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;ADDR_FLASH_SECTOR_6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; 
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sector&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FLASH_Sector_7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
  &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;sector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="main"&gt;四、修改Main函数&lt;a class="headerlink" href="#main" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;在移植过程中根据您的需要，修改Main函数，下面放上原Main函数和我个人根据&lt;code&gt;32F411EDISCOVERY&lt;/code&gt;修改后的Main函数。&lt;/p&gt;
&lt;p&gt;原先函数的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Main program.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* Unlock the Flash Program Erase controller */&lt;/span&gt;
  &lt;span class="n"&gt;FLASH_If_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Initialize Key Button mounted on STM324xG-EVAL board */&lt;/span&gt;
  &lt;span class="n"&gt;STM_EVAL_PBInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BUTTON_KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUTTON_MODE_GPIO&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* Test if Key push-button on STM324xG-EVAL Board is pressed */&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STM_EVAL_PBGetState&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BUTTON_KEY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="cm"&gt;/* Execute the IAP driver in order to reprogram the Flash */&lt;/span&gt;
    &lt;span class="n"&gt;IAP_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="cm"&gt;/* Display main menu */&lt;/span&gt;
    &lt;span class="n"&gt;Main_Menu&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="cm"&gt;/* Keep the user application running */&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Test if user code is programmed starting from address "APPLICATION_ADDRESS" */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x2FFE0000&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x20000000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; 
      &lt;span class="cm"&gt;/* Jump to user application */&lt;/span&gt;
      &lt;span class="n"&gt;JumpAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;Jump_To_Application&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pFunction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;JumpAddress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="cm"&gt;/* Initialize user application's Stack Pointer */&lt;/span&gt;
      &lt;span class="n"&gt;__set_MSP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="n"&gt;Jump_To_Application&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;根据&lt;code&gt;32F411EDISCOVERY&lt;/code&gt;修改后的代码如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Main program.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="cm"&gt;/* Unlock the Flash Program Erase controller */&lt;/span&gt;
  &lt;span class="n"&gt;FLASH_If_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

  &lt;span class="cm"&gt;/* Initialize Key Button mounted on STM324xG-EVAL board */&lt;/span&gt;
  &lt;span class="n"&gt;STM_EVAL_PBInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BUTTON_KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BUTTON_MODE_GPIO&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="cm"&gt;/* Test if Key push-button on STM324xG-EVAL Board is unpressed */&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STM_EVAL_PBGetState&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BUTTON_KEY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x00&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="cm"&gt;/* Test if user code is programmed starting from address "APPLICATION_ADDRESS" */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x2FFE0000&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mh"&gt;0x20000000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt; 
          &lt;span class="cm"&gt;/* Jump to user application */&lt;/span&gt;
          &lt;span class="n"&gt;JumpAddress&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;Jump_To_Application&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pFunction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;JumpAddress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
          &lt;span class="cm"&gt;/* Initialize user application's Stack Pointer */&lt;/span&gt;
          &lt;span class="n"&gt;__set_MSP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__IO&lt;/span&gt; &lt;span class="kt"&gt;uint32_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;APPLICATION_ADDRESS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;Jump_To_Application&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="cm"&gt;/* Keep the user application running */&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/* Execute the IAP driver in order to reprogram the Flash */&lt;/span&gt;
        &lt;span class="n"&gt;IAP_Init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="cm"&gt;/* Display main menu */&lt;/span&gt;
        &lt;span class="n"&gt;Main_Menu&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;h1 id="iap_init"&gt;五、修改IAP_Init函数&lt;a class="headerlink" href="#iap_init" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;根据您的实际情况修改&lt;code&gt;IAP_Init&lt;/code&gt;函数中的参数。&lt;/p&gt;
&lt;p&gt;原函数代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * @brief  Initialize the IAP: Configure USART.&lt;/span&gt;
&lt;span class="cm"&gt;  * @param  None&lt;/span&gt;
&lt;span class="cm"&gt;  * @retval None&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
void&lt;span class="w"&gt; &lt;/span&gt;IAP_Init&lt;span class="o"&gt;(&lt;/span&gt;void&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;USART_InitTypeDef&lt;span class="w"&gt; &lt;/span&gt;USART_InitStructure&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* USART resources configuration (Clock, GPIO pins and USART registers) ----*/&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/* USART configured as follow:&lt;/span&gt;
&lt;span class="cm"&gt;        - BaudRate = 115200 baud  &lt;/span&gt;
&lt;span class="cm"&gt;        - Word Length = 8 Bits&lt;/span&gt;
&lt;span class="cm"&gt;        - One Stop Bit&lt;/span&gt;
&lt;span class="cm"&gt;        - No parity&lt;/span&gt;
&lt;span class="cm"&gt;        - Hardware flow control disabled (RTS and CTS signals)&lt;/span&gt;
&lt;span class="cm"&gt;        - Receive and transmit enabled&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_BaudRate&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;115200&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;串口波特率&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_WordLength&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_WordLength_8b&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_StopBits&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_StopBits_1&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_Parity&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_Parity_No&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_HardwareFlowControl&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_HardwareFlowControl_None&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;.&lt;/span&gt;USART_Mode&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_Mode_Rx&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;USART_Mode_Tx&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;STM_EVAL_COMInit&lt;span class="o"&gt;(&lt;/span&gt;COM1&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;USART_InitStructure&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_3"&gt;六、结语&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;关于具体的下载流程及操作，我在这里就不多做叙述了，官方文档中说的已经非常清楚。本次移植过程也是个人摸索得出的，如果有不尽完善的地方，欢迎您提出，我进行验证更正。&lt;/p&gt;
&lt;p&gt;后续，如果我在工作之余或者工作中有需要，我可能会将IAP的代码移植到HAL库上，如果您已经做了相关工作，希望您可以在不涉及保密条款和其他利益的情况下，抄送一份给我，用于后续研究与参考。谢谢！&lt;/p&gt;</summary><category term="IAP"></category><category term="STM32F411VET6"></category><category term="STSW-STM32067"></category></entry><entry><title>Windows 8.1 Update 系统迁移</title><link href="http://dhlx.wang/Windows/Win8-1-Update-System-Migration.html" rel="alternate"></link><updated>2015-08-09T17:18:00+08:00</updated><author><name>郭世全</name></author><id>tag:dhlx.wang,2015-05-11:Windows/Win8-1-Update-System-Migration.html</id><summary type="html">
&lt;p&gt;上周的周末，新买的SSD硬盘到了，需要把旧系统盘的数据迁移至新的SSD上，最开始考虑了Winodws系统映像的方法进行迁移，但通过恢复U盘进入到恢复步骤时，总是提示我无法格式化硬盘，所以放弃了这个方案。&lt;/p&gt;
&lt;p&gt;在查询无数资料后，考虑到Win 8.1 Update的组成，突然灵光一现，尝试用Win 8.1的系统盘格式化新的SSD，从而使新的磁盘系统分区和原来的保持一致，通过备份分区数据，还原分区数据的方式，完成系统迁移。&lt;/p&gt;
&lt;p&gt;本文就是就是记录下这个操作流程，以备后人参考，如果您有更好的方法，请您不吝赐教，谢谢！&lt;/p&gt;
&lt;p&gt;废话也说完了，我们下面进入到正题。&lt;/p&gt;
&lt;h1 id="_1"&gt;一、准备工具&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://bbs.winpe.cc/thread-85876-1-1.html"&gt;天意u盘维护系统技术员版3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cn.ezbsystems.com/ultraiso/index.html"&gt;UltraISO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="ed2k://|file|cn_windows_8.1_with_update_x64_dvd_6051473.iso|4504475648|D66BEF759548656EDA981D902A957545|/"&gt;cn_windows_8.1_with_update_x64_dvd_6051473.iso&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="ed2k://|file|cn_windows_8.1_with_update_x86_dvd_6051523.iso|3349960704|C1B8A61BD8F1300825BF03C4D31B35A0|/"&gt;cn_windows_8.1_with_update_x86_dvd_6051523.iso&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://down.tech.sina.com.cn/content/54189.html"&gt;Windows 8 USB Installer Maker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.diskgenius.cn/download.php"&gt;DiskGenius v4.7.1 免费版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;16G U盘 可量产&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果遇到上述链接无法访问，请您自行想办法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;友情提示：中国拥有世界上第八大奇迹——长城。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id="winodws-81-upadate-u"&gt;二、制作Winodws 8.1 Upadate U盘安装盘&lt;a class="headerlink" href="#winodws-81-upadate-u" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这个大家应该已经很熟悉了吧！用我提供的Windows 8 USB Installer Maker工具，基本制作过程是傻瓜式安装。&lt;/p&gt;
&lt;h1 id="winodws-81-upadate"&gt;三、安装Winodws 8.1 Upadate到新系统盘&lt;a class="headerlink" href="#winodws-81-upadate" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这步我也就简单说下，基本上都会做，说一下几个需要注意的地方。&lt;/p&gt;
&lt;p&gt;1、重启进入Bios把安全启动关闭，以免后续从PE、U盘安装盘启动不了。
2、一定保证新盘的分区方式和旧盘一样，我一般采用的系统盘自动分区。
3、进入不进入系统都可以，等会儿都要覆盖的。&lt;/p&gt;
&lt;h1 id="upe"&gt;四、安装天意U盘PE&lt;a class="headerlink" href="#upe" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;这步在天意大大贴子中已经写的很清楚了，我就不重复给出制作U盘PE的教程了。这里仅给出一个UltraISO可用的用户名和注册码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;用户名：王涛 注册码：7C81-1689-4046-626F
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_2"&gt;五、备份旧系统盘数据&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、如下图所示，进入到天意PE中，打开DiskGenius。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-0" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-0.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、选中原系统分区，单机鼠标右键，可以看到备份分区到镜像文件，点击它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-1" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-1.png"/&gt;&lt;/p&gt;
&lt;p&gt;在这里您需要注意查看下旧系统分区的数据量是否远小于新系统盘的分区大小。&lt;/p&gt;
&lt;p&gt;3、选择文件路径，并点击开始，就可以开始备份了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-2" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-2.png"/&gt;&lt;/p&gt;
&lt;h1 id="_3"&gt;六、还原旧系统盘数据到新系统盘&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、选中新系统分区，单机鼠标右键，可以看到从镜像文件还原分区，点击它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-3" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-3.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、选择刚刚备份的文件，并点击开始，进行系统迁移。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-4" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-4.png"/&gt;&lt;/p&gt;
&lt;h1 id="_4"&gt;七、重新设置引导参数&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1、在天意PE中默认没有给引导分区指派盘符，所以我们需要找到系统的引导分区，单机鼠标右键，可以指派新的驱动器号，点击它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-5" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-5.png"/&gt;&lt;/p&gt;
&lt;p&gt;2、选择您想要赋予的盘符，选择它，记住它，并单击确定。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-6" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-6.png"/&gt;&lt;/p&gt;
&lt;p&gt;3、打开开始菜单，找到BIOS+UEFI引导修复工具，打开它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-7" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-7.png"/&gt;&lt;/p&gt;
&lt;p&gt;4、按照提示填写Windows系统分区盘符，引导分区盘符，并按下回车，确认信息后，再次按下回车。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Windows-8-1-Update-System-Migration-image-8" src="http://7xixm3.com1.z0.glb.clouddn.com/images/2015/5/Windows-8-1-Update-System-Migration-image-8.png"/&gt;&lt;/p&gt;
&lt;p&gt;5、出现上图最后一行的提示，您可以关闭程序，并重启电脑。&lt;/p&gt;
&lt;h1 id="_5"&gt;八、结语&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;以上就是我此次系统迁移的基本过程，如果您有没看懂的地方，您可以留言，我看到后会及时回复。&lt;/p&gt;
&lt;p&gt;P.S. 天意大大说我提供这个版本PE中DiskGenius有一些问题，但是在操作过程中我没有遇到，如果您遇到了，可以用DiskGenius的原版（在第一章节中有提供下载地址）尝试下。&lt;/p&gt;</summary><category term="Windows 8.1 Update"></category><category term="SSD"></category><category term="HDD"></category></entry></feed>